[{"categories":null,"content":" GO 语言中文网 polarisxu 脑子进煎鱼了 码农桃花源 luozhiyun很酷 Xargin 奇伢云存储 远赴星辰 五分选手 Mohuishou Tangwz 的博客 kakus 的博客 吴亲强的深夜食堂 欧长坤的博客 PYTHON爬虫与数据挖掘 董泽润的技术笔记 ","date":"0001-01-01","objectID":"https://asong2020.github.io/friend/:0:0","tags":null,"title":"友链","uri":"https://asong2020.github.io/friend/"},{"categories":["Go面试"],"content":"背景 哈喽，大家好，我是asong。今天与大家聊一聊Go语言中的零值。大学时期我是一名C语言爱好者，工作了以后感觉Go语言和C语言很像，所以选择了Go语言的工作，时不时就会把这两种语言的一些特性做个比较，今天要比较的就是零值特性。熟悉C语言的朋友知道在C语言中默认情况下不初始化局部变量。 未初始化的变量可以包含任何值，其使用会导致未定义的行为；如果我们未初始局部变量，在编译时就会报警告 C4700，这个警告指示一个Bug，这个Bug可能导致程序中出现不可预测的结果或故障。而在Go语言就不会有这样的问题，Go语言的设计者吸取了在设计C语言时的一些经验，所以Go语言的零值规范如下： 以下内容来自官方blog：https://golang.org/ref/spec#The_zero_value 当通过声明或 new 调用为变量分配存储空间时，或通过复合文字或 make 调用创建新值时，且未提供显式初始化，则给出变量或值一个默认值。此类变量或值的每个元素都为其类型设置为零值：布尔型为 false，数字类型为 0，字符串为 “\"，指针、函数、接口、切片、通道和映射为 nil。此初始化是递归完成的，例如，如果未指定任何值，则结构体数组的每个元素的字段都将其清零。 例如这两个简单的声明是等价的： var i int var i int = 0 在或者这个结构体的声明： type T struct { i int; f float64; next *T } t := new(T) 这个结构体t中成员字段零值如下： t.i == 0 t.f == 0.0 t.next == nil Go语言中这种始终将值设置为已知默认值的特性对于程序的安全性和正确性起到了很重要的作用，这样也使整个Go程序更简单、更紧凑。 ","date":"2021-09-21","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E9%9B%B6%E5%80%BC/:1:0","tags":["零值"],"title":"聊一聊Go语言中的零值，它有什么用？","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E9%9B%B6%E5%80%BC/"},{"categories":["Go面试"],"content":"零值有什么用 ","date":"2021-09-21","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E9%9B%B6%E5%80%BC/:2:0","tags":["零值"],"title":"聊一聊Go语言中的零值，它有什么用？","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E9%9B%B6%E5%80%BC/"},{"categories":["Go面试"],"content":"通过零值来提供默认值 我们在看一些Go语言库的时候，都会看到在初始化对象时采用\"动态初始化\"的模式，其实就是在创建对象时判断如果是零值就使用默认值，比如我们在分析hystrix-go这个库时，在配置Command时就是使用的这种方式： func ConfigureCommand(name string, config CommandConfig) { settingsMutex.Lock() defer settingsMutex.Unlock() timeout := DefaultTimeout if config.Timeout != 0 { timeout = config.Timeout } max := DefaultMaxConcurrent if config.MaxConcurrentRequests != 0 { max = config.MaxConcurrentRequests } volume := DefaultVolumeThreshold if config.RequestVolumeThreshold != 0 { volume = config.RequestVolumeThreshold } sleep := DefaultSleepWindow if config.SleepWindow != 0 { sleep = config.SleepWindow } errorPercent := DefaultErrorPercentThreshold if config.ErrorPercentThreshold != 0 { errorPercent = config.ErrorPercentThreshold } circuitSettings[name] = \u0026Settings{ Timeout: time.Duration(timeout) * time.Millisecond, MaxConcurrentRequests: max, RequestVolumeThreshold: uint64(volume), SleepWindow: time.Duration(sleep) * time.Millisecond, ErrorPercentThreshold: errorPercent, } } 通过零值判断进行默认值赋值，增强了Go程序的健壮性。 ","date":"2021-09-21","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E9%9B%B6%E5%80%BC/:2:1","tags":["零值"],"title":"聊一聊Go语言中的零值，它有什么用？","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E9%9B%B6%E5%80%BC/"},{"categories":["Go面试"],"content":"开箱即用 为什么叫开箱即用呢？因为Go语言的零值让程序变得更简单了，有些场景我们不需要显示初始化就可以直接用，举几个例子： 切片，他的零值是nil，即使不用make进行初始化也是可以直接使用的，例如： package main import ( \"fmt\" \"strings\" ) func main() { var s []string s = append(s, \"asong\") s = append(s, \"真帅\") fmt.Println(strings.Join(s, \" \")) } 但是零值也并不是万能的，零值切片不能直接进行赋值操作： var s []string s[0] = \"asong真帅\" 这样的程序就报错了。 方法接收者的归纳 利用零值可用的特性，我们配合空结构体的方法接受者特性，可以将方法组合起来，在业务代码中便于后续扩展和维护： type T struct{} func (t *T) Run() { fmt.Println(\"we run\") } func main() { var t T t.Run() } 我在一些开源项目中看到很多地方都这样使用了，这样的代码最结构化～。 标准库无需显示初始化 我们经常使用sync包中的mutex、once、waitgroup都是无需显示初始化即可使用，拿mutex包来举例说明，我们看到mutex的结构如下： type Mutex struct { state int32 sema uint32 } 这两个字段在未显示初始化时默认零值都是0，所以我们就看到上锁代码就针对这个特性来写的： func (m *Mutex) Lock() { // Fast path: grab unlocked mutex. if atomic.CompareAndSwapInt32(\u0026m.state, 0, mutexLocked) { if race.Enabled { race.Acquire(unsafe.Pointer(m)) } return } // Slow path (outlined so that the fast path can be inlined) m.lockSlow() } 原子操作交换时使用的old值就是0，这种设计让mutex调用者无需考虑对mutex的初始化则可以直接使用。 还有一些其他标准库也使用零值可用的特性，使用方法都一样，就不在举例了。 ","date":"2021-09-21","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E9%9B%B6%E5%80%BC/:2:2","tags":["零值"],"title":"聊一聊Go语言中的零值，它有什么用？","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E9%9B%B6%E5%80%BC/"},{"categories":["Go面试"],"content":"零值并不是万能 Go语言零值的设计大大便利了开发者，但是零值并不是万能的，有些场景下零值是不可以直接使用的： 未显示初始化的切片、map，他们可以直接操作，但是不能写入数据，否则会引发程序panic： var s []string s[0] = \"asong\" var m map[string]bool m[\"asong\"] = true 这两种写法都是错误的使用。 零值的指针 零值的指针就是指向nil的指针，无法直接进行运算，因为是没有无内容的地址： var p *uint32 *p++ // panic: panic: runtime error: invalid memory address or nil pointer dereference 这样才可以： func main() { var p *uint64 a := uint64(0) p = \u0026a *p++ fmt.Println(*p) // 1 } 零值的error类型 error内置接口类型是表示错误条件的常规接口，nil值表示没有错误，所以调用Error方法时类型error不能是零值，否则会引发panic： func main() { rs := res() fmt.Println(rs.Error()) } func res() error { return nil } panic: runtime error: invalid memory address or nil pointer dereference [signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x10a6f27] 闭包中的nil函数 在日常开发中我们会使用到闭包，但是这其中隐藏一个问题，如果我们函数忘记初始化了，那么就会引发panic： var f func(a,b,c int) func main(){ f(1,2,3) // panic: runtime error: invalid memory address or nil pointer dereference } 零值channels 我们都知道channels的默认值是nil，给定一个 nil channel c: \u003c-c 从 c 接收将永远阻塞 c \u003c- v 发送值到 c 会永远阻塞 close(c) 关闭 c 引发 panic 关于零值不可用的场景先介绍这些，掌握这些才能在日常开发中减少写bug的频率。 ","date":"2021-09-21","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E9%9B%B6%E5%80%BC/:3:0","tags":["零值"],"title":"聊一聊Go语言中的零值，它有什么用？","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E9%9B%B6%E5%80%BC/"},{"categories":["Go面试"],"content":"总结 总结一下本文叙说的几个知识点： Go语言中所有变量或者值都有默认值，对程序的安全性和正确性起到了很重要的作用 Go语言中的一些标准库利用零值特性来实现，简化操作 可以利用\"零值可用\"的特性可以提升代码的结构化、使代码更简单、更紧凑 零值也不是万能的，有一些场景下零值是不可用的，开发时要注意 好啦，本文就到这里了，素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！我是asong，我们下期见。 创建了读者交流群，欢迎各位大佬们踊跃入群，一起学习交流。入群方式：关注公众号获取。更多学习资料请到公众号领取。 推荐往期文章： 学习channel设计：从入门到放弃 详解内存对齐 [警惕] 请勿滥用goroutine 源码剖析panic与recover，看不懂你打我好了！ 面试官：小松子来聊一聊内存逃逸 面试官：两个nil比较结果是什么？ Go语言如何操纵Kafka保证无消息丢失 ","date":"2021-09-21","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E9%9B%B6%E5%80%BC/:4:0","tags":["零值"],"title":"聊一聊Go语言中的零值，它有什么用？","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E9%9B%B6%E5%80%BC/"},{"categories":["Go应用"],"content":"背景 目前一些互联网公司会使用消息队列来做核心业务，因为是核心业务，所以对数据的最后一致性比较敏感，如果中间出现数据丢失，就会引来用户的投诉，年底绩效就变成325了。之前和几个朋友聊天，他们的公司都在用kafka来做消息队列，使用kafka到底会不会丢消息呢？如果丢消息了该怎么做好补偿措施呢？ 本文我们就一起来分析一下，并介绍如何使用Go操作Kafka可以不丢失数据。 本文操作kafka基于：https://github.com/Shopify/sarama ","date":"2021-09-12","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E6%93%8D%E7%BA%B5kafka%E4%BF%9D%E8%AF%81%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1/:1:0","tags":["Kafka"],"title":"Go语言如何操纵Kafka保证无消息丢失","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E6%93%8D%E7%BA%B5kafka%E4%BF%9D%E8%AF%81%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1/"},{"categories":["Go应用"],"content":"初识kafka架构 维基百科对kafka的介绍： Kafka是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。该项目的目标是为处理实时数据提供一个统一、高吞吐、低延迟的平台。其持久化层本质上是一个“按照分布式事务日志架构的大规模发布/订阅消息队列”，这使它作为企业级基础设施来处理流式数据非常有价值。此外，Kafka可以通过Kafka Connect连接到外部系统（用于数据输入/输出），并提供了Kafka Streams——一个Java]流式处理库。 该设计受事务日志的影响较大。 kafka的整体架构比较简单，主要由producer、broker、consumer组成： 针对架构图我们解释一个各个模块： Producer：数据的生产者，可以将数据发布到所选择的topic中。 Consumer：数据的消费者，使用Consumer Group进行标识，在topic中的每条记录都会被分配给订阅消费组中的一个消费者实例，消费者实例可以分布在多个进程中或者多个机器上。 Broker：消息中间件处理节点（服务器），一个节点就是一个broker，一个Kafka集群由一个或多个broker组成。 还有些概念我们也介绍一下： topic：可以理解为一个消息的集合，topic存储在broker中，一个topic可以有多个partition分区，一个topic可以有多个Producer来push消息，一个topic可以有多个消费者向其pull消息，一个topic可以存在一个或多个broker中。 partition：其是topic的子集，不同分区分配在不同的broker上进行水平扩展从而增加kafka并行处理能力，同topic下的不同分区信息是不同的，同一分区信息是有序的；每一个分区都有一个或者多个副本，其中会选举一个leader，fowller从leader拉取数据更新自己的log（每个分区逻辑上对应一个log文件夹），消费者向leader中pull信息。 ","date":"2021-09-12","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E6%93%8D%E7%BA%B5kafka%E4%BF%9D%E8%AF%81%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1/:2:0","tags":["Kafka"],"title":"Go语言如何操纵Kafka保证无消息丢失","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E6%93%8D%E7%BA%B5kafka%E4%BF%9D%E8%AF%81%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1/"},{"categories":["Go应用"],"content":"kafka丢消息的三个节点 ","date":"2021-09-12","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E6%93%8D%E7%BA%B5kafka%E4%BF%9D%E8%AF%81%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1/:3:0","tags":["Kafka"],"title":"Go语言如何操纵Kafka保证无消息丢失","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E6%93%8D%E7%BA%B5kafka%E4%BF%9D%E8%AF%81%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1/"},{"categories":["Go应用"],"content":"生产者push消息节点 先看一下producer的大概写入流程： producer先从kafka集群找到该partition的leader producer将消息发送给leader，leader将该消息写入本地 follwers从leader pull消息，写入本地log后leader发送ack leader 收到所有 ISR 中的 replica 的 ACK 后，增加high watermark，并向 producer 发送 ack 通过这个流程我们可以看到kafka最终会返回一个ack来确认推送消息结果，这里kafka提供了三种模式： NoResponse RequiredAcks = 0 WaitForLocal RequiredAcks = 1 WaitForAll RequiredAcks = -1 NoResponse RequiredAcks = 0：这个代表的就是数据推出的成功与否都与我无关了 WaitForLocal RequiredAcks = 1：当local(leader)确认接收成功后，就可以返回了 WaitForAll RequiredAcks = -1：当所有的leader和follower都接收成功时，才会返回 所以根据这三种模式我们就能推断出生产者在push消息时有一定几率丢失的，分析如下： 如果我们选择了模式1，这种模式丢失数据的几率很大，无法重试 如果我们选择了模式2，这种模式下只要leader不挂，就可以保证数据不丢失，但是如果leader挂了，follower还没有同步数据，那么就会有一定几率造成数据丢失 如果选择了模式3，这种情况不会造成数据丢失，但是有可能会造成数据重复，假如leader与follower同步数据是网络出现问题，就有可能造成数据重复的问题。 所以在生产环境中我们可以选择模式2或者模式3来保证消息的可靠性，具体需要根据业务场景来进行选择，在乎吞吐量就选择模式2，不在乎吞吐量，就选择模式3，要想完全保证数据不丢失就选择模式3是最可靠的。 ","date":"2021-09-12","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E6%93%8D%E7%BA%B5kafka%E4%BF%9D%E8%AF%81%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1/:3:1","tags":["Kafka"],"title":"Go语言如何操纵Kafka保证无消息丢失","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E6%93%8D%E7%BA%B5kafka%E4%BF%9D%E8%AF%81%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1/"},{"categories":["Go应用"],"content":"kafka集群自身故障造成 kafka集群接收到数据后会将数据进行持久化存储，最终数据会被写入到磁盘中，在写入磁盘这一步也是有可能会造成数据损失的，因为写入磁盘的时候操作系统会先将数据写入缓存，操作系统将缓存中数据写入磁盘的时间是不确定的，所以在这种情况下，如果kafka机器突然宕机了，也会造成数据损失，不过这种概率发生很小，一般公司内部kafka机器都会做备份，这种情况很极端，可以忽略不计。 ","date":"2021-09-12","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E6%93%8D%E7%BA%B5kafka%E4%BF%9D%E8%AF%81%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1/:3:2","tags":["Kafka"],"title":"Go语言如何操纵Kafka保证无消息丢失","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E6%93%8D%E7%BA%B5kafka%E4%BF%9D%E8%AF%81%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1/"},{"categories":["Go应用"],"content":"消费者pull消息节点 push消息时会把数据追加到Partition并且分配一个偏移量，这个偏移量代表当前消费者消费到的位置，通过这个Partition也可以保证消息的顺序性，消费者在pull到某个消息后，可以设置自动提交或者手动提交commit，提交commit成功，offset就会发生偏移: 所以自动提交会带来数据丢失的问题，手动提交会带来数据重复的问题，分析如下： 在设置自动提交的时候，当我们拉取到一个消息后，此时offset已经提交了，但是我们在处理消费逻辑的时候失败了，这就会导致数据丢失了 在设置手动提交时，如果我们是在处理完消息后提交commit，那么在commit这一步发生了失败，就会导致重复消费的问题。 比起数据丢失，重复消费是符合业务预期的，我们可以通过一些幂等性设计来规避这个问题。 ","date":"2021-09-12","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E6%93%8D%E7%BA%B5kafka%E4%BF%9D%E8%AF%81%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1/:3:3","tags":["Kafka"],"title":"Go语言如何操纵Kafka保证无消息丢失","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E6%93%8D%E7%BA%B5kafka%E4%BF%9D%E8%AF%81%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1/"},{"categories":["Go应用"],"content":"实战 完整代码已经上传github：https://github.com/asong2020/Golang_Dream/tree/master/code_demo/kafka_demo ","date":"2021-09-12","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E6%93%8D%E7%BA%B5kafka%E4%BF%9D%E8%AF%81%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1/:4:0","tags":["Kafka"],"title":"Go语言如何操纵Kafka保证无消息丢失","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E6%93%8D%E7%BA%B5kafka%E4%BF%9D%E8%AF%81%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1/"},{"categories":["Go应用"],"content":"解决push消息丢失问题 主要是通过两点来解决： 通过设置RequiredAcks模式来解决，选用WaitForAll可以保证数据推送成功，不过会影响时延时 引入重试机制，设置重试次数和重试间隔 因此我们写出如下代码（摘出创建client部分）： func NewAsyncProducer() sarama.AsyncProducer { cfg := sarama.NewConfig() version, err := sarama.ParseKafkaVersion(VERSION) if err != nil{ log.Fatal(\"NewAsyncProducer Parse kafka version failed\", err.Error()) return nil } cfg.Version = version cfg.Producer.RequiredAcks = sarama.WaitForAll // 三种模式任君选择 cfg.Producer.Partitioner = sarama.NewHashPartitioner cfg.Producer.Return.Successes = true cfg.Producer.Return.Errors = true cfg.Producer.Retry.Max = 3 // 设置重试3次 cfg.Producer.Retry.Backoff = 100 * time.Millisecond cli, err := sarama.NewAsyncProducer([]string{ADDR}, cfg) if err != nil{ log.Fatal(\"NewAsyncProducer failed\", err.Error()) return nil } return cli } ","date":"2021-09-12","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E6%93%8D%E7%BA%B5kafka%E4%BF%9D%E8%AF%81%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1/:4:1","tags":["Kafka"],"title":"Go语言如何操纵Kafka保证无消息丢失","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E6%93%8D%E7%BA%B5kafka%E4%BF%9D%E8%AF%81%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1/"},{"categories":["Go应用"],"content":"解决pull消息丢失问题 这个解决办法就比较粗暴了，直接使用自动提交的模式，在每次真正消费完之后在自己手动提交offset，但是会产生重复消费的问题，不过很好解决，使用幂等性操作即可解决。 代码示例： func NewConsumerGroup(group string) sarama.ConsumerGroup { cfg := sarama.NewConfig() version, err := sarama.ParseKafkaVersion(VERSION) if err != nil{ log.Fatal(\"NewConsumerGroup Parse kafka version failed\", err.Error()) return nil } cfg.Version = version cfg.Consumer.Group.Rebalance.Strategy = sarama.BalanceStrategyRange cfg.Consumer.Offsets.Initial = sarama.OffsetOldest cfg.Consumer.Offsets.Retry.Max = 3 cfg.Consumer.Offsets.AutoCommit.Enable = true // 开启自动提交，需要手动调用MarkMessage才有效 cfg.Consumer.Offsets.AutoCommit.Interval = 1 * time.Second // 间隔 client, err := sarama.NewConsumerGroup([]string{ADDR}, group, cfg) if err != nil { log.Fatal(\"NewConsumerGroup failed\", err.Error()) } return client } 上面主要是创建ConsumerGroup部分，细心的读者应该看到了，我们这里使用的是自动提交，说好的使用手动提交呢？这是因为我们这个kafka库的特性不同，这个自动提交需要与MarkMessage()方法配合使用才会提交(有疑问的朋友可以实践一下，或者看一下源码)，否则也会提交失败，因为我们在写消费逻辑时要这样写： func (e EventHandler) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error { for msg := range claim.Messages() { var data common.KafkaMsg if err := json.Unmarshal(msg.Value, \u0026data); err != nil { return errors.New(\"failed to unmarshal message err is \" + err.Error()) } // 操作数据，改用打印 log.Print(\"consumerClaim data is \") // 处理消息成功后标记为处理, 然后会自动提交 session.MarkMessage(msg,\"\") } return nil } 或者直接使用手动提交方法来解决，只需两步： 第一步：关闭自动提交： consumerConfig.Consumer.Offsets.AutoCommit.Enable = false // 禁用自动提交，改为手动 第二步：消费逻辑中添加如下代码，手动提交模式下，也需要先进行标记，在进行commit session.MarkMessage(msg,\"\") session.Commit() 完整代码可以到github上下载并进行验证！ ","date":"2021-09-12","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E6%93%8D%E7%BA%B5kafka%E4%BF%9D%E8%AF%81%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1/:4:2","tags":["Kafka"],"title":"Go语言如何操纵Kafka保证无消息丢失","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E6%93%8D%E7%BA%B5kafka%E4%BF%9D%E8%AF%81%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1/"},{"categories":["Go应用"],"content":"总结 本文我们主要说明了两个知识点： Kafka会产生消息丢失 使用Go操作Kafka如何配置可以不丢失数据 日常业务开发中，很多公司都喜欢拿消息队列进行解耦，那么你就要注意了，使用Kafka做消息队列无法保证数据不丢失，需要我们自己手动配置补偿，别忘记了，要不又是一场P0事故。 素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！我是asong，我们下期见。 创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：关注公众号获取。更多学习资料请到公众号领取。 推荐往期文章： 学习channel设计：从入门到放弃 详解内存对齐 [警惕] 请勿滥用goroutine 源码剖析panic与recover，看不懂你打我好了！ 面试官：小松子来聊一聊内存逃逸 面试官：你能聊聊string和[]byte的转换吗？ 面试官：两个nil比较结果是什么？ 并发编程包之 errgroup ","date":"2021-09-12","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E6%93%8D%E7%BA%B5kafka%E4%BF%9D%E8%AF%81%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1/:5:0","tags":["Kafka"],"title":"Go语言如何操纵Kafka保证无消息丢失","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E6%93%8D%E7%BA%B5kafka%E4%BF%9D%E8%AF%81%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1/"},{"categories":["Go应用"],"content":"背景 伴随着微服务架构被宣传得如火如茶，一些概念也被推到了我们的面前。一提到微服务，就离不开这几个字：高内聚低耦合；微服务的架构设计最终目的也就是实现这几个字。在微服务架构中，微服务就是完成一个单一的业务功能，每个微服务可以独立演进，一个应用可能会有多个微服务组成，微服务之间的数据交可以通过远程调用来完成，这样在一个微服务架构下就会形成这样的依赖关系： 微服务A调用微服务C、D，微服务B又依赖微服务B、E，微服务D依赖于服务F，这只是一个简单的小例子，实际业务中服务之间的依赖关系比这还复杂，这样在调用链路上如果某个微服务的调用响应时间过长或者不可用，那么对上游服务(按调用关系命名)的调用就会占用越来越多的系统资源，进而引起系统崩溃，这就是微服务的雪蹦效应。 为了解决微服务的雪蹦效应，提出来使用熔断机制为微服务链路提供保护机制。熔断机制大家应该都不陌生，电路的中保险丝就是一种熔断机制，在微服务中的熔断机制是什么样的呢？ 当链路中的某个微服务不可用或者响应的时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息，当检测到该节点微服务调用响应正常后，恢复调用链路。 本文我们就介绍一个开源熔断框架：hystrix-go。 ","date":"2021-09-05","objectID":"https://asong2020.github.io/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E7%86%94%E6%96%AD%E6%A1%86%E6%9E%B6-hystrixgo/:1:0","tags":["微服务"],"title":"微服务架构下的熔断框架:hystrix-go","uri":"https://asong2020.github.io/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E7%86%94%E6%96%AD%E6%A1%86%E6%9E%B6-hystrixgo/"},{"categories":["Go应用"],"content":"熔断框架（hystrix-go） Hystrix是一个延迟和容错库，旨在隔离对远程系统、服务和第三方服务的访问点，停止级联故障并在故障不可避免的复杂分布式系统中实现弹性。hystrix-go 旨在允许 Go 程序员轻松构建具有与基于 Java 的 Hystrix 库类似的执行语义的应用程序。所以本文就从使用开始到源码分析一下hystrix-go。 ","date":"2021-09-05","objectID":"https://asong2020.github.io/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E7%86%94%E6%96%AD%E6%A1%86%E6%9E%B6-hystrixgo/:2:0","tags":["微服务"],"title":"微服务架构下的熔断框架:hystrix-go","uri":"https://asong2020.github.io/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E7%86%94%E6%96%AD%E6%A1%86%E6%9E%B6-hystrixgo/"},{"categories":["Go应用"],"content":"快速安装 go get -u github.com/afex/hystrix-go/hystrix ","date":"2021-09-05","objectID":"https://asong2020.github.io/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E7%86%94%E6%96%AD%E6%A1%86%E6%9E%B6-hystrixgo/:2:1","tags":["微服务"],"title":"微服务架构下的熔断框架:hystrix-go","uri":"https://asong2020.github.io/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E7%86%94%E6%96%AD%E6%A1%86%E6%9E%B6-hystrixgo/"},{"categories":["Go应用"],"content":"快速使用 hystrix-go真的是开箱即用，使用还是比较简单的，主要分为两个步骤： 配置熔断规则，否则将使用默认配置。可以调用的方法 func Configure(cmds map[string]CommandConfig) func ConfigureCommand(name string, config CommandConfig) Configure方法内部也是调用的ConfigureCommand方法，就是传参数不一样，根据自己的代码风格选择。 定义依赖于外部系统的应用程序逻辑 - runFunc 和服务中断期间执行的逻辑代码 - fallbackFunc，可以调用的方法： func Go(name string, run runFunc, fallback fallbackFunc) // 内部调用Goc方法 func GoC(ctx context.Context, name string, run runFuncC, fallback fallbackFuncC) func Do(name string, run runFunc, fallback fallbackFunc) // 内部调用的是Doc方法 func DoC(ctx context.Context, name string, run runFuncC, fallback fallbackFuncC) // 内部调用Goc方法，处理了异步过程 Go和Do的区别在于异步还是同步，Do方法在调用Doc方法内处理了异步过程，他们最终都是调用的Goc方法。后面我们进行分析。 举一个例子：我们在Gin框架上加一个接口级的熔断中间件 // 代码已上传github: 文末查看地址 var CircuitBreakerName = \"api_%s_circuit_breaker\" func CircuitBreakerWrapper(ctx *gin.Context){ name := fmt.Sprintf(CircuitBreakerName,ctx.Request.URL) hystrix.Do(name, func() error { ctx.Next() code := ctx.Writer.Status() if code != http.StatusOK{ return errors.New(fmt.Sprintf(\"status code %d\", code)) } return nil }, func(err error) error { if err != nil{ // 监控上报（未实现） _, _ = io.WriteString(f, fmt.Sprintf(\"circuitBreaker and err is %s\\n\",err.Error())) //写入文件(字符串) fmt.Printf(\"circuitBreaker and err is %s\\n\",err.Error()) // 返回熔断错误 ctx.JSON(http.StatusServiceUnavailable,gin.H{ \"msg\": err.Error(), }) } return nil }) } func init() { hystrix.ConfigureCommand(CircuitBreakerName,hystrix.CommandConfig{ Timeout: int(3*time.Second), // 执行command的超时时间为3s MaxConcurrentRequests: 10, // command的最大并发量 RequestVolumeThreshold: 100, // 统计窗口10s内的请求数量，达到这个请求数量后才去判断是否要开启熔断 SleepWindow: int(2 * time.Second), // 当熔断器被打开后，SleepWindow的时间就是控制过多久后去尝试服务是否可用了 ErrorPercentThreshold: 20, // 错误百分比，请求数量大于等于RequestVolumeThreshold并且错误率到达这个百分比后就会启动熔断 }) if checkFileIsExist(filename) { //如果文件存在 f, errfile = os.OpenFile(filename, os.O_APPEND, 0666) //打开文件 } else { f, errfile = os.Create(filename) //创建文件 } } func main() { defer f.Close() hystrixStreamHandler := hystrix.NewStreamHandler() hystrixStreamHandler.Start() go http.ListenAndServe(net.JoinHostPort(\"\", \"81\"), hystrixStreamHandler) r := gin.Default() r.GET(\"/api/ping/baidu\", func(c *gin.Context) { _, err := http.Get(\"https://www.baidu.com\") if err != nil { c.JSON(http.StatusInternalServerError, gin.H{\"msg\": err.Error()}) return } c.JSON(http.StatusOK, gin.H{\"msg\": \"success\"}) }, CircuitBreakerWrapper) r.Run() // listen and serve on 0.0.0.0:8080 (for windows \"localhost:8080\") } func checkFileIsExist(filename string) bool { if _, err := os.Stat(filename); os.IsNotExist(err) { return false } return true } 指令：wrk -t100 -c100 -d1s http://127.0.0.1:8080/api/ping/baidu 运行结果： circuitBreaker and err is status code 500 circuitBreaker and err is status code 500 ..... circuitBreaker and err is hystrix: max concurrency circuitBreaker and err is hystrix: max concurrency ..... circuitBreaker and err is hystrix: circuit open circuitBreaker and err is hystrix: circuit open ..... 对错误进行分析： circuitBreaker and err is status code 500：因为我们关闭了网络，所以请求是没有响应的 circuitBreaker and err is hystrix: max concurrency：我们设置的最大并发量MaxConcurrentRequests是10，我们的压测工具使用的是100并发，所有会触发这个熔断 circuitBreaker and err is hystrix: circuit open：我们设置熔断开启的请求数量RequestVolumeThreshold是100，所以当10s内的请求数量大于100时就会触发熔断。 简单对上面的例子做一个解析： 添加接口级的熔断中间件 初始化熔断相关配置 开启dashboard 可视化hystrix的上报信息，浏览器打开http://localhost:81，可以看到如下结果： ","date":"2021-09-05","objectID":"https://asong2020.github.io/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E7%86%94%E6%96%AD%E6%A1%86%E6%9E%B6-hystrixgo/:2:2","tags":["微服务"],"title":"微服务架构下的熔断框架:hystrix-go","uri":"https://asong2020.github.io/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E7%86%94%E6%96%AD%E6%A1%86%E6%9E%B6-hystrixgo/"},{"categories":["Go应用"],"content":"hystrix-go流程分析 本来想对源码进行分析，代码量有点大，所以就针对流程来分析，顺便看一些核心代码。 配置熔断规则 既然是熔断，就要有熔断规则，我们可以调用两个方法配置熔断规则，不会最终调用的都是ConfigureCommand，这里没有特别的逻辑，如果我们没有配置，系统将使用默认熔断规则： var ( // DefaultTimeout is how long to wait for command to complete, in milliseconds DefaultTimeout = 1000 // DefaultMaxConcurrent is how many commands of the same type can run at the same time DefaultMaxConcurrent = 10 // DefaultVolumeThreshold is the minimum number of requests needed before a circuit can be tripped due to health DefaultVolumeThreshold = 20 // DefaultSleepWindow is how long, in milliseconds, to wait after a circuit opens before testing for recovery DefaultSleepWindow = 5000 // DefaultErrorPercentThreshold causes circuits to open once the rolling measure of errors exceeds this percent of requests DefaultErrorPercentThreshold = 50 // DefaultLogger is the default logger that will be used in the Hystrix package. By default prints nothing. DefaultLogger = NoopLogger{} ) 配置规则如下： Timeout：定义执行command的超时时间，时间单位是ms，默认时间是1000ms； MaxConcurrnetRequests：定义command的最大并发量，默认值是10并发量； SleepWindow：熔断器被打开后使用，在熔断器被打开后，根据SleepWindow设置的时间控制多久后尝试服务是否可用，默认时间为5000ms； RequestVolumeThreshold：判断熔断开关的条件之一，统计10s（代码中写死了）内请求数量，达到这个请求数量后再根据错误率判断是否要开启熔断； ErrorPercentThreshold：判断熔断开关的条件之一，统计错误百分比，请求数量大于等于RequestVolumeThreshold并且错误率到达这个百分比后就会启动熔断 默认值是50； 这些规则根据command的name进行区分存放到一个map中。 执行command 执行command主要可以调用四个方法，分别是： func Go(name string, run runFunc, fallback fallbackFunc) func GoC(ctx context.Context, name string, run runFuncC, fallback fallbackFuncC) func Do(name string, run runFunc, fallback fallbackFunc) func DoC(ctx context.Context, name string, run runFuncC, fallback fallbackFuncC) Do内部调用的Doc方法，Go内部调用的是Goc方法，在Doc方法内部最终调用的还是Goc方法，只是在Doc方法内做了同步逻辑： func DoC(ctx context.Context, name string, run runFuncC, fallback fallbackFuncC) error { ..... 省略部分封装代码 var errChan chan error if fallback == nil { errChan = GoC(ctx, name, r, nil) } else { errChan = GoC(ctx, name, r, f) } select { case \u003c-done: return nil case err := \u003c-errChan: return err } } 因为他们最终都是调用的Goc方法，所以我们执行分析Goc方法的内部逻辑；代码有点长，我们分逻辑来分析： 创建command对象 cmd := \u0026command{ run: run, fallback: fallback, start: time.Now(), errChan: make(chan error, 1), finished: make(chan bool, 1), } // 获取熔断器 circuit, _, err := GetCircuit(name) if err != nil { cmd.errChan \u003c- err return cmd.errChan } 介绍一下command的数据结构： type command struct { sync.Mutex ticket *struct{} start time.Time errChan chan error finished chan bool circuit *CircuitBreaker run runFuncC fallback fallbackFuncC runDuration time.Duration events []string } 字段介绍： ticket：用来做最大并发量控制，这个就是一个令牌 start：记录command执行的开始时间 errChan：记录command执行错误 finished：标志command执行结束，用来做协程同步 circuit：存储熔断器相关信息 run：应用程序 fallback：应用程序执行失败后要执行的函数 runDuration：记录command执行消耗时间 events：events主要是存储事件类型信息，比如执行成功的success，或者失败的timeout、context_canceled等 上段代码重点是GetCircuit方法，这一步的目的就是获取熔断器，使用动态加载的方式，如果没有就创建一个熔断器，熔断器结构如下： type CircuitBreaker struct { Name string open bool forceOpen bool mutex *sync.RWMutex openedOrLastTestedTime int64 executorPool *executorPool metrics *metricExchange } 解释一下这几个字段： name：熔断器的名字，其实就是创建的command名字 open：判断熔断器是否打开的标志 forceopen：手动触发熔断器的开关，单元测试使用 mutex：使用读写锁保证并发安全 openedOrLastTestedTime：记录上一次打开熔断器的时间，因为要根据这个时间和SleepWindow时间来做恢复尝试 executorPool：用来做流量控制，因为我们有一个最大并发量控制，就是根据这个来做的流量控制，每次请求都要获取令牌 metrics：用来上报执行状态的事件，通过它把执行状态信息存储到实际熔断器执行各个维度状态 (成功次数，失败次数，超时……) 的数据集合中。 后面会单独分析executorPool、metrics的实现逻辑。 定义令牌相关的方法和变量 因为我们有一个条件是最大并发控制，采用的是令牌的方式进行流量控制，每一个请求都要获取一个令牌，使用完毕要把令牌还回去，先看一下这段代码： ticketCond := sync.NewCond(cmd) ticketChecked := false // When the caller extracts error from returned errChan, it's assumed that // the ticket's been returned to executorPool. Therefore, returnTicket() can // not run after cmd.errorWithFallback(). returnTicket := func() { cmd.Lock() // Avoid releasing before a ticket is acquired. for !ticketChecked { ticketCond.Wait() } cmd.circuit.executorPool.Return(cmd.ticket) cmd.Unlock() } 使用sync.NewCond创建一个条件变量，用来协调通知你可以归还令牌了。 然后定义一个返回令牌的方法，调用Return方法归还令牌。 定义上报执行事件的方法 前面我们也提到了，我们的熔断器会上报执行状态的事件，通过它把执行状态信息存储到实际熔断器执行","date":"2021-09-05","objectID":"https://asong2020.github.io/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E7%86%94%E6%96%AD%E6%A1%86%E6%9E%B6-hystrixgo/:2:3","tags":["微服务"],"title":"微服务架构下的熔断框架:hystrix-go","uri":"https://asong2020.github.io/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E7%86%94%E6%96%AD%E6%A1%86%E6%9E%B6-hystrixgo/"},{"categories":["Go应用"],"content":"总结 故事终于接近尾声了，一个熔断机制的实现确实不简单，要考虑的因素也是方方面面，尤其在微服务架构下，熔断机制是必不可少的，不仅要在框架层面实现熔断机制，还要根据具体业务场景使用熔断机制，这些都是值得我们深思熟虑的。本文介绍的熔断框架实现的还是比较完美的，这种优秀的设计思路值得我们学习。 文中代码已上传github：https://github.com/asong2020/Golang_Dream/tree/master/code_demo/hystrix_demo，欢迎star。 素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！我是asong，我们下期见。 创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：关注公众号获取。更多学习资料请到公众号领取。 推荐往期文章： 学习channel设计：从入门到放弃 详解内存对齐 [警惕] 请勿滥用goroutine 源码剖析panic与recover，看不懂你打我好了！ 面试官：小松子来聊一聊内存逃逸 面试官：你能聊聊string和[]byte的转换吗？ 面试官：两个nil比较结果是什么？ 并发编程包之 errgroup ","date":"2021-09-05","objectID":"https://asong2020.github.io/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E7%86%94%E6%96%AD%E6%A1%86%E6%9E%B6-hystrixgo/:3:0","tags":["微服务"],"title":"微服务架构下的熔断框架:hystrix-go","uri":"https://asong2020.github.io/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E7%86%94%E6%96%AD%E6%A1%86%E6%9E%B6-hystrixgo/"},{"categories":["Go应用"],"content":"前言 哈喽，大家好，我是asong。在写上一篇文章请勿滥用goroutine时，发现Go语言扩展包提供了一个带权重的信号量库Semaphore，使用信号量我们可以实现一个\"工作池\"控制一定数量的goroutine并发工作。因为对源码抱有好奇的态度，所以在周末仔细看了一下这个库并进行了解析，在这里记录一下。 ","date":"2021-08-29","objectID":"https://asong2020.github.io/go%E5%AE%98%E6%96%B9%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%BA%93/:1:0","tags":["信号量"],"title":"源码赏析Go官方扩展信号量库Semaphore","uri":"https://asong2020.github.io/go%E5%AE%98%E6%96%B9%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%BA%93/"},{"categories":["Go应用"],"content":"何为信号量 要想知道一个东西是什么，我都爱去百度百科上搜一搜，输入\"信号量\"，这答案不就来了。 百度百科解释： 信号量(Semaphore)，有时被称为信号灯，是[多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用。在进入一个关键代码段之前，线程必须获取一个信号量；一旦该关键代码段完成了，那么该线程必须释放信号量。其它想进入该关键代码段的线程必须等待直到第一个线程释放信号量。为了完成这个过程，需要创建一个信号量VI，然后将Acquire Semaphore VI以及Release Semaphore VI分别放置在每个关键代码段的首末端。确认这些信号量VI引用的是初始创建的信号量。 通过这段解释我们可以得知什么是信号量，其实信号量就是一种变量或者抽象数据类型，用于控制并发系统中多个进程对公共资源的访问，访问具有原子性。信号量主要分为两类： 二值信号量：顾名思义，其值只有两种0或者1，相当于互斥量，当值为1时资源可用，当值为0时，资源被锁住，进程阻塞无法继续执行。 计数信号量：信号量是一个任意的整数，起始时，如果计数器的计数值为0，那么创建出来的信号量就是不可获得的状态，如果计数器的计数值大于0，那么创建出来的信号量就是可获得的状态，并且总共获取的次数等于计数器的值。 ","date":"2021-08-29","objectID":"https://asong2020.github.io/go%E5%AE%98%E6%96%B9%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%BA%93/:2:0","tags":["信号量"],"title":"源码赏析Go官方扩展信号量库Semaphore","uri":"https://asong2020.github.io/go%E5%AE%98%E6%96%B9%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%BA%93/"},{"categories":["Go应用"],"content":"信号量工作原理 信号量是由操作系统来维护的，信号量只能进行两种操作等待和发送信号，操作总结来说，核心就是PV操作： P原语：P是荷兰语Proberen(测试)的首字母。为阻塞原语，负责把当前进程由运行状态转换为阻塞状态，直到另外一个进程唤醒它。操作为：申请一个空闲资源(把信号量减1)，若成功，则退出；若失败，则该进程被阻塞； V原语：V是荷兰语Verhogen(增加)的首字母。为唤醒原语，负责把一个被阻塞的进程唤醒，它有一个参数表，存放着等待被唤醒的进程信息。操作为：释放一个被占用的资源(把信号量加1)，如果发现有被阻塞的进程，则选择一个唤醒之。 在信号量进行PV操作时都为原子操作，并且在PV原语执行期间不允许有中断的发生。 PV原语对信号量的操作可以分为三种情况： 把信号量视为某种类型的共享资源的剩余个数，实现对一类共享资源的访问 把信号量用作进程间的同步 视信号量为一个加锁标志，实现对一个共享变量的访问 具体在什么场景使用本文就不在继续分析，接下来我们重点来看一下Go语言提供的扩展包Semaphore，看看它是怎样实现的。 ","date":"2021-08-29","objectID":"https://asong2020.github.io/go%E5%AE%98%E6%96%B9%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%BA%93/:3:0","tags":["信号量"],"title":"源码赏析Go官方扩展信号量库Semaphore","uri":"https://asong2020.github.io/go%E5%AE%98%E6%96%B9%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%BA%93/"},{"categories":["Go应用"],"content":"官方扩展包Semaphore 我们之前在分析Go语言源码时总会看到这几个函数： func runtime_Semacquire(s *uint32) func runtime_SemacquireMutex(s *uint32, lifo bool, skipframes int) func runtime_Semrelease(s *uint32, handoff bool, skipframes int) 这几个函数就是信号量的PV操作，不过他们都是给Go内部使用的，如果想使用信号量，那就可以使用官方的扩展包：Semaphore，这是一个带权重的信号量，接下来我们就重点分析一下这个库。 安装方法：go get -u golang.org/x/sync ","date":"2021-08-29","objectID":"https://asong2020.github.io/go%E5%AE%98%E6%96%B9%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%BA%93/:4:0","tags":["信号量"],"title":"源码赏析Go官方扩展信号量库Semaphore","uri":"https://asong2020.github.io/go%E5%AE%98%E6%96%B9%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%BA%93/"},{"categories":["Go应用"],"content":"数据结构 type Weighted struct { size int64 // 设置一个最大权值 cur int64 // 标识当前已被使用的资源数 mu sync.Mutex // 提供临界区保护 waiters list.List // 阻塞等待的调用者列表 } semaphore库核心结构就是Weighted，主要有4个字段： size：这个代表的是最大权值，在创建Weighted对象指定 cur：相当于一个游标，来记录当前已使用的权值 mu：互斥锁，并发情况下做临界区保护 waiters：阻塞等待的调用者列表，使用链表数据结构保证先进先出的顺序，存储的数据是waiter对象，waiter数据结构如下： type waiter struct { n int64 // 等待调用者权重值 ready chan\u003c- struct{} // close channel就是唤醒 } 这里只有两个字段： n：这个就是等待调用者的权重值 ready：这就是一个channel，利用channel的close机制实现唤醒 semaphore还提供了一个创建Weighted对象的方法，在初始化时需要给定最大权值： // NewWeighted为并发访问创建一个新的加权信号量，该信号量具有给定的最大权值。 func NewWeighted(n int64) *Weighted { w := \u0026Weighted{size: n} return w } ","date":"2021-08-29","objectID":"https://asong2020.github.io/go%E5%AE%98%E6%96%B9%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%BA%93/:4:1","tags":["信号量"],"title":"源码赏析Go官方扩展信号量库Semaphore","uri":"https://asong2020.github.io/go%E5%AE%98%E6%96%B9%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%BA%93/"},{"categories":["Go应用"],"content":"阻塞获取权值的方法 - Acquire 先直接看代码吧： func (s *Weighted) Acquire(ctx context.Context, n int64) error { s.mu.Lock() // 加锁保护临界区 // 有资源可用并且没有等待获取权值的goroutine if s.size-s.cur \u003e= n \u0026\u0026 s.waiters.Len() == 0 { s.cur += n // 加权 s.mu.Unlock() // 释放锁 return nil } // 要获取的权值n大于最大的权值了 if n \u003e s.size { // 先释放锁，确保其他goroutine调用Acquire的地方不被阻塞 s.mu.Unlock() // 阻塞等待context的返回 \u003c-ctx.Done() return ctx.Err() } // 走到这里就说明现在没有资源可用了 // 创建一个channel用来做通知唤醒 ready := make(chan struct{}) // 创建waiter对象 w := waiter{n: n, ready: ready} // waiter按顺序入队 elem := s.waiters.PushBack(w) // 释放锁，等待唤醒，别阻塞其他goroutine s.mu.Unlock() // 阻塞等待唤醒 select { // context关闭 case \u003c-ctx.Done(): err := ctx.Err() // 先获取context的错误信息 s.mu.Lock() select { case \u003c-ready: // 在context被关闭后被唤醒了，那么试图修复队列，假装我们没有取消 err = nil default: // 判断是否是第一个元素 isFront := s.waiters.Front() == elem // 移除第一个元素 s.waiters.Remove(elem) // 如果是第一个元素且有资源可用通知其他waiter if isFront \u0026\u0026 s.size \u003e s.cur { s.notifyWaiters() } } s.mu.Unlock() return err // 被唤醒了 case \u003c-ready: return nil } } 注释已经加到代码中了，总结一下这个方法主要有三个流程： 流程一：有资源可用时并且没有等待权值的goroutine，走正常加权流程； 流程二：想要获取的权值n大于初始化时设置最大的权值了，这个goroutine永远不会获取到信号量，所以阻塞等待context的关闭； 流程三：前两步都没问题的话，就说明现在系统没有资源可用了，这时就需要阻塞等待唤醒，在阻塞等待唤醒这里有特殊逻辑； 特殊逻辑一：如果在context被关闭后被唤醒了，那么就先忽略掉这个cancel，试图修复队列。 特殊逻辑二：context关闭后，则根据是否有可用资源决定通知后面等待唤醒的调用者，这样做的目的其实是为了避免当不同的context控制不同的goroutine时，未关闭的goroutine不会被阻塞住，依然执行，来看这样一个例子（因为goroutine的抢占式调度，所以这个例子也会具有偶然性）： func main() { s := semaphore.NewWeighted(3) ctx,cancel := context.WithTimeout(context.Background(), time.Second * 2) defer cancel() for i :=0; i \u003c 3; i++{ if i != 0{ go func(num int) { if err := s.Acquire(ctx,3); err != nil{ fmt.Printf(\"goroutine： %d, err is %s\\n\", num, err.Error()) return } time.Sleep(2 * time.Second) fmt.Printf(\"goroutine： %d run over\\n\",num) s.Release(3) }(i) }else { go func(num int) { ct,cancel := context.WithTimeout(context.Background(), time.Second * 3) defer cancel() if err := s.Acquire(ct,3); err != nil{ fmt.Printf(\"goroutine： %d, err is %s\\n\", num, err.Error()) return } time.Sleep(3 * time.Second) fmt.Printf(\"goroutine： %d run over\\n\",num) s.Release(3) }(i) } } time.Sleep(10 * time.Second) } 上面的例子中goroutine:0 使用ct对象来做控制，超时时间为3s，goroutine:1和goroutine:2对象使用ctx对象来做控制，超时时间为2s，这三个goroutine占用的资源都等于最大资源数，也就是说只能有一个goruotine运行成功，另外两个goroutine都会被阻塞，因为goroutine是抢占式调度，所以我们不能确定哪个gouroutine会第一个被执行，这里我们假设第一个获取到信号量的是gouroutine:2，阻塞等待的调用者列表顺序是：goroutine:1 -\u003e goroutine:0，因为在goroutine:2中有一个2s的延时，所以会触发ctx的超时，ctx会下发Done信号，因为goroutine:2和goroutine:1都是被ctx控制的，所以就会把goroutine:1从等待者队列中取消，但是因为goroutine:1属于队列的第一个队员，并且因为goroutine:2已经释放资源，那么就会唤醒goroutine:0继续执行，画个图表示一下： 使用这种方式可以避免goroutine永久失眠。 ","date":"2021-08-29","objectID":"https://asong2020.github.io/go%E5%AE%98%E6%96%B9%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%BA%93/:4:2","tags":["信号量"],"title":"源码赏析Go官方扩展信号量库Semaphore","uri":"https://asong2020.github.io/go%E5%AE%98%E6%96%B9%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%BA%93/"},{"categories":["Go应用"],"content":"不阻塞获取权值的方法 - TryAcquire func (s *Weighted) TryAcquire(n int64) bool { s.mu.Lock() // 加锁 // 有资源可用并且没有等待获取资源的goroutine success := s.size-s.cur \u003e= n \u0026\u0026 s.waiters.Len() == 0 if success { s.cur += n } s.mu.Unlock() return success } 这个方法就简单很多了，不阻塞地获取权重为n的信号量，成功时返回true，失败时返回false并保持信号量不变。 ","date":"2021-08-29","objectID":"https://asong2020.github.io/go%E5%AE%98%E6%96%B9%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%BA%93/:4:3","tags":["信号量"],"title":"源码赏析Go官方扩展信号量库Semaphore","uri":"https://asong2020.github.io/go%E5%AE%98%E6%96%B9%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%BA%93/"},{"categories":["Go应用"],"content":"释放权重 func (s *Weighted) Release(n int64) { s.mu.Lock() // 释放资源 s.cur -= n // 释放资源大于持有的资源，则会发生panic if s.cur \u003c 0 { s.mu.Unlock() panic(\"semaphore: released more than held\") } // 通知其他等待的调用者 s.notifyWaiters() s.mu.Unlock() } 这里就是很常规的操作，主要就是资源释放，同时进行安全性判断，如果释放资源大于持有的资源，则会发生panic。 ","date":"2021-08-29","objectID":"https://asong2020.github.io/go%E5%AE%98%E6%96%B9%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%BA%93/:4:4","tags":["信号量"],"title":"源码赏析Go官方扩展信号量库Semaphore","uri":"https://asong2020.github.io/go%E5%AE%98%E6%96%B9%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%BA%93/"},{"categories":["Go应用"],"content":"唤醒waiter 在Acquire和Release方法中都调用了notifyWaiters，我们来分析一下这个方法： func (s *Weighted) notifyWaiters() { for { // 获取等待调用者队列中的队员 next := s.waiters.Front() // 没有要通知的调用者了 if next == nil { break // No more waiters blocked. } // 断言出waiter信息 w := next.Value.(waiter) if s.size-s.cur \u003c w.n { // 没有足够资源为下一个调用者使用时，继续阻塞该调用者，遵循先进先出的原则， // 避免需要资源数比较大的waiter被饿死 // // 考虑一个场景，使用信号量作为读写锁，现有N个令牌，N个reader和一个writer // 每个reader都可以通过Acquire（1）获取读锁，writer写入可以通过Acquire（N）获得写锁定 // 但不包括所有的reader，如果我们允许reader在队列中前进，writer将会饿死-总是有一个令牌可供每个reader break } // 获取资源 s.cur += w.n // 从waiter列表中移除 s.waiters.Remove(next) // 使用channel的close机制唤醒waiter close(w.ready) } } 这里只需要注意一个点：唤醒waiter采用先进先出的原则，避免需要资源数比较大的waiter被饿死。 ","date":"2021-08-29","objectID":"https://asong2020.github.io/go%E5%AE%98%E6%96%B9%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%BA%93/:4:5","tags":["信号量"],"title":"源码赏析Go官方扩展信号量库Semaphore","uri":"https://asong2020.github.io/go%E5%AE%98%E6%96%B9%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%BA%93/"},{"categories":["Go应用"],"content":"何时使用Semaphore 到这里我们就把Semaphore的源代码看了一篇，代码行数不多，封装的也很巧妙，那么我们该什么时候选择使用它呢？ 目前能想到一个场景就是Semaphore配合上errgroup实现一个\"工作池\"，使用Semaphore限制goroutine的数量，配合上errgroup做并发控制，示例如下： const ( limit = 2 ) func main() { serviceName := []string{ \"cart\", \"order\", \"account\", \"item\", \"menu\", } eg,ctx := errgroup.WithContext(context.Background()) s := semaphore.NewWeighted(limit) for index := range serviceName{ name := serviceName[index] if err := s.Acquire(ctx,1); err != nil{ fmt.Printf(\"Acquire failed and err is %s\\n\", err.Error()) break } eg.Go(func() error { defer s.Release(1) return callService(name) }) } if err := eg.Wait(); err != nil{ fmt.Printf(\"err is %s\\n\", err.Error()) return } fmt.Printf(\"run success\\n\") } func callService(name string) error { fmt.Println(\"call \",name) time.Sleep(1 * time.Second) return nil } 结果如下： call order call cart call account call item call menu run success ","date":"2021-08-29","objectID":"https://asong2020.github.io/go%E5%AE%98%E6%96%B9%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%BA%93/:4:6","tags":["信号量"],"title":"源码赏析Go官方扩展信号量库Semaphore","uri":"https://asong2020.github.io/go%E5%AE%98%E6%96%B9%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%BA%93/"},{"categories":["Go应用"],"content":"总结 本文我们主要赏析了Go官方扩展库Semaphore的实现，他的设计思路简单，仅仅用几十行就完成了完美的封装，值得我们借鉴学习。不过在实际业务场景中，我们使用信号量的场景并不多，大多数场景我们都可以使用channel来替代，但是有些场景使用Semaphore来实现会更好，比如上篇文章【[警惕] 请勿滥用goroutine】我们使用channel+sync来控制goroutine数量，这种实现方式并不好，因为实际已经起来了多个goroutine，只不过控制了工作的goroutine数量，如果改用semaphore实现才是真正的控制了goroutine数量。 文中代码已上传github：https://github.com/asong2020/Golang_Dream/blob/master/code_demo/semaphore_demo/semaphore.go，欢迎star。 素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！我是asong，我们下期见。 创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：关注公众号获取。更多学习资料请到公众号领取。 推荐往期文章： 学习channel设计：从入门到放弃 详解内存对齐 Go语言中new和make你使用哪个来分配内存？ 源码剖析panic与recover，看不懂你打我好了！ 面试官：小松子来聊一聊内存逃逸 面试官：你能聊聊string和[]byte的转换吗？ 面试官：两个nil比较结果是什么？ 并发编程包之 errgroup ","date":"2021-08-29","objectID":"https://asong2020.github.io/go%E5%AE%98%E6%96%B9%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%BA%93/:5:0","tags":["信号量"],"title":"源码赏析Go官方扩展信号量库Semaphore","uri":"https://asong2020.github.io/go%E5%AE%98%E6%96%B9%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%BA%93/"},{"categories":["Go应用"],"content":"前言 哈喽，大家好，我是asong。Go语言中，goroutine的创建成本很低，调度效率很高，人称可以开几百几千万个goroutine，但是真正开几百几千万个goroutine就不会有任何影响吗？本文我们就一起来看一看goroutine是否有数量限制并介绍几种正确使用goroutine的姿势～。 ","date":"2021-08-22","objectID":"https://asong2020.github.io/%E6%8E%A7%E5%88%B6goroutine%E9%80%80%E5%87%BA%E5%92%8C%E6%95%B0%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/:1:0","tags":["goroutine"],"title":"控制goroutine退出和数量的几种方式","uri":"https://asong2020.github.io/%E6%8E%A7%E5%88%B6goroutine%E9%80%80%E5%87%BA%E5%92%8C%E6%95%B0%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"categories":["Go应用"],"content":"现状 在Go语言中，goroutine的创建成本很低，调度效率高，Go语言在设计时就是按以数万个goroutine为规范进行设计的，数十万个并不意外，但是goroutine在内存占用方面确实具有有限的成本，你不能创造无限数量的它们，比如这个例子： ch := generate() go func() { for range ch { } }() 这段代码通过generate()方法获得一个channel，然后启动一个goroutine一直去处理这个channel的数据，这个goroutine什么时候会退出？答案是不确定，ch是由函数generate()来决定的，所以有可能这个goroutine永远都不会退出，这就有可能会引发内存泄漏。 goroutine就是G-P-M调度模型中的G，我们可以把goroutine看成是一种协程，创建goroutine也是有开销的，但是开销很小，初始只需要2-4k的栈空间，当goroutine数量越来越大时，同时存在的goroutine也越来越多时，程序就隐藏内存泄漏的问题。看一个例子： func main() { for i := 0; i \u003c math.MaxInt64; i++ { go func(i int) { time.Sleep(5 * time.Second) }(i) } } 大家可以在自己的电脑上运行一下这个程序，观察一下CPU和内存占用情况，我说下我运行后的现象： CPU使用率疯狂上涨 内存占用率也不断上涨 运行一段时间后主进程崩溃了。。。 因此每次在编写GO程序时，都应该仔细考虑一个问题： 您将要启动的goroutine将如何以及在什么条件下结束？ 接下来我们就来介绍几种方式可以控制goroutine和goroutine的数量。 ","date":"2021-08-22","objectID":"https://asong2020.github.io/%E6%8E%A7%E5%88%B6goroutine%E9%80%80%E5%87%BA%E5%92%8C%E6%95%B0%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/:2:0","tags":["goroutine"],"title":"控制goroutine退出和数量的几种方式","uri":"https://asong2020.github.io/%E6%8E%A7%E5%88%B6goroutine%E9%80%80%E5%87%BA%E5%92%8C%E6%95%B0%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"categories":["Go应用"],"content":"控制goroutine的方法 ","date":"2021-08-22","objectID":"https://asong2020.github.io/%E6%8E%A7%E5%88%B6goroutine%E9%80%80%E5%87%BA%E5%92%8C%E6%95%B0%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/:3:0","tags":["goroutine"],"title":"控制goroutine退出和数量的几种方式","uri":"https://asong2020.github.io/%E6%8E%A7%E5%88%B6goroutine%E9%80%80%E5%87%BA%E5%92%8C%E6%95%B0%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"categories":["Go应用"],"content":"Context包 Go 语言中的每一个请求的都是通过一个单独的 goroutine 进行处理的，HTTP/RPC 请求的处理器往往都会启动新的 Goroutine 访问数据库和 RPC 服务，我们可能会创建多个 goroutine 来处理一次请求，而 Context 的主要作用就是在不同的 goroutine 之间同步请求特定的数据、取消信号以及处理请求的截止日期。 Context包主要衍生了四个函数： func WithCancel(parent Context) (ctx Context, cancel CancelFunc) func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) func WithValue(parent Context, key, val interface{}) Context 使用这四个函数我们对goroutine进行控制，具体展开就不再本文说了，我们以WithCancel方法写一个例子： func main() { ctx,cancel := context.WithCancel(context.Background()) go Speak(ctx) time.Sleep(10*time.Second) cancel() time.Sleep(2 * time.Second) fmt.Println(\"bye bye!\") } func Speak(ctx context.Context) { for range time.Tick(time.Second){ select { case \u003c- ctx.Done(): fmt.Println(\"asong哥，我收到信号了，要走了，拜拜！\") return default: fmt.Println(\"asong哥，你好帅呀～balabalabalabala\") } } } 运行结果： asong哥，你好帅呀～balabalabalabala # ....... 省略部分 asong哥，我收到信号了，要走了，拜拜！ bye bye! 这里我们使用withCancel创建了一个基于Background的ctx，然后启动了一个goroutine每隔1s夸我一句，10s后在主goroutine中发送取消新信号，那么启动的goroutine在检测到信号后就会取消退出。 ","date":"2021-08-22","objectID":"https://asong2020.github.io/%E6%8E%A7%E5%88%B6goroutine%E9%80%80%E5%87%BA%E5%92%8C%E6%95%B0%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/:3:1","tags":["goroutine"],"title":"控制goroutine退出和数量的几种方式","uri":"https://asong2020.github.io/%E6%8E%A7%E5%88%B6goroutine%E9%80%80%E5%87%BA%E5%92%8C%E6%95%B0%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"categories":["Go应用"],"content":"channel 我们知道channel是用于goroutine的数据通信，在Go中通过goroutine+channel的方式，可以简单、高效地解决并发问题。上面我们介绍了使用context来达到对goroutine的控制，实际上context的内部实现也是使用的channel，所以有时候为了实现方便，我们可以直接通过channel+select或者channel+close的方式来控制goroutine的退出，我们分别来一写一个例子： channel+select func fibonacci(ch chan int, done chan struct{}) { x, y := 0, 1 for { select { case ch \u003c- x: x, y = y, x+y case \u003c-done: fmt.Println(\"over\") return } } } func main() { ch := make(chan int) done := make(chan struct{}) go func() { for i := 0; i \u003c 10; i++ { fmt.Println(\u003c-ch) } done \u003c- struct{}{} }() fibonacci(ch, done) } 上面的例子是计算斐波那契数列的结果，我们使用两个channel，一个channel用来传输数据，另外一个channel用来做结束信号，这里我们使用的是select的阻塞式的收发操作，直到有一个channel发生状态改变，我们也可以在select中使用default语句，那么select语句在执行时会遇到这两种情况： 当存在可以收发的Channel时，直接处理该Channel 对应的 case； 当不存在可以收发的Channel 时，执行 default 中的语句； 建议大家使用带default的方式，因为在一个nil channel上的操作会一直被阻塞，如果没有default case,只有nil channel的select会一直被阻塞。 channel+close channel可以单个出队，也可以循环出队，因为我们可以使用for-range循环处理channel，range ch会一直迭代到channel被关闭，根据这个特性，我们也可做到对goroutine的控制： func main() { ch := make(chan int, 10) go func() { for i:=0; i\u003c10;i++{ ch \u003c- i } close(ch) }() go func() { for val := range ch{ fmt.Println(val) } fmt.Println(\"receive data over\") }() time.Sleep(5* time.Second) fmt.Println(\"program over\") } 如果对channel不熟悉的朋友可以看一下我之前的文章：学习channel设计：从入门到放弃 ","date":"2021-08-22","objectID":"https://asong2020.github.io/%E6%8E%A7%E5%88%B6goroutine%E9%80%80%E5%87%BA%E5%92%8C%E6%95%B0%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/:3:2","tags":["goroutine"],"title":"控制goroutine退出和数量的几种方式","uri":"https://asong2020.github.io/%E6%8E%A7%E5%88%B6goroutine%E9%80%80%E5%87%BA%E5%92%8C%E6%95%B0%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"categories":["Go应用"],"content":"控制goroutine的数量 我们可以通过以下方式达到控制goroutine数量的目的，不过本身Go的goroutine就已经很轻量了，所以控制goroutine的数量还是要根据具体场景分析，并不是所有场景都需要控制goroutine的数量的，一般在并发场景我们会考虑控制goroutine的数量，接下来我们来看一看如下几种方式达到控制goroutine数量的目的。 ","date":"2021-08-22","objectID":"https://asong2020.github.io/%E6%8E%A7%E5%88%B6goroutine%E9%80%80%E5%87%BA%E5%92%8C%E6%95%B0%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/:4:0","tags":["goroutine"],"title":"控制goroutine退出和数量的几种方式","uri":"https://asong2020.github.io/%E6%8E%A7%E5%88%B6goroutine%E9%80%80%E5%87%BA%E5%92%8C%E6%95%B0%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"categories":["Go应用"],"content":"协程池 写 go 并发程序的时候如果程序会启动大量的 goroutine ，势必会消耗大量的系统资源（内存，CPU），所以可以考虑使用goroutine池达到复用goroutine，节省资源，提升性能。也有一些开源的协程池库，例如：ants、go-playground/pool、jeffail/tunny等，这里我们看ants的一个官方例子： var sum int32 func myFunc(i interface{}) { n := i.(int32) atomic.AddInt32(\u0026sum, n) fmt.Printf(\"run with %d\\n\", n) } func demoFunc() { time.Sleep(10 * time.Millisecond) fmt.Println(\"Hello World!\") } func main() { defer ants.Release() runTimes := 1000 // Use the common pool. var wg sync.WaitGroup syncCalculateSum := func() { demoFunc() wg.Done() } for i := 0; i \u003c runTimes; i++ { wg.Add(1) _ = ants.Submit(syncCalculateSum) } wg.Wait() fmt.Printf(\"running goroutines: %d\\n\", ants.Running()) fmt.Printf(\"finish all tasks.\\n\") // Use the pool with a function, // set 10 to the capacity of goroutine pool and 1 second for expired duration. p, _ := ants.NewPoolWithFunc(10, func(i interface{}) { myFunc(i) wg.Done() }) defer p.Release() // Submit tasks one by one. for i := 0; i \u003c runTimes; i++ { wg.Add(1) _ = p.Invoke(int32(i)) } wg.Wait() fmt.Printf(\"running goroutines: %d\\n\", p.Running()) fmt.Printf(\"finish all tasks, result is %d\\n\", sum) } 这个例子其实就是计算大量整数和的程序，这里通过ants.NewPoolWithFunc()创建了一个 goroutine 池。第一个参数是池容量，即池中最多有 10 个 goroutine。第二个参数为每次执行任务的函数。当我们调用p.Invoke(data)的时候，ants池会在其管理的 goroutine 中找出一个空闲的，让它执行函数taskFunc，并将data作为参数。 具体这个库的设计就不详细展开了，后面会专门写一篇文章来介绍如何设计一个协程池。 ","date":"2021-08-22","objectID":"https://asong2020.github.io/%E6%8E%A7%E5%88%B6goroutine%E9%80%80%E5%87%BA%E5%92%8C%E6%95%B0%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/:4:1","tags":["goroutine"],"title":"控制goroutine退出和数量的几种方式","uri":"https://asong2020.github.io/%E6%8E%A7%E5%88%B6goroutine%E9%80%80%E5%87%BA%E5%92%8C%E6%95%B0%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"categories":["Go应用"],"content":"信号量Semaphore Go语言的官方扩展包为我们提供了一个基于权重的信号量Semaphore，我可以根据信号量来控制一定数量的 goroutine 并发工作，官方也给提供了一个例子：workerPool，代码有点长就不在这里贴了，我们来自己写一个稍微简单点的例子： const ( Limit = 3 // 同时运行的goroutine上限 Weight = 1 // 信号量的权重 ) func main() { names := []string{ \"asong1\", \"asong2\", \"asong3\", \"asong4\", \"asong5\", \"asong6\", \"asong7\", } sem := semaphore.NewWeighted(Limit) var w sync.WaitGroup for _, name := range names { w.Add(1) go func(name string) { sem.Acquire(context.Background(), Weight) fmt.Println(name) time.Sleep(2 * time.Second) // 延时能更好的体现出来控制 sem.Release(Weight) w.Done() }(name) } w.Wait() fmt.Println(\"over--------\") } 上面的例子我们使用 NewWeighted() 函数创建一个并发访问的最大资源数，也就是同时运行的goroutine上限为3，使用Acquire函数来获取指定个数的资源，如果当前没有空闲资源可用，则当前goroutine将陷入休眠状态，最后使用release函数释放已使用资源数量（计数器）进行更新减少，并通知其它 waiters。 ","date":"2021-08-22","objectID":"https://asong2020.github.io/%E6%8E%A7%E5%88%B6goroutine%E9%80%80%E5%87%BA%E5%92%8C%E6%95%B0%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/:4:2","tags":["goroutine"],"title":"控制goroutine退出和数量的几种方式","uri":"https://asong2020.github.io/%E6%8E%A7%E5%88%B6goroutine%E9%80%80%E5%87%BA%E5%92%8C%E6%95%B0%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"categories":["Go应用"],"content":"channel+waitgroup实现 这个方法我是在煎鱼大佬的一篇文章学到的：来，控制一下Goroutine的并发数量 主要实现原理是利用waitGroup做并发控制，利用channel可以在goroutine之间进行数据通信，通过限制channel的队列长度来控制同时运行的goroutine数量，例子如下： func main() { count := 9 // 要运行的goroutine数量 limit := 3 // 同时运行的goroutine为3个 ch := make(chan bool, limit) wg := sync.WaitGroup{} wg.Add(count) for i:=0; i \u003c count; i++{ go func(num int) { defer wg.Done() ch \u003c- true // 发送信号 fmt.Printf(\"%d 我在干活 at time %d\\n\",num,time.Now().Unix()) time.Sleep(2 * time.Second) \u003c- ch // 接收数据代表退出了 }(i) } wg.Wait() } 这种实现方式真的妙，与信号量的实现方式基本相似，某些场景大家也可以考虑使用这种方式来达到控制goroutine的目的，不过最好封装一下，要不有点丑陋，感兴趣的可以看一下煎鱼大佬是怎么封装的：https://github.com/eddycjy/gsema/blob/master/sema.go ","date":"2021-08-22","objectID":"https://asong2020.github.io/%E6%8E%A7%E5%88%B6goroutine%E9%80%80%E5%87%BA%E5%92%8C%E6%95%B0%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/:4:3","tags":["goroutine"],"title":"控制goroutine退出和数量的几种方式","uri":"https://asong2020.github.io/%E6%8E%A7%E5%88%B6goroutine%E9%80%80%E5%87%BA%E5%92%8C%E6%95%B0%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"categories":["Go应用"],"content":"总结 本文主要目的是介绍控制goroutine的几种方式、控制goroutine数量的几种方式，goroutine的创建成本低、效率高带来了很大优势，同时也会有一些弊端，这就需要我们在实际开发中根据具体场景选择正确的方式使用goroutine，本文介绍的技术方案也可能是片面的，如果你有更好的方式可以在评论区中分享出来，我们大家一起学习学习～。 文中代码已经上传github，欢迎star：https://github.com/asong2020/Golang_Dream/tree/master/code_demo/goroutine_demo 素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！我是asong，我们下期见。 创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：关注公众号获取。更多学习资料请到公众号领取。 推荐往期文章： 学习channel设计：从入门到放弃 详解内存对齐 Go语言中new和make你使用哪个来分配内存？ 源码剖析panic与recover，看不懂你打我好了！ 面试官：小松子来聊一聊内存逃逸 面试官：你能聊聊string和[]byte的转换吗？ 面试官：两个nil比较结果是什么？ 并发编程包之 errgroup ","date":"2021-08-22","objectID":"https://asong2020.github.io/%E6%8E%A7%E5%88%B6goroutine%E9%80%80%E5%87%BA%E5%92%8C%E6%95%B0%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/:5:0","tags":["goroutine"],"title":"控制goroutine退出和数量的几种方式","uri":"https://asong2020.github.io/%E6%8E%A7%E5%88%B6goroutine%E9%80%80%E5%87%BA%E5%92%8C%E6%95%B0%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"categories":["Go面试"],"content":"前言 哈喽，大家好，我是asong。好久不见，上周停更了一周，因为工作有点忙，好在这周末闲了下来，就赶紧来肝文喽。今天我们来聊一聊一道常见的面试八股文——内存对齐，我们平常在业务开发中根本不care内存对齐，但是在面试中，这就是一个高频考点，今天我们就一起来看一看到底什么是内存对齐。 ","date":"2021-08-14","objectID":"https://asong2020.github.io/%E8%AF%A6%E8%A7%A3%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/:1:0","tags":["内存布局"],"title":"Go语言详解内存对齐","uri":"https://asong2020.github.io/%E8%AF%A6%E8%A7%A3%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"},{"categories":["Go面试"],"content":"前情概要 在了解内存对齐之前，先来明确几个关于操作系统的概念，更加方面我们对内存对齐的理解。 内存管理：我们都知道内存是计算中重要的组成之一，内存是与CPU进行沟通的桥梁，用于暂存CPU中的运算数据、以及与硬盘等外部存储器交换的数据。早期，程序是直接运行在物理内存上的，直接操作物理内存，但是会存在一些问题，比如使用效率低、地址空间不隔离等问题，所以就出现了虚拟内存，虚拟内存就是在程序和物理内存之间引入了一个中间层，这个中间层就是虚拟内存，这样就达到了对进程地址和物理地址的隔离。在linux系统中，将虚拟内存划分为用户空间和内核空间，用户进程只能访问用户空间的虚拟地址，只有通过系统调用、外设中断或异常才能访问内核空间，我们主要来看一下用户空间，用户空间被分为5个不同内存区域： 代码段：存放可执行文件的操作指令，只读 数据段：用来存放可执行文件中已初始化全局变量，存放静态变量和全局变量 BSS段：用来存未初始化的全局变量 栈区：用来存临时创建的局部变量 堆区：用来存动态分配的内存段 内存的知识先介绍个大概，对于本文的理解应该够了，我们接着介绍操作系统几个其他概念。 CPU：中央处理单元（Cntral Pocessing Unit）的缩写，也叫处理器；CPU是计算机的运算核心和控制核心，我们人类靠着大脑思考，电脑就是靠着CPU来运算、控制，起到协调和控制作用，从功能来看，CPU 的内部由寄存器、控制器、运算器和时钟四部分组成，各部分之间通过电信号连通。 CPU和内存的工作关系：当我们执行一个程序时，首先由输入设备向CPU发出操作指令，CPU接收到操作指令后，硬盘中对应的程序就会被直接加载到内存中，此后，CPU 再对内存进行寻址操作，将加载到内存中的指令翻译出来，而后发送操作信号给操作控制器，实现程序的运行或数据的处理。存在于内存中的目的就是为了CPU能够过总线进行寻址，取指令、译码、执行取数据，内存与寄存器交互，然后CPU运算，再输出数据至内存。 os：os全称为Operating System，也就是操作操作系统，是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务组织用户交互的相互关联的系统软件，同时也是计算机系统的内核与基石。 编译器：编译器就是将“一种语言（通常为高级语言）”翻译为“另一种语言（通常为低级语言）”的程序。一个现代编译器的主要工作流程：源代码 (source code) → 预处理器(preprocessor) → 编译器 (compiler) → 目标代码 (object code) → 链接器 (Linker) → 可执行程序(executables)。 写在最后的一个知识点： 计算机中，最小的存储单元为字节，理论上任意地址都可以通过总线进行访问，每次寻址能传输的数据大小就跟CPU位数有关。常见的CPU位数有8位，16位，32位，64位。位数越高，单次操作执行的数据量越大，性能也就越强。os的位数一般与CPU的位数相匹配，32位CPU可以寻址4GB内存空间，也可以运行32位的os，同样道理，64位的CPU可以运行32位的os，也可以运行64位的os。 ","date":"2021-08-14","objectID":"https://asong2020.github.io/%E8%AF%A6%E8%A7%A3%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/:2:0","tags":["内存布局"],"title":"Go语言详解内存对齐","uri":"https://asong2020.github.io/%E8%AF%A6%E8%A7%A3%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"},{"categories":["Go面试"],"content":"何为内存对齐 以下内容来源于网络总结： 现代计算机中内存空间都是按照字节(byte)进行划分的，所以从理论上讲对于任何类型的变量访问都可以从任意地址开始，但是在实际情况中，在访问特定类型变量的时候经常在特定的内存地址访问，所以这就需要把各种类型数据按照一定的规则在空间上排列，而不是按照顺序一个接一个的排放，这种就称为内存对齐，内存对齐是指首地址对齐，而不是说每个变量大小对齐。 ","date":"2021-08-14","objectID":"https://asong2020.github.io/%E8%AF%A6%E8%A7%A3%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/:3:0","tags":["内存布局"],"title":"Go语言详解内存对齐","uri":"https://asong2020.github.io/%E8%AF%A6%E8%A7%A3%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"},{"categories":["Go面试"],"content":"为何要有内存对齐 主要原因可以归结为两点： 有些CPU可以访问任意地址上的任意数据，而有些CPU只能在特定地址访问数据，因此不同硬件平台具有差异性，这样的代码就不具有移植性，如果在编译时，将分配的内存进行对齐，这就具有平台可以移植性了 CPU每次寻址都是要消费时间的，并且CPU 访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问，所以数据结构应该尽可能地在自然边界上对齐，如果访问未对齐的内存，处理器需要做两次内存访问，而对齐的内存访问仅需要一次访问，内存对齐后可以提升性能。举个例子： 假设当前CPU是32位的，并且没有内存对齐机制，数据可以任意存放，现在有一个int32变量占4byte，存放地址在0x00000002 - 0x00000005(纯假设地址，莫当真)，这种情况下，每次取4字节的CPU第一次取到[0x00000000 - 0x00000003]，只得到变量1/2的数据，所以还需要取第二次，为了得到一个int32类型的变量，需要访问两次内存并做拼接处理，影响性能。如果有内存对齐了，int32类型数据就会按照对齐规则在内存中，上面这个例子就会存在地址0x00000000处开始，那么处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，使用空间换时间，提高了效率。 没有内存对齐机制： 内存对齐后： ","date":"2021-08-14","objectID":"https://asong2020.github.io/%E8%AF%A6%E8%A7%A3%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/:4:0","tags":["内存布局"],"title":"Go语言详解内存对齐","uri":"https://asong2020.github.io/%E8%AF%A6%E8%A7%A3%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"},{"categories":["Go面试"],"content":"对齐系数 每个特定平台上的编译器都有自己的默认\"对齐系数\"，常用平台默认对齐系数如下： 32位系统对齐系数是4 64位系统对齐系数是8 这只是默认对齐系数，实际上对齐系数我们是可以修改的，之前写C语言的朋友知道，可以通过预编译指令#pragma pack(n)来修改对齐系数，因为C语言是预处理器的，但是在Go语言中没有预处理器，只能通过tags和命名约定来让Go的包可以管理不同平台的代码，但是怎么修改对齐系数，感觉Go并没有开放这个参数，找了好久没有找到，等后面再仔细看看，找到了再来更新！ 既然对齐系数无法更改，但是我们可以查看对齐系数，使用Go语言中的unsafe.Alignof可以返回相应类型的对齐系数，使用我的mac（64位）测试后发现，对齐系数都符合2^n这个规律，最大也不会超过8。 func main() { fmt.Printf(\"string alignof is %d\\n\", unsafe.Alignof(string(\"a\"))) fmt.Printf(\"complex128 alignof is %d\\n\", unsafe.Alignof(complex128(0))) fmt.Printf(\"int alignof is %d\\n\", unsafe.Alignof(int(0))) } 运行结果 string alignof is 8 complex128 alignof is 8 int alignof is 8 注意：不同硬件平台占用的大小和对齐值都可能是不一样的。 ","date":"2021-08-14","objectID":"https://asong2020.github.io/%E8%AF%A6%E8%A7%A3%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/:5:0","tags":["内存布局"],"title":"Go语言详解内存对齐","uri":"https://asong2020.github.io/%E8%AF%A6%E8%A7%A3%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"},{"categories":["Go面试"],"content":"结构体的内存对齐规则 一提到内存对齐，大家都喜欢拿结构体的内存对齐来举例子，这里要提醒大家一下，不要混淆了一个概念，其他类型也都是要内存对齐的，只不过拿结构体来举例子能更好的理解内存对齐，并且结构体中的成员变量对齐有自己的规则，我们需要搞清这个对齐规则。 C语言的对齐规则与Go语言一样，所以C语言的对齐规则对Go同样适用： 对于结构体的各个成员，第一个成员位于偏移为0的位置，结构体第一个成员的偏移量(offset)为0，以后每个成员相对于结构体首地址的offset都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。 除了结构成员需要对齐，结构本身也需要对齐，结构的长度必须是编译器默认的对齐长度和成员中最长类型中最小的数据大小的倍数对齐。 ","date":"2021-08-14","objectID":"https://asong2020.github.io/%E8%AF%A6%E8%A7%A3%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/:6:0","tags":["内存布局"],"title":"Go语言详解内存对齐","uri":"https://asong2020.github.io/%E8%AF%A6%E8%A7%A3%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"},{"categories":["Go面试"],"content":"举个例子 根据上面的对齐规则，我们来分析一个例子，加深理解： // 64位平台，对齐参数是8 type User struct { A int32 // 4 B []int32 // 24 C string // 16 D bool // 1 } func main() { var u User fmt.Println(\"u1 size is \",unsafe.Sizeof(u)) } // 运行结果 u size is 56 这里我的mac是64位的，对齐参数是8，int32、[]int32、string、bool对齐值分别是4、8、8、1，占用内存大小分别是4、24、16、1，我们先根据第一条对齐规则分析User： 第一个字段类型是int32，对齐值是4，大小为4，所以放在内存布局中的第一位. 第二个字段类型是[]int32，对齐值是8，大小为24，按照第一条规则，偏移量应该是成员大小24与对齐值8中较小那个的整数倍，那么偏移量就是8，所以4-7位会由编译进行填充，一般为0值，也称为空洞，第9到32位为第二个字段B. 第三个字段类型是string，对齐值是8，大小为16，所以他的内存偏移值必须是8的倍数，因为user前两个字段就已经排到了第32位，所以offset为32正好是8的倍数，不要填充，从32位到48位是第三个字段C. 第四个字段类型是bool，对齐值是1，大小为1，所以他的内存偏移值必须是1的倍数，因为user前两个字段就已经排到了第48位，所以下一位的偏移量正好是48，正好是字段D的对齐值的倍数，不用填充，可以直接排列到第四个字段，也就是从48到第49位是第三个字段D. 根据第一条规则分析后，现在结构所占大小为49字节，我们再来根据第二条规则分析： 根据第二条规则，默认对齐值是8，字段中最大类型程度是24，所以求出结构体的对齐值是8，我们目前的内存长度是49，不是8的倍数，所以需要补齐，所以最终的结果就是56，补了7位。 ","date":"2021-08-14","objectID":"https://asong2020.github.io/%E8%AF%A6%E8%A7%A3%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/:6:1","tags":["内存布局"],"title":"Go语言详解内存对齐","uri":"https://asong2020.github.io/%E8%AF%A6%E8%A7%A3%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"},{"categories":["Go面试"],"content":"成员变量顺序对内存对齐带来的影响 根据上面的规则我们可以看出，成员变量的顺序也会影响内存对齐的结果，我们先来看一个例子： type test1 struct { a bool // 1 b int32 // 4 c string // 16 } type test2 struct { a int32 // 4 b string // 16 c bool // 1 } func main() { var t1 test1 var t2 test2 fmt.Println(\"t1 size is \",unsafe.Sizeof(t1)) fmt.Println(\"t2 size is \",unsafe.Sizeof(t2)) } 运行结果： t1 size is 24 t2 size is 32 test1的内存布局： test2的内存布局： ) 通过以上分析，我们可以看出，结构体中成员变量的顺序会影响结构体的内存布局，所以在日常开发中大家要注意这个问题，可以节省内存空间。 ","date":"2021-08-14","objectID":"https://asong2020.github.io/%E8%AF%A6%E8%A7%A3%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/:7:0","tags":["内存布局"],"title":"Go语言详解内存对齐","uri":"https://asong2020.github.io/%E8%AF%A6%E8%A7%A3%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"},{"categories":["Go面试"],"content":"空结构体字段对齐 Go语言中空结构体的大小为0，如果一个结构体中包含空结构体类型的字段时，通常是不需要进行内存对齐的，举个例子： type demo1 struct { a struct{} b int32 } func main() { fmt.Println(unsafe.Sizeof(demo1{})) } 运行结果： 4 从运行结果可知结构体demo1占用的内存与字段b占用内存大小相同，所以字段a是没有占用内存的，但是空结构体有一个特例，那就是当 struct{} 作为结构体最后一个字段时，需要内存对齐。因为如果有指针指向该字段, 返回的地址将在结构体之外，如果此指针一直存活不释放对应的内存，就会有内存泄露的问题（该内存不因结构体释放而释放），所以当struct{}作为结构体成员中最后一个字段时，要填充额外的内存保证安全。 type demo2 struct { a int32 b struct{} } func main() { fmt.Println(unsafe.Sizeof(demo2{})) } 运行结果： 8 ","date":"2021-08-14","objectID":"https://asong2020.github.io/%E8%AF%A6%E8%A7%A3%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/:8:0","tags":["内存布局"],"title":"Go语言详解内存对齐","uri":"https://asong2020.github.io/%E8%AF%A6%E8%A7%A3%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"},{"categories":["Go面试"],"content":"考虑内存对齐的设计 在之前的文章源码剖析sync.WaitGroup分析sync.waitgroup的源码时，使用state1来存储状态： // A WaitGroup must not be copied after first use. type WaitGroup struct { noCopy noCopy // 64-bit value: high 32 bits are counter, low 32 bits are waiter count. // 64-bit atomic operations require 64-bit alignment, but 32-bit // compilers do not ensure it. So we allocate 12 bytes and then use // the aligned 8 bytes in them as state, and the other 4 as storage // for the sema. state1 [3]uint32 } state1这里总共被分配了12个字节，这里被设计了三种状态： 其中对齐的8个字节作为状态，高32位为计数的数量，低32位为等待的goroutine数量 其中的4个字节作为信号量存储 提供了(wg *WaitGroup) state() (statep *uint64, semap *uint32)帮助我们从state1字段中取出他的状态和信号量，为什么要这样设计呢？ 因为64位原子操作需要64位对齐，但是32位编译器不能保证这一点，所以为了保证waitGroup在32位平台上使用的话，就必须保证在任何时候，64位操作不会报错。所以也就不能分成两个字段来写，考虑到字段顺序不同、平台不同，内存对齐也就不同。因此这里采用动态识别当前我们操作的64位数到底是不是在8字节对齐的位置上面，我们来分析一下state方法： // state returns pointers to the state and sema fields stored within wg.state1. func (wg *WaitGroup) state() (statep *uint64, semap *uint32) { if uintptr(unsafe.Pointer(\u0026wg.state1))%8 == 0 { return (*uint64)(unsafe.Pointer(\u0026wg.state1)), \u0026wg.state1[2] } else { return (*uint64)(unsafe.Pointer(\u0026wg.state1[1])), \u0026wg.state1[0] } } 当数组的首地址是处于一个8字节对齐的位置上时，那么就将这个数组的前8个字节作为64位值使用表示状态，后4个字节作为32位值表示信号量(semaphore)。同理如果首地址没有处于8字节对齐的位置上时，那么就将前4个字节作为semaphore，后8个字节作为64位数值。画个图表示一下： ) ","date":"2021-08-14","objectID":"https://asong2020.github.io/%E8%AF%A6%E8%A7%A3%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/:9:0","tags":["内存布局"],"title":"Go语言详解内存对齐","uri":"https://asong2020.github.io/%E8%AF%A6%E8%A7%A3%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"},{"categories":["Go面试"],"content":"总结 终于接近尾声了，内存对齐一直面试中的高频考点，通过内存对齐可以了解面试者对操作系统知识的了解程度，所以这块知识还是比较重要的，希望这篇文章能帮助大家答疑解惑，更好的忽悠面试官～。 文中代码已上传github：https://github.com/asong2020/Golang_Dream/tree/master/code_demo/memory 欢迎star; 文中有任何问题欢迎留言区探讨～； 素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！我是asong，我们下期见。 创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：关注公众号获取。更多学习资料请到公众号领取。 推荐往期文章： 学习channel设计：从入门到放弃 面试官：小松子来聊一聊内存逃逸 Go语言中new和make你使用哪个来分配内存？ 源码剖析panic与recover，看不懂你打我好了！ 空结构体引发的大型打脸现场 面试官：你能聊聊string和[]byte的转换吗？ 面试官：两个nil比较结果是什么？ 面试官：你能用Go写段代码判断当前系统的存储方式吗? ","date":"2021-08-14","objectID":"https://asong2020.github.io/%E8%AF%A6%E8%A7%A3%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/:10:0","tags":["内存布局"],"title":"Go语言详解内存对齐","uri":"https://asong2020.github.io/%E8%AF%A6%E8%A7%A3%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"},{"categories":["Go面试"],"content":"前言 哈喽，大家好，我是asong，今天给大家介绍一个并发编程包errgroup，其实这个包就是对sync.waitGroup的封装。我们在之前的文章—— 源码剖析sync.WaitGroup(文末思考题你能解释一下吗?)，从源码层面分析了sync.WaitGroup的实现，使用waitGroup可以实现一个goroutine等待一组goroutine干活结束，更好的实现了任务同步，但是waitGroup却无法返回错误，当一组Goroutine中的某个goroutine出错时，我们是无法感知到的，所以errGroup对waitGroup进行了一层封装，封装代码仅仅不到50行，下面我们就来看一看他是如何封装的？ ","date":"2021-08-06","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%8C%85%E4%B9%8Berrgroup/:1:0","tags":["并发编程"],"title":"Go语言并发编程包之errgroup","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%8C%85%E4%B9%8Berrgroup/"},{"categories":["Go面试"],"content":"errGroup如何使用 老规矩，我们先看一下errGroup是如何使用的，前面吹了这么久，先来验验货； 以下来自官方文档的例子： var ( Web = fakeSearch(\"web\") Image = fakeSearch(\"image\") Video = fakeSearch(\"video\") ) type Result string type Search func(ctx context.Context, query string) (Result, error) func fakeSearch(kind string) Search { return func(_ context.Context, query string) (Result, error) { return Result(fmt.Sprintf(\"%s result for %q\", kind, query)), nil } } func main() { Google := func(ctx context.Context, query string) ([]Result, error) { g, ctx := errgroup.WithContext(ctx) searches := []Search{Web, Image, Video} results := make([]Result, len(searches)) for i, search := range searches { i, search := i, search // https://golang.org/doc/faq#closures_and_goroutines g.Go(func() error { result, err := search(ctx, query) if err == nil { results[i] = result } return err }) } if err := g.Wait(); err != nil { return nil, err } return results, nil } results, err := Google(context.Background(), \"golang\") if err != nil { fmt.Fprintln(os.Stderr, err) return } for _, result := range results { fmt.Println(result) } } 上面这个例子来自官方文档，代码量有点多，但是核心主要是在Google这个闭包中，首先我们使用errgroup.WithContext创建一个errGroup对象和ctx对象，然后我们直接调用errGroup对象的Go方法就可以启动一个协程了，Go方法中已经封装了waitGroup的控制操作，不需要我们手动添加了，最后我们调用Wait方法，其实就是调用了waitGroup方法。这个包不仅减少了我们的代码量，而且还增加了错误处理，对于一些业务可以更好的进行并发处理。 ","date":"2021-08-06","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%8C%85%E4%B9%8Berrgroup/:2:0","tags":["并发编程"],"title":"Go语言并发编程包之errgroup","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%8C%85%E4%B9%8Berrgroup/"},{"categories":["Go面试"],"content":"赏析errGroup ","date":"2021-08-06","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%8C%85%E4%B9%8Berrgroup/:3:0","tags":["并发编程"],"title":"Go语言并发编程包之errgroup","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%8C%85%E4%B9%8Berrgroup/"},{"categories":["Go面试"],"content":"数据结构 我们先看一下Group的数据结构： type Group struct { cancel func() // 这个存的是context的cancel方法 wg sync.WaitGroup // 封装sync.WaitGroup errOnce sync.Once // 保证只接受一次错误 err error // 保存第一个返回的错误 } ","date":"2021-08-06","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%8C%85%E4%B9%8Berrgroup/:3:1","tags":["并发编程"],"title":"Go语言并发编程包之errgroup","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%8C%85%E4%B9%8Berrgroup/"},{"categories":["Go面试"],"content":"方法解析 func WithContext(ctx context.Context) (*Group, context.Context) func (g *Group) Go(f func() error) func (g *Group) Wait() error errGroup总共只有三个方法： WithContext方法 func WithContext(ctx context.Context) (*Group, context.Context) { ctx, cancel := context.WithCancel(ctx) return \u0026Group{cancel: cancel}, ctx } 这个方法只有两步： 使用context的WithCancel()方法创建一个可取消的Context 创建cancel()方法赋值给Group对象 Go方法 func (g *Group) Go(f func() error) { g.wg.Add(1) go func() { defer g.wg.Done() if err := f(); err != nil { g.errOnce.Do(func() { g.err = err if g.cancel != nil { g.cancel() } }) } }() } Go方法中运行步骤如下： 执行Add()方法增加一个计数器 开启一个协程，运行我们传入的函数f，使用waitGroup的Done()方法控制是否结束 如果有一个函数f运行出错了，我们把它保存起来，如果有cancel()方法，则执行cancel()取消其他goroutine 这里大家应该会好奇为什么使用errOnce，也就是sync.Once，这里的目的就是保证获取到第一个出错的信息，避免被后面的Goroutine的错误覆盖。 wait方法 func (g *Group) Wait() error { g.wg.Wait() if g.cancel != nil { g.cancel() } return g.err } 总结一下wait方法的执行逻辑： 调用waitGroup的Wait()等待一组Goroutine的运行结束 这里为了保证代码的健壮性，如果前面赋值了cancel，要执行cancel()方法 返回错误信息，如果有goroutine出现了错误才会有值 ","date":"2021-08-06","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%8C%85%E4%B9%8Berrgroup/:3:2","tags":["并发编程"],"title":"Go语言并发编程包之errgroup","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%8C%85%E4%B9%8Berrgroup/"},{"categories":["Go面试"],"content":"小结 到这里我们就分析完了errGroup包，总共就1个结构体和3个方法，理解起来还是比较简单的，针对上面的知识点我们做一个小结： 我们可以使用withContext方法创建一个可取消的Group，也可以直接使用一个零值的Group或new一个Group，不过直接使用零值的Group和new出来的Group出现错误之后就不能取消其他Goroutine了。 如果多个Goroutine出现错误，我们只会获取到第一个出错的Goroutine的错误信息，晚于第一个出错的Goroutine的错误信息将不会被感知到。 errGroup中没有做panic处理，我们在Go方法中传入func() error方法时要保证程序的健壮性 ","date":"2021-08-06","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%8C%85%E4%B9%8Berrgroup/:3:3","tags":["并发编程"],"title":"Go语言并发编程包之errgroup","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%8C%85%E4%B9%8Berrgroup/"},{"categories":["Go面试"],"content":"踩坑日记 使用errGroup也并不是一番风顺的，我之前在项目中使用errGroup就出现了一个BUG，把它分享出来，避免踩坑。 这个需求是这样的(并不是真实业务场景，由asong虚构的)：开启多个Goroutine去缓存中设置数据，同时开启一个Goroutine去异步写日志，很快我的代码就写出来了： func main() { g, ctx := errgroup.WithContext(context.Background()) // 单独开一个协程去做其他的事情，不参与waitGroup go WriteChangeLog(ctx) for i:=0 ; i\u003c 3; i++{ g.Go(func() error { return errors.New(\"访问redis失败\\n\") }) } if err := g.Wait();err != nil{ fmt.Printf(\"appear error and err is %s\",err.Error()) } time.Sleep(1 * time.Second) } func WriteChangeLog(ctx context.Context) error { select { case \u003c- ctx.Done(): return nil case \u003c- time.After(time.Millisecond * 50): fmt.Println(\"write changelog\") } return nil } // 运行结果 appear error and err is 访问redis失败 代码没啥问题吧，但是日志一直没有写入，排查了好久，终于找到问题原因。原因就是这个ctx。 因为这个ctx是WithContext方法返回的一个带取消的ctx，我们把这个ctx当作父context传入WriteChangeLog方法中了，如果errGroup取消了，也会导致上下文的context都取消了，所以WriteChangelog方法就一直执行不到。 这个点是我们在日常开发中想不到的，所以需要注意一下～。 ","date":"2021-08-06","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%8C%85%E4%B9%8Berrgroup/:4:0","tags":["并发编程"],"title":"Go语言并发编程包之errgroup","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%8C%85%E4%B9%8Berrgroup/"},{"categories":["Go面试"],"content":"总结 因为最近看很多朋友都不知道这个库，所以今天就把他分享出来了，封装代码仅仅不到50行，真的是很厉害，如果让你来封装，你能封装的更好吗？ 素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！我是asong，我们下期见。 创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：关注公众号获取。更多学习资料请到公众号领取。 推荐往期文章： 学习channel设计：从入门到放弃 编程模式之Go如何实现装饰器 Go语言中new和make你使用哪个来分配内存？ 源码剖析panic与recover，看不懂你打我好了！ 空结构体引发的大型打脸现场 面试官：你能聊聊string和[]byte的转换吗？ 面试官：两个nil比较结果是什么？ 面试官：你能用Go写段代码判断当前系统的存储方式吗? 赏析Singleflight设计 ","date":"2021-08-06","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%8C%85%E4%B9%8Berrgroup/:5:0","tags":["并发编程"],"title":"Go语言并发编程包之errgroup","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%8C%85%E4%B9%8Berrgroup/"},{"categories":["Go面试"],"content":"前言 哈喽，大家好，我是asong。最近无聊看了一下Go语言的面试八股文，发现面试官都喜欢问内存逃逸这个话题，这个激起了我的兴趣，我对内存逃逸的了解很浅，所以找了很多文章精读了一下，在这里做一个总结，方便日后查阅、学习。 ","date":"2021-08-01","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/:1:0","tags":["逃逸分析"],"title":"Go语言的内存逃逸分析","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"},{"categories":["Go面试"],"content":"什么是内存逃逸 初次看到这个话题，我是懵逼的，怎么还有内存逃逸，内存逃逸到底是干什么的？接下来我们一起来看看什么是内存逃逸。 我们都知道一般情况下程序存放在rom或者Flash中，运行时需要拷贝到内存中执行，内存会分别存储不同的信息，内存空间包含两个最重要的区域：堆区(Stack)和栈区(Heap)，对于我这种C语言出身的人，对堆内存和栈内存的了解还是挺深的。在C语言中，栈区域会专门存放函数的参数、局部变量等，栈的地址从内存高地址往低地址增长，而堆内存正好相反，堆地址从内存低地址往高地址增长，但是如果我们想在堆区域分配内存需要我们手动调用malloc函数去堆区域申请内存分配，然后我使用完了还需要自己手动释放，如果没有释放就会导致内存泄漏。写过C语言的朋友应该都知道C语言函数是不能返回局部变量地址(特指存放于栈区的局部变量地址)，除非是局部静态变量地址，字符串常量地址、动态分配地址。其原因是一般局部变量的作用域只在函数内，其存储位置在栈区中，当程序调用完函数后，局部变量会随此函数一起被释放。其地址指向的内容不明（原先的数值可能不变，也可能改变）。而局部静态变量地址和字符串常量地址存放在数据区，动态分配地址存放在堆区，函数运行结束后只会释放栈区的内容，而不会改变数据区和堆区。 所以在C语言中我们想在一个函数中返回局部变量地址时，有三个正确的方式：返回静态局部变量地址、返回字符串常量地址，返回动态分配在堆上的地址，因为他们都不在栈区，即使释放函数，其内容也不会受影响，我们以在返回堆上内存地址为例看一段代码： #include \"stdio.h\"#include \"stdlib.h\"//返回动态分配的地址 int* f1() { int a = 9; int *pa = (int*) malloc(8); *pa = a; return pa; } int main() { int *pb; pb = f1(); printf(\"after : *pb = %d\\tpb = %p\\n\",*pb, pb); free(pb); return 1; } 通过上面的例子我们知道在C语言中动态内存的分配与释放完全交与程序员的手中，这样就会导致我们在写程序时如履薄冰，好处是我们可以完全掌控内存，缺点是我们一不小心就会导致内存泄漏，所以很多现代语言都有GC机制，Go就是一门带垃圾回收的语言，真正解放了我们程序员的双手，我们不需要在像写C语言那样考虑是否能返回局部变量地址了，内存管理交与给编译器，编译器会经过逃逸分析把变量合理的分配到\"正确\"的地方。 说到这里，可以简单总结一下什么是内存逃逸了： 在一段程序中，每一个函数都会有自己的内存区域存放自己的局部变量、返回地址等，这些内存会由编译器在栈中进行分配，每一个函数都会分配一个栈桢，在函数运行结束后进行销毁，但是有些变量我们想在函数运行结束后仍然使用它，那么就需要把这个变量在堆上分配，这种从\"栈\"上逃逸到\"堆\"上的现象就成为内存逃逸。 ","date":"2021-08-01","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/:2:0","tags":["逃逸分析"],"title":"Go语言的内存逃逸分析","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"},{"categories":["Go面试"],"content":"什么是逃逸分析 上面我们知道了什么是内存逃逸，下面我们就来看一看什么是逃逸分析？ 上文我们说到C语言使用malloc在堆上动态分配内存后，还需要手动调用free释放内存，如果不释放就会造成内存泄漏的风险。在Go语言中堆内存的分配与释放完全不需要我们去管了，Go语言引入了GC机制，GC机制会对位于堆上的对象进行自动管理，当某个对象不可达时(即没有其对象引用它时)，他将会被回收并被重用。虽然引入GC可以让开发人员降低对内存管理的心智负担，但是GC也会给程序带来性能损耗，当堆内存中有大量待扫描的堆内存对象时，将会给GC带来过大的压力，虽然Go语言使用的是标记清除算法，并且在此基础上使用了三色标记法和写屏障技术，提高了效率，但是如果我们的程序仍在堆上分配了大量内存，依赖会对GC造成不可忽视的压力。因此为了减少GC造成的压力，Go语言引入了逃逸分析，也就是想法设法尽量减少在堆上的内存分配，可以在栈中分配的变量尽量留在栈中。 小结逃逸分析： 逃逸分析就是指程序在编译阶段根据代码中的数据流，对代码中哪些变量需要在栈中分配，哪些变量需要在堆上分配进行静态分析的方法。堆和栈相比，堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。栈内存分配则会非常快。栈分配内存只需要两个CPU指令：“PUSH”和“RELEASE”，分配和释放；而堆分配内存首先需要去找到一块大小合适的内存块，之后要通过垃圾回收才能释放。所以逃逸分析更做到更好内存分配，提高程序的运行速度。 ","date":"2021-08-01","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/:3:0","tags":["逃逸分析"],"title":"Go语言的内存逃逸分析","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"},{"categories":["Go面试"],"content":"Go语言中的逃逸分析 Go语言的逃逸分析总共实现了两个版本： 1.13版本前是第一版 1.13版本后是第二版 粗略看了一下逃逸分析的代码，大概有1500+行（go1.15.7）。代码我倒是没仔细看，注释我倒是仔细看了一遍，注释写的还是很详细的，代码路径：src/cmd/compile/internal/gc/escape.go，大家可以自己看一遍注释，其逃逸分析原理如下： pointers to stack objects cannot be stored in the heap：指向栈对象的指针不能存储在堆中 pointers to a stack object cannot outlive that object：指向栈对象的指针不能超过该对象的存活期，也就说指针不能在栈对象被销毁后依旧存活。（例子：声明的函数返回并销毁了对象的栈帧，或者它在循环迭代中被重复用于逻辑上不同的变量） 我们大概知道它的分析准则是什么就好了，具体逃逸分析是怎么做的，感兴趣的同学可以根据源码自行研究。 既然逃逸分析是在编译阶段进行的，那我们就可以通过go build -gcflags '-m -m -l'命令查看到逃逸分析的结果，我们之前在分析内联优化时使用的-gcflags '-m -m'，能看到所有的编译器优化，这里使用-l禁用掉内联优化，只关注逃逸优化就好了。 现在我们也知道了逃逸分析，接下来我们就看几个逃逸分析的例子。 ","date":"2021-08-01","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/:4:0","tags":["逃逸分析"],"title":"Go语言的内存逃逸分析","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"},{"categories":["Go面试"],"content":"几个逃逸分析的例子 ","date":"2021-08-01","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/:5:0","tags":["逃逸分析"],"title":"Go语言的内存逃逸分析","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"},{"categories":["Go面试"],"content":"1. 函数返回局部指针变量 先看例子： func Add(x,y int) *int { res := 0 res = x + y return \u0026res } func main() { Add(1,2) } 查看逃逸分析结果： go build -gcflags=\"-m -m -l\" ./test1.go # command-line-arguments ./test1.go:6:9: \u0026res escapes to heap ./test1.go:6:9: from ~r2 (return) at ./test1.go:6:2 ./test1.go:4:2: moved to heap: res 分析结果很明了，函数返回的局部变量是一个指针变量，当函数Add执行结束后，对应的栈桢就会被销毁，但是引用已经返回到函数之外，如果我们在外部解引用地址，就会导致程序访问非法内存，就像上面的C语言的例子一样，所以编译器经过逃逸分析后将其在堆上分配内存。 ","date":"2021-08-01","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/:5:1","tags":["逃逸分析"],"title":"Go语言的内存逃逸分析","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"},{"categories":["Go面试"],"content":"2. interface类型逃逸 先看一个例子： func main() { str := \"asong太帅了吧\" fmt.Printf(\"%v\",str) } 查看逃逸分析结果： go build -gcflags=\"-m -m -l\" ./test2.go # command-line-arguments ./test2.go:9:13: str escapes to heap ./test2.go:9:13: from ... argument (arg to ...) at ./test2.go:9:13 ./test2.go:9:13: from *(... argument) (indirection) at ./test2.go:9:13 ./test2.go:9:13: from ... argument (passed to call[argument content escapes]) at ./test2.go:9:13 ./test2.go:9:13: main ... argument does not escape str是main函数中的一个局部变量，传递给fmt.Println()函数后发生了逃逸，这是因为fmt.Println()函数的入参是一个interface{}类型，如果函数参数为interface{}，那么在编译期间就很难确定其参数的具体类型，也会发送逃逸。 观察这个分析结果，我们可以看到没有moved to heap: str，这也就是说明str变量并没有在堆上进行分配，只是它存储的值逃逸到堆上了，也就说任何被str引用的对象必须分配在堆上。如果我们把代码改成这样： func main() { str := \"asong太帅了吧\" fmt.Printf(\"%p\",\u0026str) } 查看逃逸分析结果： go build -gcflags=\"-m -m -l\" ./test2.go # command-line-arguments ./test2.go:9:18: \u0026str escapes to heap ./test2.go:9:18: from ... argument (arg to ...) at ./test2.go:9:12 ./test2.go:9:18: from *(... argument) (indirection) at ./test2.go:9:12 ./test2.go:9:18: from ... argument (passed to call[argument content escapes]) at ./test2.go:9:12 ./test2.go:9:18: \u0026str escapes to heap ./test2.go:9:18: from \u0026str (interface-converted) at ./test2.go:9:18 ./test2.go:9:18: from ... argument (arg to ...) at ./test2.go:9:12 ./test2.go:9:18: from *(... argument) (indirection) at ./test2.go:9:12 ./test2.go:9:18: from ... argument (passed to call[argument content escapes]) at ./test2.go:9:12 ./test2.go:8:2: moved to heap: str ./test2.go:9:12: main ... argument does not escape 这回str也逃逸到了堆上，在堆上进行内存分配，这是因为我们访问str的地址，因为入参是interface类型，所以变量str的地址以实参的形式传入fmt.Printf后被装箱到一个interface{}形参变量中，装箱的形参变量的值要在堆上分配，但是还要存储一个栈上的地址，也就是str的地址，堆上的对象不能存储一个栈上的地址，所以str也逃逸到堆上，在堆上分配内存。（这里注意一个知识点：Go语言的参数传递只有值传递） ","date":"2021-08-01","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/:5:2","tags":["逃逸分析"],"title":"Go语言的内存逃逸分析","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"},{"categories":["Go面试"],"content":"3. 闭包产生的逃逸 func Increase() func() int { n := 0 return func() int { n++ return n } } func main() { in := Increase() fmt.Println(in()) // 1 } 查看逃逸分析结果： go build -gcflags=\"-m -m -l\" ./test3.go # command-line-arguments ./test3.go:10:3: Increase.func1 capturing by ref: n (addr=true assign=true width=8) ./test3.go:9:9: func literal escapes to heap ./test3.go:9:9: from ~r0 (assigned) at ./test3.go:7:17 ./test3.go:9:9: func literal escapes to heap ./test3.go:9:9: from \u0026(func literal) (address-of) at ./test3.go:9:9 ./test3.go:9:9: from ~r0 (assigned) at ./test3.go:7:17 ./test3.go:10:3: \u0026n escapes to heap ./test3.go:10:3: from func literal (captured by a closure) at ./test3.go:9:9 ./test3.go:10:3: from \u0026(func literal) (address-of) at ./test3.go:9:9 ./test3.go:10:3: from ~r0 (assigned) at ./test3.go:7:17 ./test3.go:8:2: moved to heap: n ./test3.go:17:16: in() escapes to heap ./test3.go:17:16: from ... argument (arg to ...) at ./test3.go:17:13 ./test3.go:17:16: from *(... argument) (indirection) at ./test3.go:17:13 ./test3.go:17:16: from ... argument (passed to call[argument content escapes]) at ./test3.go:17:13 ./test3.go:17:13: main ... argument does not escape 因为函数也是一个指针类型，所以匿名函数当作返回值时也发生了逃逸，在匿名函数中使用外部变量n，这个变量n会一直存在直到in被销毁，所以n变量逃逸到了堆上。 ","date":"2021-08-01","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/:5:3","tags":["逃逸分析"],"title":"Go语言的内存逃逸分析","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"},{"categories":["Go面试"],"content":"4. 变量大小不确定及栈空间不足引发逃逸 我们先使用ulimit -a查看操作系统的栈空间： ulimit -a -t: cpu time (seconds) unlimited -f: file size (blocks) unlimited -d: data seg size (kbytes) unlimited -s: stack size (kbytes) 8192 -c: core file size (blocks) 0 -v: address space (kbytes) unlimited -l: locked-in-memory size (kbytes) unlimited -u: processes 2784 -n: file descriptors 256 我的电脑的栈空间大小是8192，所以根据这个我们写一个测试用例： package main import ( \"math/rand\" ) func LessThan8192() { nums := make([]int, 100) // = 64KB for i := 0; i \u003c len(nums); i++ { nums[i] = rand.Int() } } func MoreThan8192(){ nums := make([]int, 1000000) // = 64KB for i := 0; i \u003c len(nums); i++ { nums[i] = rand.Int() } } func NonConstant() { number := 10 s := make([]int, number) for i := 0; i \u003c len(s); i++ { s[i] = i } } func main() { NonConstant() MoreThan8192() LessThan8192() } 查看逃逸分析结果： go build -gcflags=\"-m -m -l\" ./test4.go # command-line-arguments ./test4.go:8:14: LessThan8192 make([]int, 100) does not escape ./test4.go:16:14: make([]int, 1000000) escapes to heap ./test4.go:16:14: from make([]int, 1000000) (non-constant size) at ./test4.go:16:14 ./test4.go:25:11: make([]int, number) escapes to heap ./test4.go:25:11: from make([]int, number) (non-constant size) at ./test4.go:25:11 我们可以看到，当栈空间足够时，不会发生逃逸，但是当变量过大时，已经完全超过栈空间的大小时，将会发生逃逸到堆上分配内存。 同样当我们初始化切片时，没有直接指定大小，而是填入的变量，这种情况为了保证内存的安全，编译器也会触发逃逸，在堆上进行分配内存。 参考文章（建议大家阅读一遍） https://driverzhang.github.io/post/golang%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/ https://segmentfault.com/a/1190000039843497 https://tonybai.com/2021/05/24/understand-go-escape-analysis-by-example/ https://cloud.tencent.com/developer/article/1732263 https://geektutu.com/post/hpg-escape-analysis.html ","date":"2021-08-01","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/:5:4","tags":["逃逸分析"],"title":"Go语言的内存逃逸分析","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"},{"categories":["Go面试"],"content":"总结 本文到这里结束了，这篇文章我们一起分析了什么是内存逃逸以及Go语言中的逃逸分析，上面只列举了几个例子，因为发生的逃逸的情况是列举不全的，我们只需要了解什么是逃逸分析，了解逃逸的策略就可以了，后面在实战中可以根据具体代码具体分析，写出更优质的代码。 最后对逃逸做一个总结： 逃逸分析在编译阶段确定哪些变量可以分配在栈中，哪些变量分配在堆上 逃逸分析减轻了GC压力，提高程序的运行速度 栈上内存使用完毕不需要GC处理，堆上内存使用完毕会交给GC处理 函数传参时对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值能够获得更好的性能 根据代码具体分析，尽量减少逃逸代码，减轻GC压力，提高性能 素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！我是asong，我们下期见。 创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：关注公众号获取。更多学习资料请到公众号领取。 推荐往期文章： 学习channel设计：从入门到放弃 编程模式之Go如何实现装饰器 Go语言中new和make你使用哪个来分配内存？ 源码剖析panic与recover，看不懂你打我好了！ 空结构体引发的大型打脸现场 面试官：你能聊聊string和[]byte的转换吗？ 面试官：两个nil比较结果是什么？ 面试官：你能用Go写段代码判断当前系统的存储方式吗? ","date":"2021-08-01","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/:6:0","tags":["逃逸分析"],"title":"Go语言的内存逃逸分析","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"},{"categories":["Go源码"],"content":"前言 哈喽，大家好，我是asong，今天这篇文章的目的主要是解答一位读者的疑问，涉及知识点是反射和结构体内存布局。我们先看一下读者的问题： 我们通过两个问题来解决他的疑惑： 结构体在内存中是如何存储的 反射获取结构体成员信息的过程 ","date":"2021-07-26","objectID":"https://asong2020.github.io/%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5%E8%BF%87%E7%A8%8B/:1:0","tags":["标准库"],"title":"Go语言反射获取结构体字段的过程","uri":"https://asong2020.github.io/%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5%E8%BF%87%E7%A8%8B/"},{"categories":["Go源码"],"content":"结构体是如何存储的 结构体是占用一块连续的内存，一个结构体变量的大小是由结构体中的字段决定的，结构体变量的地址等于结构体第一个字段的首地址。示例： type User struct { Name string Age uint64 Gender bool // true：男 false: 女 } func main(){ u := User{ Name: \"asong\", Age: 18, Gender: false, } fmt.Printf(\"%p\\n\",\u0026u) fmt.Printf(\"%p\\n\",\u0026u.Name) } // 运行结果 0xc00000c060 0xc00000c060 从运行结果我们可以验证了结构体变量u的存放地址就是字段Name的首地址。 结构体的内存布局其实就是分配一段连续的内存，具体是在栈上分配还是堆上分配取决于编译器的逃逸分析，结构体在内存分配时还要考虑到内存对齐。 对齐的作用和原因：CPU访问内存时，并不是逐个字节访问，而是以字长（word size)单位访问。比如32位的CPU，字长为4字节，那么CPU访问内存的单位也是4字节。这样设计可以减少CPU访问内存的次数，加大CPU访问内存的吞吐量。假设我们需要读取8个字节的数据，一次读取4个字节那么就只需读取2次就可以。内存对齐对实现变量的原子性操作也是有好处的，每次内存访问都是原子的，如果变量的大小不超过字长，那么内存对齐后，对该变量的访问就是原子的，这个特性在并发场景下至关重要。 C语言的内存对齐规则与Go语言一样，所以C语言的对齐规则对Go同样适用： 对于结构的各个成员，第一个成员位于偏移为0的位置，结构体第一个成员的偏移量（offset）为0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。 除了结构成员需要对齐，结构本身也需要对齐，结构的长度必须是编译器默认的对齐长度和成员中最长类型中最小的数据大小的倍数对齐。 根据这个规则我们来分析一下上面示例的结构体User，这里我使用的mac，所以是64位CPU，编译器默认对齐参数是8，String、uint64、bool的对齐值分别是8、8、1，根据第一条规则分析： 第一个字段类型是string，对齐值是8，大小为16，所以放在内存布局中的第一位。 第二个字段类型是uin64，对齐值是8，大小为8，所以他的内存偏移值必须是8的倍数，因为第一个字段Name占有16位，所以直接从16开始不要补位。 第三个字段类型是bool，对齐值是1，大小为1，所以他的内存偏移值必须是1的倍数，因为User的前两个字段已经排到了24位，所以下一个偏移量正好是24。 接下来我们在分析第二个规则： 根据第一条内存对齐规则分析后，内存长度已经为25字节了，我们开始使用第2条规则进行对齐，默认对齐值是8，字段中最大类型的长度是16，所以可以得出该结构体的对齐值是8，我们目前的内存长度是25，不是8的倍数，所以需要补全，所以最终的结果是32，补了7位，由编译器进行填充，一般为0值，也称之为空洞。 注意：这里对内存对齐没有说的很细，想要更深了解内存对齐可以看我之前的一篇文章：Go看源码必会知识之unsafe包 ","date":"2021-07-26","objectID":"https://asong2020.github.io/%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5%E8%BF%87%E7%A8%8B/:2:0","tags":["标准库"],"title":"Go语言反射获取结构体字段的过程","uri":"https://asong2020.github.io/%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5%E8%BF%87%E7%A8%8B/"},{"categories":["Go源码"],"content":"Go语言反射获取结构体成员信息 Go语言提供了一种机制在运行时更新和检查变量的值、调用变量的方法和变量的内在操作，但是在编译时并不知道这些变量的具体类型，这种机制被称为反射。Go语言提供了 reflect 包来访问程序的反射信息。 我们可以通过调用reflect.TypeOf()获得反射对象信息，如果他的类型是结构体，接着可以通过反射值对象reflect.Type的NumField和Field方法获取结构体成员的详细信息，先看一个例子： type User struct { Name string Age uint64 Gender bool // true：男 false: 女 } func main() { u := User{ Name: \"asong\", Age: 18, Gender: false, } getType := reflect.TypeOf(u) for i:=0; i \u003c getType.NumField(); i++{ fieldType := getType.Field(i) // 输出成员名 fmt.Printf(\"name: %v \\n\", fieldType.Name) } } // 运行结果 name: Name name: Age name: Gender 接下来我们就一起来看一看Go语言是如何通过反射来获取结构体成员信息的。 首先我们来看一看reflect.TypeOf()方法是如何获取到类型的： func TypeOf(i interface{}) Type { eface := *(*emptyInterface)(unsafe.Pointer(\u0026i)) return toType(eface.typ) } 我们知道在Go语言中任何类型都可以转成interface{}类型，当向接口变量赋于一个实体类型的时候，接口会存储实体的类型信息，反射就是通过接口的类型信息实现的。 一个空接口结构如下： type eface struct { _type *_type data unsafe.Pointer } _type 字段，表示空接口所承载的具体的实体类型。data 描述了具体的值，Go 语言里所有的类型都 实现了 空接口。 所以在TypeOf方法中，我们就是通过读取_type字段获取到类型。 现在我们已经知道他是怎么获取到具体的类型了，接下来我们就来看一看NumField()方法是怎么获取到字段的。 func (t *rtype) Kind() Kind { return Kind(t.kind \u0026 kindMask) } func (t *rtype) NumField() int { if t.Kind() != Struct { panic(\"reflect: NumField of non-struct type \" + t.String()) } tt := (*structType)(unsafe.Pointer(t)) return len(tt.fields) } 因为只有struct类型才可以调用，所以在NumFiled()方法中做了类型检查，如果不是struct类型则直接发生panic，然后会rtype类型强制转换成structType，最后返回结构体成员字段的数量。 // structType represents a struct type. type structType struct { rtype pkgPath name fields []structField // sorted by offset } // Struct field type structField struct { name name // name is always non-empty typ *rtype // type of field offsetEmbed uintptr // byte offset of field\u003c\u003c1 | isEmbedded } 调用Field()方法会根据索引返回对应的结构体字段的信息，当值不是结构体或索引超界时发生panic。 func (t *rtype) Field(i int) StructField { // 类型检查 if t.Kind() != Struct { panic(\"reflect: Field of non-struct type \" + t.String()) } // 强制转换成structType 类型 tt := (*structType)(unsafe.Pointer(t)) return tt.Field(i) } // Field returns the i'th struct field. func (t *structType) Field(i int) (f StructField) { // 溢出检查 if i \u003c 0 || i \u003e= len(t.fields) { panic(\"reflect: Field index out of bounds\") } // 获取之前structType中fields字段的值 p := \u0026t.fields[i] // 转换成StructFiled结构体 f.Type = toType(p.typ) f.Name = p.name.name() // 判断是否是匿名结构体 f.Anonymous = p.embedded() if !p.name.isExported() { f.PkgPath = t.pkgPath.name() } if tag := p.name.tag(); tag != \"\" { f.Tag = StructTag(tag) } // 获取字段的偏移量 f.Offset = p.offset() // 获取索引值 f.Index = []int{i} return } 返回StructField结构如下： // A StructField describes a single field in a struct. type StructField struct { Name string // 字段名 PkgPath string // 字段路径 Type Type // 字段反射类型对象 Tag StructTag // 字段的结构体标签 Offset uintptr // 字段在结构体中的相对偏移 Index []int // Type.FieldByIndex中的返回的索引值 Anonymous bool // 是否为匿名字段 } 到这里整个反射获取结构体成员信息的过程应该很明朗了吧～。 **小结：**因为Go 语言里所有的类型都 实现了 空接口，所以可以根据这个特性获取到数据类型以及存放数据的地址，对于结构体类型，将其转换为structType类型，最后转换成StructField结构获取所有结构体信息。 ","date":"2021-07-26","objectID":"https://asong2020.github.io/%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5%E8%BF%87%E7%A8%8B/:3:0","tags":["标准库"],"title":"Go语言反射获取结构体字段的过程","uri":"https://asong2020.github.io/%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5%E8%BF%87%E7%A8%8B/"},{"categories":["Go源码"],"content":"总结 本文没想详细展开讲解Go语言反射的原理和过程，只是简单介绍了一下反射获取到结构体成员信息的过程，更多关于反射知识的讲解会在后面持续更新，敬请期待～。 素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！我是asong，我们下期见。 创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：关注公众号获取。更多学习资料请到公众号领取。 推荐往期文章： 学习channel设计：从入门到放弃 编程模式之Go如何实现装饰器 Go语言中new和make你使用哪个来分配内存？ 源码剖析panic与recover，看不懂你打我好了！ 空结构体引发的大型打脸现场 面试官：你能聊聊string和[]byte的转换吗？ 面试官：两个nil比较结果是什么？ 面试官：你能用Go写段代码判断当前系统的存储方式吗? 赏析Singleflight设计 ","date":"2021-07-26","objectID":"https://asong2020.github.io/%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5%E8%BF%87%E7%A8%8B/:4:0","tags":["标准库"],"title":"Go语言反射获取结构体字段的过程","uri":"https://asong2020.github.io/%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5%E8%BF%87%E7%A8%8B/"},{"categories":["Go源码"],"content":"前言 哈喽，大家好，我是asong。今天与大家来聊一聊内联函数。虽然我们在开发中根本不需要考虑内联函数，其在编译器编译代码时会做优化，但是如果想分析更底层的技术，这个知识是要必备，今天我们就一起来看看什么是内联函数以及Go编译器是如何对函数调用做优化的！ ","date":"2021-07-15","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/:1:0","tags":["编译器"],"title":"GO语言中的内联函数","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"},{"categories":["Go源码"],"content":"什么是内联函数 学过C语言的朋友应该对内联函数不陌生吧，在C语言中一个inline关键字，使用inline修饰的函数就是内联函数。 示例： #include \u003cstdio.h\u003e inline char* chooseParity(int a) { return (i % 2 \u003e 0) ? \"奇\" : \"偶\"; } int main() { int i = 0; for (i=1; i \u003c 100; i++) { printf(\"i:%d 奇偶性:%s /n\", i, chooseParity(i)); } } 这段代码中函数char* chooseParity(int a)使用inline进行修饰，那么这段代码在执行的时候就会变成这样： int i = 0; for (i=1; i \u003c 100; i++) { printf(\"i:%d 奇偶性:%s /n\", i, (i % 2 \u003e 0) ? \"奇\" : \"偶\"); } 这样就避免了频繁调用函数对栈内存重复开辟所带来的消耗，我们都知道一些函数被频繁调用，会不断地有函数入栈，即函数栈，会造成栈空间或栈内存的大量消耗，内联函数的出现节省了每次调用函数带来的额外时间开支。但并不是所有场景都可以使用内联函数的，必须在程序占用空间和程序执行效率之间进行权衡，因为过多的比较复杂的函数进行内联扩展将带来很大的存储资源开支。 大多数语言的内联函数的优化都是在编译器编译代码时进行的，在C语言中编译器也会对函数调用进行优化，但是其还是提供了inline关键字，这是因为在C编译其中可以选择不同的优化级别，有些函数在As-if规则是不可分辨的，所以提供inline供使用者使用，保证没有触发规则时，仍然是内联函数，说难听点就是起到擦屁股的作用！ Go 语言的编译器也会对函数调用进行优化，但是他没有提供任何关键字可以手动声明内联函数，不过我们可以在函数上添加//go:noinline注释告诉编译器不要对它进行内联优化。 示例： //go:noinline func maxValue(a,b int) int { if a \u003e b{ return a } return b } ","date":"2021-07-15","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/:2:0","tags":["编译器"],"title":"GO语言中的内联函数","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"},{"categories":["Go源码"],"content":"内联函数优化带来的性能提升 接下来，我们来写一个简单的例子看一看内联函数与非内联函数的差异。 //go:noinline func AddNoinline(x,y,z int) int { return x+y+z } func AddInline(x,y,z int) int { return x+y+z } func BenchmarkAddNoinline(b *testing.B) { x,y,z :=1,2,3 b.ResetTimer() for i:=0;i\u003cb.N;i++{ AddInline(x,y,z) } } func BenchmarkAddInline(b *testing.B) { x,y,z :=1,2,3 b.ResetTimer() for i:=0;i\u003cb.N;i++{ AddNoinline(x,y,z) } } 运行结果： goos: darwin goarch: amd64 pkg: asong.cloud/Golang_Dream/code_demo/inline BenchmarkAddNoinline-16 722205944 1.55 ns/op BenchmarkAddInline-16 1000000000 0.237 ns/op PASS ok asong.cloud/Golang_Dream/code_demo/inline 3.200s 从运行结果我们可以看出内联函数的处理速度还是略快于非内联函数，因为我这个例子比较简单，所以差异还不是特别明显。 ","date":"2021-07-15","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/:3:0","tags":["编译器"],"title":"GO语言中的内联函数","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"},{"categories":["Go源码"],"content":"查看编译器做了什么优化 我们在编译代码时传入--gcflags=-m 参数可以查看编译器的优化策略，传入--gcflags=\"-m -m\"会查看更完整的优化策略！ 示例： func main(){ s := []int{10,12,3,14} fmt.Println(GetMaxValue(s)) } func GetMaxValue(s []int) int { max :=0 for i:=0;i\u003clen(s);i++{ max = maxValue(s[i],max) } return max } func maxValue(a,b int) int { if a \u003e b{ return a } return b } 执行 go build --gcflags=\"-m -m\" ./test.go，输出如下结果： # command-line-arguments ./test.go:20:6: can inline maxValue with cost 8 as: func(int, int) int { if a \u003e b { return a }; return b } ./test.go:12:6: cannot inline GetMaxValue: unhandled op FOR ./test.go:15:17: inlining call to maxValue func(int, int) int { if a \u003e b { return a }; return b } ./test.go:7:6: cannot inline main: function too complex: cost 145 exceeds budget 80 ./test.go:9:13: inlining call to fmt.Println func(...interface {}) (int, error) { var fmt..autotmp_3 int; fmt..autotmp_3 = \u003cN\u003e; var fmt..autotmp_4 error; fmt..autotmp_4 = \u003cN\u003e; fmt..autotmp_3, fmt..autotmp_4 = fmt.Fprintln(io.Writer(os.Stdout), fmt.a...); return fmt..autotmp_3, fmt..autotmp_4 } ./test.go:12:18: s does not escape ./test.go:9:25: GetMaxValue(s) escapes to heap: ./test.go:9:25: flow: ~arg0 = \u0026{storage for GetMaxValue(s)}: ./test.go:9:25: from GetMaxValue(s) (spill) at ./test.go:9:25 ./test.go:9:25: from ~arg0 = \u003cN\u003e (assign-pair) at ./test.go:9:13 ./test.go:9:25: flow: {storage for []interface {} literal} = ~arg0: ./test.go:9:25: from []interface {} literal (slice-literal-element) at ./test.go:9:13 ./test.go:9:25: flow: fmt.a = \u0026{storage for []interface {} literal}: ./test.go:9:25: from []interface {} literal (spill) at ./test.go:9:13 ./test.go:9:25: from fmt.a = []interface {} literal (assign) at ./test.go:9:13 ./test.go:9:25: flow: {heap} = *fmt.a: ./test.go:9:25: from fmt.Fprintln(io.Writer(os.Stdout), fmt.a...) (call parameter) at ./test.go:9:13 ./test.go:8:12: []int literal does not escape ./test.go:9:25: GetMaxValue(s) escapes to heap ./test.go:9:13: []interface {} literal does not escape \u003cautogenerated\u003e:1: .this does not escape 编译器判断函数maxValue可以进行内联，在函数GetMaxValue中对maxValue的调用就是内联，但是函数GetMaxValue是不能内联的，原因是使用了FOR循环，与Go编译器优化规则有关，我们在下一节介绍。还对fmt.Println 进行了内联优化。后面几行都是逃逸分析，后面会专门写一篇文章来了解逃逸分析～。 ","date":"2021-07-15","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/:4:0","tags":["编译器"],"title":"GO语言中的内联函数","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"},{"categories":["Go源码"],"content":"Go编译器内联优化规则 我们在/src/cmd/compile/internal/gc/inl.go中看到内联优化相关的代码： inlineMaxBudget = 80 func (v *hairyVisitor) visit(n *Node) bool { if n == nil { return false } switch n.Op { .... //省略部分代码 case OCLOSURE, OCALLPART, ORANGE, OFOR, OFORUNTIL, OSELECT, OTYPESW, OGO, ODEFER, ODCLTYPE, // can't print yet OBREAK, ORETJMP: v.reason = \"unhandled op \" + n.Op.String() return true .... //省略部分代码 } return v.visit(n.Left) || v.visit(n.Right) || v.visitList(n.List) || v.visitList(n.Rlist) || v.visitList(n.Ninit) || v.visitList(n.Nbody) } 从这里可以看出一个规则： 闭包，select，for，defer，go关键字所开启的新goroutine等不会进行内联； Go函数中超过80个节点的代码量就不再内联，根据解析的AST节点数量来做判断； 其实这部分规则还是很多的，代码量也是1300+，看仔细还是挺有难度的，这里只简单介绍一下一目了然的规则，在日后开发中有个概念就好，更详细的规则可在源码中自己发掘！ ","date":"2021-07-15","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/:5:0","tags":["编译器"],"title":"GO语言中的内联函数","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"},{"categories":["Go源码"],"content":"内联函数带来的问题 我们知道内联函数会直接把函数替换为函数的内容，这样就会引入一个问题，如果发生panic时，开发者需要知道panic的准确堆栈信息，获取源码文件以及行号，但是因为使用了内联函数，那么错误日志就打印在错误的地方，这就会产生误导性。Go开发者当然会考虑到这个问题，他是如何解决的呢？ Go在内部维持了一份内联函数的映射关系，会生成一个内联树，我们可以通过-gcflags=\"-d pctab=pctoinline\"参数查看，看一个例子： func main(){ s := []int{90,100,24,18} Sum(s) } func Sum(s []int) int { sum :=0 for i:=0;i\u003clen(s);i++{ sum = add(sum,s[i]) } return sum } func add(x,y int) int{ panic(\"panic\") return x+y } 运行go build -gcflags=\"-d pctab=pctoinline\" ./test1.go： -- inlining tree for \"\".Sum: 0 | -1 | \"\".add (/Users/go/src/asong.cloud/Golang_Dream/code_demo/inline/test1.go:11:12) pc=39 -- 从结果我们可以看到在inlining tree中为.Sum和.add添加了映射关系。 ","date":"2021-07-15","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/:6:0","tags":["编译器"],"title":"GO语言中的内联函数","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"},{"categories":["Go源码"],"content":"总结 内联函数对于程序的提升是很重要的，函数调用是有开销的，比如：创建新的堆栈帧、保存和恢复寄存器等，所以内联函数的优化可以有效避免一些不必要的开销，你学会了吗？宝贝！ 参考文章：https://medium.com/a-journey-with-go/go-inlining-strategy-limitation-6b6d7fc3b1be 文中代码已上传github：https://github.com/asong2020/Golang_Dream/tree/master/code_demo/inline 素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！我是asong，我们下期见。 创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：关注公众号获取。更多学习资料请到公众号领取。 推荐往期文章： 学习channel设计：从入门到放弃 编程模式之Go如何实现装饰器 Go语言中new和make你使用哪个来分配内存？ 源码剖析panic与recover，看不懂你打我好了！ 空结构体引发的大型打脸现场 面试官：你能聊聊string和[]byte的转换吗？ 面试官：两个nil比较结果是什么？ 面试官：你能用Go写段代码判断当前系统的存储方式吗? 赏析Singleflight设计 ","date":"2021-07-15","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/:7:0","tags":["编译器"],"title":"GO语言中的内联函数","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"},{"categories":["Go应用"],"content":"前言 哈喽，大家好，我是asong。今天想与大家分享一下singleflight这个库，singleflight仅仅只有100多行却可以做到防止缓存击穿，有点厉害哦！所以本文我们就一起来看一看他是怎么设计的～。 注意：本文基于 https://pkg.go.dev/golang.org/x/sync/singleflight进行分析。 ","date":"2021-07-15","objectID":"https://asong2020.github.io/%E8%B5%8F%E6%9E%90singleflight%E8%AE%BE%E8%AE%A1/:1:0","tags":["并发编程"],"title":"防缓存穿透利器-singleflight源码赏析","uri":"https://asong2020.github.io/%E8%B5%8F%E6%9E%90singleflight%E8%AE%BE%E8%AE%A1/"},{"categories":["Go应用"],"content":"缓存击穿 ","date":"2021-07-15","objectID":"https://asong2020.github.io/%E8%B5%8F%E6%9E%90singleflight%E8%AE%BE%E8%AE%A1/:2:0","tags":["并发编程"],"title":"防缓存穿透利器-singleflight源码赏析","uri":"https://asong2020.github.io/%E8%B5%8F%E6%9E%90singleflight%E8%AE%BE%E8%AE%A1/"},{"categories":["Go应用"],"content":"什么是缓存击穿 平常在高并发系统中，会出现大量的请求同时查询一个key的情况，假如此时这个热key刚好失效了，就会导致大量的请求都打到数据库上面去，这种现象就是缓存击穿。缓存击穿和缓存雪崩有点像，但是又有一点不一样，缓存雪崩是因为大面积的缓存失效，打崩了DB，而缓存击穿则是指一个key非常热点，在不停的扛着高并发，高并发集中对着这一个点进行访问，如果这个key在失效的瞬间，持续的并发到来就会穿破缓存，直接请求到数据库，就像一个完好无损的桶上凿开了一个洞，造成某一时刻数据库请求量过大，压力剧增！ ","date":"2021-07-15","objectID":"https://asong2020.github.io/%E8%B5%8F%E6%9E%90singleflight%E8%AE%BE%E8%AE%A1/:2:1","tags":["并发编程"],"title":"防缓存穿透利器-singleflight源码赏析","uri":"https://asong2020.github.io/%E8%B5%8F%E6%9E%90singleflight%E8%AE%BE%E8%AE%A1/"},{"categories":["Go应用"],"content":"如何解决 方法一 我们简单粗暴点，直接让热点数据永远不过期，定时任务定期去刷新数据就可以了。不过这样设置需要区分场景，比如某宝首页可以这么做。 方法二 为了避免出现缓存击穿的情况，我们可以在第一个请求去查询数据库的时候对他加一个互斥锁，其余的查询请求都会被阻塞住，直到锁被释放，后面的线程进来发现已经有缓存了，就直接走缓存，从而保护数据库。但是也是由于它会阻塞其他的线程，此时系统吞吐量会下降。需要结合实际的业务去考虑是否要这么做。 方法三 方法三就是singleflight的设计思路，也会使用互斥锁，但是相对于方法二的加锁粒度会更细，这里先简单总结一下singleflight的设计原理，后面看源码在具体分析。 singleflightd的设计思路就是将一组相同的请求合并成一个请求，使用map存储，只会有一个请求到达mysql，使用sync.waitgroup包进行同步，对所有的请求返回相同的结果。 ","date":"2021-07-15","objectID":"https://asong2020.github.io/%E8%B5%8F%E6%9E%90singleflight%E8%AE%BE%E8%AE%A1/:2:2","tags":["并发编程"],"title":"防缓存穿透利器-singleflight源码赏析","uri":"https://asong2020.github.io/%E8%B5%8F%E6%9E%90singleflight%E8%AE%BE%E8%AE%A1/"},{"categories":["Go应用"],"content":"源码赏析 已经迫不及待了，直奔主题吧，下面我们一起来看看singleflight是怎么设计的。 ","date":"2021-07-15","objectID":"https://asong2020.github.io/%E8%B5%8F%E6%9E%90singleflight%E8%AE%BE%E8%AE%A1/:3:0","tags":["并发编程"],"title":"防缓存穿透利器-singleflight源码赏析","uri":"https://asong2020.github.io/%E8%B5%8F%E6%9E%90singleflight%E8%AE%BE%E8%AE%A1/"},{"categories":["Go应用"],"content":"数据结构 singleflight的结构定义如下： type Group struct { mu sync.Mutex // 互斥锁，保证并发安全 m map[string]*call // 存储相同的请求，key是相同的请求，value保存调用信息。 } Group结构还是比较简单的，只有两个字段，m是一个map，key是相同请求的标识，value是用来保存调用信息，这个map是懒加载，其实就是在使用时才会初始化；mu是互斥锁，用来保证m的并发安全。m存储调用信息也是单独封装了一个结构： type call struct { wg sync.WaitGroup // 存储返回值，在wg done之前只会写入一次 val interface{} // 存储返回的错误信息 err error // 标识别是否调用了Forgot方法 forgotten bool // 统计相同请求的次数，在wg done之前写入 dups int // 使用DoChan方法使用，用channel进行通知 chans []chan\u003c- Result } // Dochan方法时使用 type Result struct { Val interface{} // 存储返回值 Err error // 存储返回的错误信息 Shared bool // 标示结果是否是共享结果 } ","date":"2021-07-15","objectID":"https://asong2020.github.io/%E8%B5%8F%E6%9E%90singleflight%E8%AE%BE%E8%AE%A1/:3:1","tags":["并发编程"],"title":"防缓存穿透利器-singleflight源码赏析","uri":"https://asong2020.github.io/%E8%B5%8F%E6%9E%90singleflight%E8%AE%BE%E8%AE%A1/"},{"categories":["Go应用"],"content":"Do方法 // 入参：key：标识相同请求，fn：要执行的函数 // 返回值：v: 返回结果 err: 执行的函数错误信息 shard: 是否是共享结果 func (g *Group) Do(key string, fn func() (interface{}, error)) (v interface{}, err error, shared bool) { // 代码块加锁 g.mu.Lock() // map进行懒加载 if g.m == nil { // map初始化 g.m = make(map[string]*call) } // 判断是否有相同请求 if c, ok := g.m[key]; ok { // 相同请求次数+1 c.dups++ // 解锁就好了，只需要等待执行结果了，不会有写入操作了 g.mu.Unlock() // 已有请求在执行，只需要等待就好了 c.wg.Wait() // 区分panic错误和runtime错误 if e, ok := c.err.(*panicError); ok { panic(e) } else if c.err == errGoexit { runtime.Goexit() } return c.val, c.err, true } // 之前没有这个请求，则需要new一个指针类型 c := new(call) // sync.waitgroup的用法，只有一个请求运行，其他请求等待，所以只需要add(1) c.wg.Add(1) // m赋值 g.m[key] = c // 没有写入操作了，解锁即可 g.mu.Unlock() // 唯一的请求该去执行函数了 g.doCall(c, key, fn) return c.val, c.err, c.dups \u003e 0 } 这里是唯一有疑问的应该是区分panic和runtime错误部分吧，这个与下面的docall方法有关联，看完docall你就知道为什么了。 ","date":"2021-07-15","objectID":"https://asong2020.github.io/%E8%B5%8F%E6%9E%90singleflight%E8%AE%BE%E8%AE%A1/:3:2","tags":["并发编程"],"title":"防缓存穿透利器-singleflight源码赏析","uri":"https://asong2020.github.io/%E8%B5%8F%E6%9E%90singleflight%E8%AE%BE%E8%AE%A1/"},{"categories":["Go应用"],"content":"docall // doCall handles the single call for a key. func (g *Group) doCall(c *call, key string, fn func() (interface{}, error)) { // 标识是否正常返回 normalReturn := false // 标识别是否发生panic recovered := false defer func() { // 通过这个来判断是否是runtime导致直接退出了 if !normalReturn \u0026\u0026 !recovered { // 返回runtime错误信息 c.err = errGoexit } c.wg.Done() g.mu.Lock() defer g.mu.Unlock() // 防止重复删除key if !c.forgotten { delete(g.m, key) } // 检测是否出现了panic错误 if e, ok := c.err.(*panicError); ok { // 如果是调用了dochan方法，为了channel避免死锁，这个panic要直接抛出去，不能recover住，要不就隐藏错误了 if len(c.chans) \u003e 0 { go panic(e) // 开一个写成panic select {} // 保持住这个goroutine，这样可以将panic写入crash dump } else { panic(e) } } else if c.err == errGoexit { // runtime错误不需要做任何时，已经退出了 } else { // 正常返回的话直接向channel写入数据就可以了 for _, ch := range c.chans { ch \u003c- Result{c.val, c.err, c.dups \u003e 0} } } }() // 使用匿名函数目的是recover住panic，返回信息给上层 func() { defer func() { if !normalReturn { // 发生了panic，我们recover住，然后把错误信息返回给上层 if r := recover(); r != nil { c.err = newPanicError(r) } } }() // 执行函数 c.val, c.err = fn() // fn没有发生panic normalReturn = true }() // 判断执行函数是否发生panic if !normalReturn { recovered = true } } 这里来简单描述一下为什么区分panic和runtime错误，不区分的情况下如果调用出现了恐慌，但是锁没有被释放，导致使用相同密钥的所有后续调用都出现了死锁，具体可以查看这个issue：https://github.com/golang/go/issues/33519。 ","date":"2021-07-15","objectID":"https://asong2020.github.io/%E8%B5%8F%E6%9E%90singleflight%E8%AE%BE%E8%AE%A1/:3:3","tags":["并发编程"],"title":"防缓存穿透利器-singleflight源码赏析","uri":"https://asong2020.github.io/%E8%B5%8F%E6%9E%90singleflight%E8%AE%BE%E8%AE%A1/"},{"categories":["Go应用"],"content":"Dochan和Forget方法 //异步返回 // 入参数：key：标识相同请求，fn：要执行的函数 // 出参数：\u003c- chan 等待接收结果的channel func (g *Group) DoChan(key string, fn func() (interface{}, error)) \u003c-chan Result { // 初始化channel ch := make(chan Result, 1) g.mu.Lock() // 懒加载 if g.m == nil { g.m = make(map[string]*call) } // 判断是否有相同的请求 if c, ok := g.m[key]; ok { //相同请求数量+1 c.dups++ // 添加等待的chan c.chans = append(c.chans, ch) g.mu.Unlock() return ch } c := \u0026call{chans: []chan\u003c- Result{ch}} c.wg.Add(1) g.m[key] = c g.mu.Unlock() // 开一个写成调用 go g.doCall(c, key, fn) // 返回这个channel等待接收数据 return ch } // 释放某个 key 下次调用就不会阻塞等待了 func (g *Group) Forget(key string) { g.mu.Lock() if c, ok := g.m[key]; ok { c.forgotten = true } delete(g.m, key) g.mu.Unlock() } ","date":"2021-07-15","objectID":"https://asong2020.github.io/%E8%B5%8F%E6%9E%90singleflight%E8%AE%BE%E8%AE%A1/:3:4","tags":["并发编程"],"title":"防缓存穿透利器-singleflight源码赏析","uri":"https://asong2020.github.io/%E8%B5%8F%E6%9E%90singleflight%E8%AE%BE%E8%AE%A1/"},{"categories":["Go应用"],"content":"注意事项 因为我们在使用singleflight时需要自己写执行函数，所以如果我们写的执行函数一直循环住了，就会导致我们的整个程序处于循环的状态，积累越来越多的请求，所以在使用时，还是要注意一点的，比如这个例子： result, err, _ := d.singleGroup.Do(key, func() (interface{}, error) { for{ // TODO } } 不过这个问题一般也不会发生，我们在日常开发中都会使用context控制超时。 ","date":"2021-07-15","objectID":"https://asong2020.github.io/%E8%B5%8F%E6%9E%90singleflight%E8%AE%BE%E8%AE%A1/:4:0","tags":["并发编程"],"title":"防缓存穿透利器-singleflight源码赏析","uri":"https://asong2020.github.io/%E8%B5%8F%E6%9E%90singleflight%E8%AE%BE%E8%AE%A1/"},{"categories":["Go应用"],"content":"总结 好啦，这篇文章就到这里啦。因为最近我在项目中也使用singleflight这个库，所以就看了一下源码实现，真的是厉害，这么短的代码就实现了这么重要的功能，我怎么就想不到呢。。。。所以说还是要多读一些源码库，真的能学到好多，真是应了那句话：你知道的越多，不知道的就越多！ 素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！我是asong，我们下期见。 创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：关注公众号获取。更多学习资料请到公众号领取。 推荐往期文章： 学习channel设计：从入门到放弃 Go语言如何实现可重入锁？ Go语言中new和make你使用哪个来分配内存？ 源码剖析panic与recover，看不懂你打我好了！ 空结构体引发的大型打脸现场 面试官：你能聊聊string和[]byte的转换吗？ 面试官：两个nil比较结果是什么？ 面试官：你能用Go写段代码判断当前系统的存储方式吗? 面试中如果这样写二分查找 ","date":"2021-07-15","objectID":"https://asong2020.github.io/%E8%B5%8F%E6%9E%90singleflight%E8%AE%BE%E8%AE%A1/:5:0","tags":["并发编程"],"title":"防缓存穿透利器-singleflight源码赏析","uri":"https://asong2020.github.io/%E8%B5%8F%E6%9E%90singleflight%E8%AE%BE%E8%AE%A1/"},{"categories":["Go应用"],"content":"前言 哈喽，大家好，我是asong。今天想与大家聊一聊如何用Go实现装饰器代码。为什么会有这个想法呢？最近由于项目需要一直在看python的代码，在这个项目中应用了大量的装饰器代码，一个装饰器代码可以在全文共用，减少了冗余代码。python的语法糖让实现装饰器变得很简单，但是Go语言的糖不多，而且又是强类型的静态无虚拟机的语言，所以，没有办法做到像 Java 和 Python 那样写出优雅的装饰器的代码，但也是可以实现的，今天我们就看看如何Go语言写出装饰器代码！ ","date":"2021-07-12","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%A3%85%E9%A5%B0%E5%99%A8/:1:0","tags":["编程模式"],"title":"Go语言编程模式之装饰器","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Go应用"],"content":"什么是装饰器 介绍装饰器基本概念之前，我们先举个例子，跟装饰器很贴切： 如今我们的生活水平提高了，基本人手一台手机，大家也知道手机屏幕摔到地板上是很容易碎屏的，手机屏幕一坏，又要多花一笔费用进行维修，很是心痛；那么有什么什么办法来避免这个问题呢，在不破坏手机屏幕结构的情况下，让我们的手机更耐坏呢？其实我们只需要花几元钱买一个钢化膜，钢化膜在不改变原有手机屏幕的结构下，让手机变得更耐摔了。 根据上面这个例子，就可以引出本文的核心 -\u003e 装饰器。装饰器本质就是： 函数装饰器用于在源码中“标记”函数，以某种方式增强函数的行为。 装饰器是一个强大的功能，但是若想掌握，必须要理解闭包！闭包的概念我们在下面一小节说明，我们先来看一看python是如何使用装饰器的： def metric(fn): @functools.wraps(fn) def timer(*arag, **kw): start = time.time() num = fn(*arag, **kw) end = time.time() times = (end - start) * 1000 print('%s executed in %s ms' % (fn.__name__, times)) return num return timer @metric def Sum(x, y): time.sleep(0.0012) return x + y; Sum(10, 20) 这里要实现功能很简单，metric就是一个装饰器函数，他可以作用于任何函数之上，并打印该函数的执行时间，有个这个装饰器，我们想要知道任何一个函数的执行时间，就简便很多了。 简单总结一下装饰器使用场景： 插入日志：使面向切面编程变的更简单了。 缓存：读写缓存使用装饰器来实现，减少了冗余代码。 事务处理：使代码看起来更简洁了。 权限校验：权限校验器是都是一套代码，减少了冗余代码。 装饰器的使用场景还用很多，就不一一列举了，下面我们就来看看如何使用Go也来实现装饰器代码吧！ ","date":"2021-07-12","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%A3%85%E9%A5%B0%E5%99%A8/:2:0","tags":["编程模式"],"title":"Go语言编程模式之装饰器","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Go应用"],"content":"闭包 装饰器的实现和闭包是分不开的，所以我们先来学习一下什么是闭包！ 我们通常会把闭包和匿名函数弄混，这是因为：在 函数内部定义函数不常见，直到开始使用匿名函数才会这样做。而且， 只有涉及嵌套函数时才有闭包问题。因此，很多人是同时知道这两个概念的。 其实，闭包指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。函数是不是匿名的没有关系，关键是 它能访问定义体之外定义的非全局变量。 光看概念其实挺难理解闭包，我们通过例子来进行理解。 func makeAverager() func(val float32) float32{ series := make([]float32,0) return func(val float32) float32 { series = append(series, val) total := float32(0) for _,v:=range series{ total +=v } return total/ float32(len(series)) } } func main() { avg := makeAverager() fmt.Println(avg(10)) fmt.Println(avg(30)) } 这个例子，你猜运行结果是什么？10,30还是10,20？ 运行一下，答案出来了：10,20。为什么会这样呢？我们来分析一下！ 上面的代码中makeAverager的写法在C语言中是不允许的，因为在C语言中，函数内的内存分配是在栈上的，在makeAverager返回后，这部分栈就被回收了，但是在Go语言中是没有问题的，因为Go语言会进行escape analyze分析出变量的作用范围，将变量在堆上进行内存分配，我们使用go build --gcflags=-m ./test/test1.go 来看一下分析结果： # command-line-arguments test/test1.go:21:13: inlining call to fmt.Println test/test1.go:22:13: inlining call to fmt.Println test/test1.go:8:2: moved to heap: series test/test1.go:8:16: make([]float32, 0) escapes to heap test/test1.go:9:9: func literal escapes to heap test/test1.go:21:17: avg(10) escapes to heap test/test1.go:21:13: []interface {} literal does not escape test/test1.go:22:17: avg(30) escapes to heap test/test1.go:22:13: []interface {} literal does not escape \u003cautogenerated\u003e:1: .this does not escape 从运行结果我们可以看出，series、func、avg都逃逸到了堆上。所以我们可以得出结论，series变量和func(val float32) float32{}被引用后，他所在的函数结束，也不会马上销毁，这也是变相延长了函数的生命周期！ 小结：综上所诉，闭包是一种函数，它会保留定义函数时存在的自由变量的绑定， 这样调用函数时，虽然定义作用域不可用了，但是仍能使用那些绑定。 注意，只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中 的外部变量。 ","date":"2021-07-12","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%A3%85%E9%A5%B0%E5%99%A8/:3:0","tags":["编程模式"],"title":"Go语言编程模式之装饰器","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Go应用"],"content":"Gin中装饰器的应用 大家应该都使用过Gin这个Web框架，其在注册路由时提供了中间件的使用，可以拦截http请求-响应生命周期的特殊函数，在请求-响应生命周期中可以注册多个中间件，每个中间件执行不同的功能，一个中间执行完再轮到下一个中间件执行。这个中间件其实就是使用的装饰器，我们来看一件简单的例子： func VerifyHeader() gin.HandlerFunc { return func(c *gin.Context) { header := c.Request.Header.Get(\"token\") if header == \"\" { c.JSON(200, gin.H{ \"code\": 1000, \"msg\": \"Not logged in\", }) return } } } func main() { r := gin.Default() group := r.Group(\"/api/asong\",VerifyHeader()) { group.GET(\"/ping\", func(context *gin.Context) { context.JSON(200,gin.H{ \"message\": \"pong\", }) }) } r.Run() } 这段代码很简单，我们只需要写一个VerifyHeader函数，在注册路由的时候添加进去就可以了，当有请求进来时，会先执行gin.HanderFunc函数，在Gin框架中使用一个切片来存储的，所以在添加中间件时，要注意添加顺序哦！ // HandlerFunc defines the handler used by gin middleware as return value. type HandlerFunc func(*Context) // HandlersChain defines a HandlerFunc array. type HandlersChain []HandlerFunc func (group *RouterGroup) combineHandlers(handlers HandlersChain) HandlersChain { finalSize := len(group.Handlers) + len(handlers) if finalSize \u003e= int(abortIndex) { panic(\"too many handlers\") } mergedHandlers := make(HandlersChain, finalSize) copy(mergedHandlers, group.Handlers) copy(mergedHandlers[len(group.Handlers):], handlers) return mergedHandlers } ","date":"2021-07-12","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%A3%85%E9%A5%B0%E5%99%A8/:4:0","tags":["编程模式"],"title":"Go语言编程模式之装饰器","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Go应用"],"content":"net/http使用装饰器 上面我们看到了装饰器在Gin框架中的应用，这种设计大大减少了冗余代码的出现，也使代码的可扩展性提高了。那么接下来我们就在标准库http包上自己实现一个装饰器，练习一下。 我们知道Go语言的http标准库是不能使用中间件的，所以我们的机会来了，我们来给他实现一个！看代码： type DecoratorHandler func(http.HandlerFunc) http.HandlerFunc func MiddlewareHandlerFunc(hp http.HandlerFunc, decors ...DecoratorHandler) http.HandlerFunc { for d := range decors { dp := decors[len(decors)-1-d] hp = dp(hp) } return hp } func VerifyHeader(h http.HandlerFunc) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { token := r.Header.Get(\"token\") if token == \"\" { fmt.Fprintf(w,r.URL.Path +\" response: Not Logged in\") return } h(w,r) } } func Pong(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w,r.URL.Path +\"response: pong\") return } func main() { http.HandleFunc(\"/api/asong/ping\",MiddlewareHandlerFunc(Pong,VerifyHeader)) err := http.ListenAndServe(\":8080\", nil) if err != nil { log.Fatal(\"ListenAndServe: \", err) } } 实现起来还是比较简单，这里重新声明了DecoratorHandler类型，本质就是func(http.HandlerFunc) http.HandlerFunc，这样更加方便我们添加中间件函数，中间件按照添加的顺序执行。 ","date":"2021-07-12","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%A3%85%E9%A5%B0%E5%99%A8/:5:0","tags":["编程模式"],"title":"Go语言编程模式之装饰器","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Go应用"],"content":"总结 好啦，本文到这里就结束了，这一文我们学习了闭包的概念，通过闭包我们学习了如何在Go语言中使用装饰器，因为Go语言中不支持注解这个语法糖，所以使用装饰器还是有点丑陋的，不过这个思想还是挺重要的，我们日常开发中可以参考这种思想，写出更优质的代码来！ 素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！我是asong，我们下期见。 创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：关注公众号获取。更多学习资料请到公众号领取。 推荐往期文章： 学习channel设计：从入门到放弃 Go语言如何实现可重入锁？ Go语言中new和make你使用哪个来分配内存？ 源码剖析panic与recover，看不懂你打我好了！ 空结构体引发的大型打脸现场 面试官：你能聊聊string和[]byte的转换吗？ 面试官：两个nil比较结果是什么？ 面试官：你能用Go写段代码判断当前系统的存储方式吗? 面试中如果这样写二分查找 ","date":"2021-07-12","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%A3%85%E9%A5%B0%E5%99%A8/:6:0","tags":["编程模式"],"title":"Go语言编程模式之装饰器","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Go源码"],"content":"前言 哈喽，大家好，我是asong。终于回归了，停更了两周了，这两周一直在搞留言号的事，经过漫长的等待，终于搞定了。兄弟们，以后就可以在留言区尽情开喷了，只要你敢喷，我就敢精选🐶。(因为发生了账号迁移，需点击右上角重新添加星标，优质文章第一时间获取！) 今天给大家带来的是Go语言中的channel。Go语言从出世以来就以高并发著称，得益于其Goroutine的设计，Goroutine也就是一个可执行的轻量级协程，有了Goroutine我们可以轻松的运行协程，但这并不能满足我们的需求，我们往往还希望多个线程/协程是能够通信的，Go语言为了支持多个Goroutine通信，设计了channel，本文我们就一起从GO1.15的源码出发，看看channel到底是如何设计的。 好啦，开往幼儿园的列车就要开了，朋友们系好安全带，我要开车啦🐶 ","date":"2021-06-28","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:1:0","tags":["标准库"],"title":"Go语言源码剖析channel的设计与实现","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["Go源码"],"content":"什么是channel 通过开头的介绍我们可以知道channel是用于goroutine的数据通信，在Go中通过goroutine+channel的方式，可以简单、高效地解决并发问题。我们先来看一下简单的示例： func GoroutineOne(ch chan \u003c-string) { fmt.Println(\"GoroutineOne running\") ch \u003c- \"asong真帅\" fmt.Println(\"GoroutineOne end of the run\") } func GoroutineTwo(ch \u003c- chan string) { fmt.Println(\"GoroutineTwo running\") fmt.Printf(\"女朋友说：%s\\n\",\u003c-ch) fmt.Println(\"GoroutineTwo end of the run\") } func main() { ch := make(chan string) go GoroutineOne(ch) go GoroutineTwo(ch) time.Sleep(3 * time.Second) } // 运行结果 // GoroutineOne running // GoroutineTwo running // 女朋友说：asong真帅 // GoroutineTwo end of the run // GoroutineOne end of the run 这里我们运行了两个Goroutine，在GoroutineOne中我们向channel中写入数据，在GoroutineTwo中我们监听channel，直到读取到\"asong真帅\"。我们可以画一个简单的图来表明一下这个顺序： 上面的例子是对无缓冲channel的一个简单应用，其实channel的使用语法还是挺多的，下面且听我慢慢道来，毕竟是从入门到放弃嘛，那就先从入门开始。 ","date":"2021-06-28","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:2:0","tags":["标准库"],"title":"Go语言源码剖析channel的设计与实现","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["Go源码"],"content":"入门channel ","date":"2021-06-28","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:3:0","tags":["标准库"],"title":"Go语言源码剖析channel的设计与实现","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["Go源码"],"content":"channel类型 channel有三种类型的定义，分别是：chan、chan \u003c-、\u003c- chan，可选的\u003c-代表channel的方向，如果我们没有指定方向，那么channel就是双向的，既可以接收数据，也可以发送数据。 chan T // 接收和发送类型为T的数据 chan\u003c- T // 只可以用来发送 T 类型的数据 \u003c- chan T // 只可以用来接收 T 类型的数据 ","date":"2021-06-28","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:3:1","tags":["标准库"],"title":"Go语言源码剖析channel的设计与实现","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["Go源码"],"content":"创建channel 我们可以使用make初始化channel，可以创建两种两种类型的channel：无缓冲的channel和有缓冲的channel。 示例： ch_no_buffer := make(chan int) ch_no_buffer := make(chan int, 0) ch_buffer := make(chan int, 100) 没有设置容量或者容量设置为0，则说明channel没有缓存，此时只有发送方和接收方都准备好后他们才可以进行通讯，否则就是一直阻塞。如果容量设置大于0，那就是一个带缓冲的channel，发送方只有buffer满了之后才会阻塞，接收方只有缓存空了才会阻塞。 注意：未初始化（为nil）的channel是不可以通信的 func main() { var ch chan string ch \u003c- \"asong真帅\" fmt.Println(\u003c- ch) } // 运行报错 fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan send (nil chan)]: ","date":"2021-06-28","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:3:2","tags":["标准库"],"title":"Go语言源码剖析channel的设计与实现","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["Go源码"],"content":"channel入队 channel的入队定义如下： \"channel\" \u003c- \"要入队的值（可以是表达式）\" 在无缓冲的channel中，只有在出队方准备好后，channel才会入队，否则一直阻塞着，所以说无缓冲channel是同步的。 在有缓冲的channel中，缓存未满时，就会执行入队操作。 向nil的channel中入队会一直阻塞，导致死锁。 ","date":"2021-06-28","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:3:3","tags":["标准库"],"title":"Go语言源码剖析channel的设计与实现","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["Go源码"],"content":"channel单个出队 channel的单个出队定义如下： \u003c- \"channel\" 无论是有无缓冲的channel在接收不到数据时都会阻塞，直到有数据可以接收。 从nil的channel中接收数据会一直阻塞。 channel的出队还有一种非阻塞写法，定义如下： val, ok := \u003c-ch 这么写可以判断当前channel是否关闭，如果这个channel被关闭了，ok会被设置为false，val就是零值。 ","date":"2021-06-28","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:3:4","tags":["标准库"],"title":"Go语言源码剖析channel的设计与实现","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["Go源码"],"content":"channel循环出队 我们可以使用for-range循环处理channel。 func main() { ch := make(chan int,10) go func() { for i:=0;i\u003c10;i++{ ch \u003c- i } close(ch) }() for val := range ch{ fmt.Println(val) } fmt.Println(\"over\") } range ch会一直迭代到channel被关闭。在使用有缓冲channel时，配合for-range是一个不错的选择。 ","date":"2021-06-28","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:3:5","tags":["标准库"],"title":"Go语言源码剖析channel的设计与实现","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["Go源码"],"content":"配合select使用 Go语言中的select能够让Goroutine同时等待多个channel读或者写，在channel状态未改变之前，select会一直阻塞当前线程或Goroutine。先看一个例子： func fibonacci(ch chan int, done chan struct{}) { x, y := 0, 1 for { select { case ch \u003c- x: x, y = y, x+y case \u003c-done: fmt.Println(\"over\") return } } } func main() { ch := make(chan int) done := make(chan struct{}) go func() { for i := 0; i \u003c 10; i++ { fmt.Println(\u003c-ch) } done \u003c- struct{}{} }() fibonacci(ch, done) } select与switch具有相似的控制结构，与switch不同的是，select中的case中的表达式必须是channel的收发操作，当select中的两个case同时被触发时，会随机执行其中的一个。为什么是随机执行的呢？随机的引入就是为了避免饥饿问题的发生，如果我们每次都是按照顺序依次执行的，若两个case一直都是满足条件的，那么后面的case永远都不会执行。 上面例子中的select用法是阻塞式的收发操作，直到有一个channel发生状态改变。我们也可以在select中使用default语句，那么select语句在执行时会遇到这两种情况： 当存在可以收发的Channel时，直接处理该 Channel 对应的 case； 当不存在可以收发的 Channel 时，执行 default 中的语句； 注意：nil channel上的操作会一直被阻塞，如果没有default case,只有nil channel的select会一直被阻塞。 ","date":"2021-06-28","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:3:6","tags":["标准库"],"title":"Go语言源码剖析channel的设计与实现","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["Go源码"],"content":"关闭channel 内建的close方法可以用来关闭channel。如果channel已经关闭，不可以继续发送数据了，否则会发生panic，但是从这个关闭的channel中不但可以读取出已发送的数据，还可以不断的读取零值。 func main() { ch := make(chan int, 10) ch \u003c- 10 ch \u003c- 20 close(ch) fmt.Println(\u003c-ch) //1 fmt.Println(\u003c-ch) //2 fmt.Println(\u003c-ch) //0 fmt.Println(\u003c-ch) //0 } ","date":"2021-06-28","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:3:7","tags":["标准库"],"title":"Go语言源码剖析channel的设计与实现","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["Go源码"],"content":"channel基本设计思想 channel设计的基本思想是：不要通过共享内存来通信，而是通过通信来实现共享内存（Do not communicate by sharing memory; instead, share memory by communicating）。 这个思想大家是否理解呢？我在这里分享一下我的理解(查找资料+个人理解)，有什么不对的，留言区指正或开喷！ 什么是使用共享内存来通信？其实就是多个线程/协程使用同一块内存，通过加锁的方式来宣布使用某块内存，通过解锁来宣布不再使用某块内存。 什么是通过通信来实现共享内存？其实就是把一份内存的开销变成两份内存开销而已，再说的通俗一点就是，我们使用发送消息的方式来同步信息。 为什么鼓励使用通过通信来实现共享内存？使用发送消息来同步信息相比于直接使用共享内存和互斥锁是一种更高级的抽象，使用更高级的抽象能够为我们在程序设计上提供更好的封装，让程序的逻辑更加清晰；其次，消息发送在解耦方面与共享内存相比也有一定优势，我们可以将线程的职责分成生产者和消费者，并通过消息传递的方式将它们解耦，不需要再依赖共享内存。 对于这个理解更深的文章，建议读一下这篇文章：为什么使用通信来共享内存 channel在设计上本质就是一个有锁的环形队列，包括发送方队列、接收方队列、互斥锁等结构，下面我就一起从源码出发，剖析这个有锁的环形队列是怎么设计的！ ","date":"2021-06-28","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:4:0","tags":["标准库"],"title":"Go语言源码剖析channel的设计与实现","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["Go源码"],"content":"源码剖析 ","date":"2021-06-28","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:5:0","tags":["标准库"],"title":"Go语言源码剖析channel的设计与实现","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["Go源码"],"content":"数据结构 在src/runtime/chan.go中我们可以看到hchan的结构如下： type hchan struct { qcount uint // total data in the queue dataqsiz uint // size of the circular queue buf unsafe.Pointer // points to an array of dataqsiz elements elemsize uint16 closed uint32 elemtype *_type // element type sendx uint // send index recvx uint // receive index recvq waitq // list of recv waiters sendq waitq // list of send waiters lock mutex } 我们来解释一下hchan中每个字段都是什么意思： qcount：循环数组中的元素数量 dataqsiz：循环数组的长度 buf：只针对有缓冲的channel，指向底层循环数组的指针 elemsize：能够接收和发送的元素大小 closed：channel是否关闭标志 elemtype：记录channel中元素的类型 sendx：已发送元素在循环数组中的索引 sendx：已接收元素在循环数组中的索引 recvq：等待接收的goroutine队列 senq：等待发送的goroutine队列 lock：互斥锁，保护hchan中的字段，保证读写channel的操作都是原子的。 这个结构结合上面那个图理解就更清晰了： buf是指向底层的循环数组，dataqsiz就是这个循环数组的长度，qcount就是当前循环数组中的元素数量，缓冲的channel才有效。 elemsize和elemtype就是我们创建channel时设置的容量大小和元素类型。 sendq、recvq是一个双向链表结构，分别表示被阻塞的goroutine链表，这些 goroutine 由于尝试读取 channel 或向 channel 发送数据而被阻塞。 对于上面的描述，我们可以画出来这样的一个理解图： ","date":"2021-06-28","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:5:1","tags":["标准库"],"title":"Go语言源码剖析channel的设计与实现","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["Go源码"],"content":"channel的创建 前面介绍channel入门的时候我们就说到了，我们使用make进行创建，make在经过编译器编译后对应的runtime.makechan或runtime.makechan64。为什么会有这个区别呢？先看一下代码： // go 1.15.7 func makechan64(t *chantype, size int64) *hchan { if int64(int(size)) != size { panic(plainError(\"makechan: size out of range\")) } return makechan(t, int(size)) } runtime.makechan64本质也是调用的makechan方法，只不过多了一个数值溢出的校验。runtime.makechan64是用于处理缓冲区大于2的32方，所以这两个方法会根据传入的参数类型和缓冲区大小进行选择。大多数情况都是使用makechan。我们只需要分析makechan函数就可以了。 func makechan(t *chantype, size int) *hchan { elem := t.elem // 对发送元素进行限制 1\u003c\u003c16 = 65536 if elem.size \u003e= 1\u003c\u003c16 { throw(\"makechan: invalid channel element type\") } // 检查是否对齐 if hchanSize%maxAlign != 0 || elem.align \u003e maxAlign { throw(\"makechan: bad alignment\") } // 判断是否会发生内存溢出 mem, overflow := math.MulUintptr(elem.size, uintptr(size)) if overflow || mem \u003e maxAlloc-hchanSize || size \u003c 0 { panic(plainError(\"makechan: size out of range\")) } // 构造hchan对象 var c *hchan switch { // 说明是无缓冲的channel case mem == 0: // Queue or element size is zero. c = (*hchan)(mallocgc(hchanSize, nil, true)) // Race detector uses this location for synchronization. c.buf = c.raceaddr() // 元素类型不包含指针，只进行一次内存分配 // 如果hchan结构体中不含指针，gc就不会扫描chan中的元素，所以我们只需要分配 // \"hchan 结构体大小 + 元素大小*个数\" 的内存 case elem.ptrdata == 0: // Allocate hchan and buf in one call. c = (*hchan)(mallocgc(hchanSize+mem, nil, true)) c.buf = add(unsafe.Pointer(c), hchanSize) // 元素包含指针，进行两次内存分配操作 default: c = new(hchan) c.buf = mallocgc(mem, elem, true) } // 初始化hchan中的对象 c.elemsize = uint16(elem.size) c.elemtype = elem c.dataqsiz = uint(size) lockInit(\u0026c.lock, lockRankHchan) if debugChan { print(\"makechan: chan=\", c, \"; elemsize=\", elem.size, \"; dataqsiz=\", size, \"\\n\") } return c } 注释我都添加上了，应该很容易懂吧，这里在特殊说一下分配内存这块的内容，其实归一下类，就只有两块： 分配一次内存：若创建的channel是无缓冲的，或者创建的有缓冲的channel中存储的类型不存在指针引用，就会调用一次mallocgc分配一段连续的内存空间。 分配两次内存：若创建的有缓冲channel存储的类型存在指针引用，就会连同hchan和底层数组同时分配一段连续的内存空间。 因为都是调用mallocgc方法进行内存分配，所以channel都是在堆上创建的，会进行垃圾回收，不关闭close方法也是没有问题的（但是想写出漂亮的代码就不建议你这么做了）。 ","date":"2021-06-28","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:5:2","tags":["标准库"],"title":"Go语言源码剖析channel的设计与实现","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["Go源码"],"content":"channel入队 channel发送数据部分的代码经过编译器编译后对应的是runtime.chansend1，其调用的也是runtime.chansend方法： func chansend1(c *hchan, elem unsafe.Pointer) { chansend(c, elem, true, getcallerpc()) } 我们主要分析一下chansend方法，代码有点长，我们分几个步骤来看这段代码： 前置检查 加锁/异常检查 channel直接发送数据 channel发送数据缓冲区有可用空间 channel发送数据缓冲区无可用空间 前置检查 if c == nil { if !block { return false } gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2) throw(\"unreachable\") } if debugChan { print(\"chansend: chan=\", c, \"\\n\") } if raceenabled { racereadpc(c.raceaddr(), callerpc, funcPC(chansend)) } if !block \u0026\u0026 c.closed == 0 \u0026\u0026 full(c) { return false } var t0 int64 if blockprofilerate \u003e 0 { t0 = cputicks() } 这里最主要的检查就是判断当前channel是否为nil，往一个nil的channel中发送数据时，会调用gopark函数将当前执行的goroutine从running状态转入waiting状态，这让就会导致进程出现死锁，表象出panic事件。 紧接着会对非阻塞的channel进行一个上限判断，看看是否快速失败，这里相对于之前的版本做了改进，使用full方法来对hchan结构进行校验。 func full(c *hchan) bool { if c.dataqsiz == 0 { return c.recvq.first == nil } return c.qcount == c.dataqsiz } 这里快速失败校验逻辑如下： 若是 qcount 与 dataqsiz 大小相同（缓冲区已满）时，则会返回失败。 非阻塞且未关闭，同时底层数据 dataqsiz 大小为 0（无缓冲channel），如果接收方没准备好则直接返回失败。 加锁/异常检查 lock(\u0026c.lock) if c.closed != 0 { unlock(\u0026c.lock) panic(plainError(\"send on closed channel\")) } 前置校验通过后，在发送数据的逻辑执行之前会先为当前的channel加锁，防止多个协程并发修改数据。如果 Channel 已经关闭，那么向该 Channel 发送数据时会报“send on closed channel”错误并中止程序。 channel直接发送数据 直接发送数据是指 如果已经有阻塞的接收goroutines（即recvq中指向非空），那么数据将被直接发送给接收goroutine。 if sg := c.recvq.dequeue(); sg != nil { //找到一个等待的接收器。我们将想要发送的值直接传递给接收者，绕过通道缓冲区(如果有的话)。 send(c, sg, ep, func() { unlock(\u0026c.lock) }, 3) return true } 这里主要是调用Send方法，我们来看一下这个函数： func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) { // 静态竞争省略掉 // elem是指接收到的值存放的位置 if sg.elem != nil { // 调用sendDirect方法直接进行内存拷贝 // 从发送者拷贝到接收者 sendDirect(c.elemtype, sg, ep) sg.elem = nil } // 绑定goroutine gp := sg.g // 解锁 unlockf() gp.param = unsafe.Pointer(sg) if sg.releasetime != 0 { sg.releasetime = cputicks() } // 唤醒接收的 goroutine goready(gp, skip+1) } 我们再来看一下SendDirect方法： func sendDirect(t *_type, sg *sudog, src unsafe.Pointer) { dst := sg.elem typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size) memmove(dst, src, t.size) } 这里调用了memove方法进行内存拷贝，这里是从一个 goroutine 直接写另一个 goroutine 栈的操作，这样做的好处是减少了一次内存 copy：不用先拷贝到 channel 的 buf，直接由发送者到接收者，没有中间商赚差价，效率得以提高，完美。 channel发送数据缓冲区有可用空间 接着往下看代码，判断channel缓冲区是否还有可用空间： // 判断通道缓冲区是否还有可用空间 if c.qcount \u003c c.dataqsiz { qp := chanbuf(c, c.sendx) if raceenabled { raceacquire(qp) racerelease(qp) } typedmemmove(c.elemtype, qp, ep) // 指向下一个待发送元素在循环数组中的位置 c.sendx++ // 因为存储数据元素的结构是循环队列，所以当当前索引号已经到队末时，将索引号调整到队头 if c.sendx == c.dataqsiz { c.sendx = 0 } // 当前循环队列中存储元素数+1 c.qcount++ // 释放锁，发送数据完毕 unlock(\u0026c.lock) return true } 这里的几个步骤还是挺好理解的，注释已经添加到代码中了，我们再来详细解析一下： 如果当前缓冲区还有可用空间，则调用chanbuf方法获取底层缓冲数组中sendx索引的元素指针值 调用typedmemmove方法将发送的值拷贝到缓冲区中 数据拷贝成功，sendx进行+1操作，指向下一个待发送元素在循环数组中的位置。如果下一个索引位置正好是循环队列的长度，那么就需要把所谓位置归0，因为这是一个循环环形队列。 发送数据成功后，队列元素长度自增，至此发送数据完毕，释放锁，返回结果即可。 channel发送数据缓冲区无可用空间 缓冲区空间也会有满了的时候，这是有两种方式可以选择，一种是直接返回，另外一种是阻塞等待。 直接返回的代码就很简单了，做一个简单的是否阻塞判断，不阻塞的话，直接释放锁，返回即可。 if !block { unlock(\u0026c.lock) return false } 阻塞的话代码稍微长一点，我们来分析一下： gp := getg() mysg := acquireSudog() mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } mysg.elem = ep mysg.waitlink = nil mysg.g = gp mysg.isSelect = false mysg.c = c gp.waiting = mysg gp.param = nil c.sendq.enqueue(mysg) atomic.Store8(\u0026gp.parkingOnChan, 1) gopark(chanparkcommit, unsafe.Pointer(\u0026c.lock), waitReasonChanSend, traceEvGoBlockSend, 2) KeepAlive(ep) 首先通过调用gettg获取当前执行的goroutine，然后调用acquireSudog方法构造sudog结构体，然后设置待发送信息和goroutine等信息（sudog 通过 g 字段绑定 goroutine，而 goroutine 通过waiting绑定 sudog，sudog 还通过 elem 字段绑定待发送元素的地址）；构造完毕后调用c.sendq.enqueue将其放入待发送的等待队列，最后调用gopark方法挂起当前的goroutine进入wait状态。 这里在最后调用了KeepAlive方法，很多人对这个比较懵逼，我来解释一下。这个方法就是为了保证待发送的数据处于活跃状态，也就是分配在堆上避免被GC。这里我在画一个图解释一下上面的绑定过程，更加深理解。 现在goroutine处于wait状态了，等待被唤醒，唤醒代码如下： if mysg != gp.waiting { throw(\"G waiting list is corrupted\") } gp.waiting = nil gp.activeStackChans = false if gp.param == nil { if c.closed == 0 { throw(\"chansend: spurious wakeup\") } // 唤醒后channel被关闭了，直接pan","date":"2021-06-28","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:5:3","tags":["标准库"],"title":"Go语言源码剖析channel的设计与实现","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["Go源码"],"content":"接收数据 之前我们介绍过channel接收数据有两种方式，如下： val := \u003c- ch val, ok := \u003c- ch 它们在经过编译器编译后分别对应的是runtime.chanrecv1 和 runtime.chanrecv2： //go:nosplit func chanrecv1(c *hchan, elem unsafe.Pointer) { chanrecv(c, elem, true) } //go:nosplit func chanrecv2(c *hchan, elem unsafe.Pointer) (received bool) { _, received = chanrecv(c, elem, true) return } 其实都是调用chanrecv方法，所以我们只需要解析这个方法就可以了。接收部分的代码和接收部分的代码是相对应的，所以我们也可以分几个步骤来看这部分代码： 前置检查 加锁和提前返回 channel直接接收数据 channel缓冲区有数据 channel缓冲区无数据 前置检查 if c == nil { if !block { return } gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2) throw(\"unreachable\") } if atomic.Load(\u0026c.closed) == 0 { return } if empty(c) { if raceenabled { raceacquire(c.raceaddr()) } if ep != nil { typedmemclr(c.elemtype, ep) } return true, false } } var t0 int64 if blockprofilerate \u003e 0 { t0 = cputicks() } 首先也会判断当前channel是否为nil channel，如果是nil channel且为非阻塞接收，则直接返回即可。如果是nil channel且为阻塞接收，则直接调用gopark方法挂起当前goroutine。 然后也会进行快速失败检查，这里只会对非阻塞接收的channel进行快速失败检查，检查规则如下： func empty(c *hchan) bool { // c.dataqsiz is immutable. if c.dataqsiz == 0 { return atomic.Loadp(unsafe.Pointer(\u0026c.sendq.first)) == nil } return atomic.Loaduint(\u0026c.qcount) == 0 } 当循环队列为 0且等待队列 sendq 内没有 goroutine 正在等待或者缓冲区数组为空时，如果channel还未关闭，这说明没有要接收的数据，直接返回即可。如果channel已经关闭了且缓存区没有数据了，则会清理ep指针中的数据并返回。这里为什么清理ep指针呢？ep指针是什么？这个ep就是我们要接收的值存放的地址（val := \u003c-ch val就是ep ），即使channel关闭了，我们也可以接收零值。 加锁和提前返回 lock(\u0026c.lock) if c.closed != 0 \u0026\u0026 c.qcount == 0 { if raceenabled { raceacquire(c.raceaddr()) } unlock(\u0026c.lock) if ep != nil { typedmemclr(c.elemtype, ep) } return true, false } 前置校验通过后，在执行接收数据的逻辑之前会先为当前的channel加锁，防止多个协程并发接收数据。同样也会判断当前channel是否被关闭，如果channel被关闭了，并且缓存区没有数据了，则直接释放锁和清理ep中的指针数据，不需要再走接下来的流程。 channel直接接收数据 这一步与channel直接发送数据是对应的，当发现channel上有正在阻塞等待的发送方时，则直接进行接收。 if sg := c.sendq.dequeue(); sg != nil { recv(c, sg, ep, func() { unlock(\u0026c.lock) }, 3) return true, true } 等待发送队列里有goroutine存在，有两种可能： 非缓冲的channel 缓冲的channel，但是缓冲区满了 针对这两种情况，在recv方法中的执行逻辑是不同的： func recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) { // 非缓冲channel if c.dataqsiz == 0 { // 未忽略接收值 if ep != nil { // 直接从发送方拷贝数据到接收方 recvDirect(c.elemtype, sg, ep) } } else { // 有缓冲channel，但是缓冲区满了 // 缓冲区满时，接收方和发送方游标重合了 // 因为是循环队列，都是游标0的位置 // 获取当前接收方游标位置下的值 qp := chanbuf(c, c.recvx) // 未忽略值的情况下直接从发送方拷贝数据到接收方 if ep != nil { typedmemmove(c.elemtype, ep, qp) } // 将发送者数据拷贝到缓冲区中 typedmemmove(c.elemtype, qp, sg.elem) // 自增到下一个待接收位置 c.recvx++ // 如果下一个待接收位置等于队列长度了，则下一个待接收位置为队头，因为是循环队列 if c.recvx == c.dataqsiz { c.recvx = 0 } // 上面已经将发送者数据拷贝到缓冲区中了，所以缓冲区还是满的，所以发送方位置仍然等于接收方位置。 c.sendx = c.recvx // c.sendx = (c.sendx+1) % c.dataqsiz } sg.elem = nil // 绑定发送方goroutine gp := sg.g unlockf() gp.param = unsafe.Pointer(sg) if sg.releasetime != 0 { sg.releasetime = cputicks() } // 唤醒发送方的goroutine goready(gp, skip+1) } 代码中的注释已经很清楚了，但还是想在解释一遍，这里主要就是分为两种情况： 非缓冲区channel：未忽略接收值时直接调用recvDirect方法直接从发送方的goroutine调用栈中将数据拷贝到接收方的goroutine。 带缓冲区的channel：首先调用chanbuf方法根据recv索引的位置读取缓冲区元素，并将其拷贝到接收方的内存地址；拷贝完毕后调整sendx和recvx索引位置。 最后别忘了还有一个操作就是调用goready方法唤醒发送方的goroutine可以继续发送数据了。 channel缓冲区有数据 我们接着往下看代码，若当前channel的缓冲区有数据时，代码逻辑如下： // 缓冲channel，buf里有可用元素，发送方也可以正常发送 if c.qcount \u003e 0 { // 直接从循环队列中找到要接收的元素 qp := chanbuf(c, c.recvx) // 未忽略接收值，直接把缓冲区的值拷贝到接收方中 if ep != nil { typedmemmove(c.elemtype, ep, qp) } // 清理掉循环数组里相应位置的值 typedmemclr(c.elemtype, qp) // 接收游标向前移动 c.recvx++ // 超过循环队列的长度时，接收游标归0（循环队列） if c.recvx == c.dataqsiz { c.recvx = 0 } // 循环队列中的数据数量减1 c.qcount-- // 接收数据完毕，释放锁 unlock(\u0026c.lock) return true, true } if !block { unlock(\u0026c.lock) return false, false } 这段代码没什么难度，就不再解释一遍了。 channel缓冲区无数据 经过上面的步骤，现在可以确定目前这个channel既没有待发送的goroutine，并且缓冲区也没有数据。接下来就看我们是否阻塞等待接收数据了，也就有了如下判断： if !block { unlock(\u0026c.lock) return false, false } 非阻塞接收数据的话，直接返回即可；否则则进入阻塞接收模式： gp := getg() mysg := acquireSudog() mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } mysg.elem = ep mysg.waitlink = nil gp.waiting = mysg mysg.g = gp mysg.isSelect = false mysg.c = c gp.param = nil c.recvq.enqueue(mysg) atomic.Store8(\u0026gp.parkingOnChan, 1) gopark(chanparkcommit, unsafe.Pointer(\u0026c","date":"2021-06-28","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:5:4","tags":["标准库"],"title":"Go语言源码剖析channel的设计与实现","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["Go源码"],"content":"关闭channel 使用close可以关闭channel，其经过编译器编译后对应的是runtime.closechan方法，详细逻辑我们通过注释到代码中： func closechan(c *hchan) { // 对一个nil的channel进行关闭会引发panic if c == nil { panic(plainError(\"close of nil channel\")) } // 加锁 lock(\u0026c.lock) // 关闭一个已经关闭的channel也会引发channel if c.closed != 0 { unlock(\u0026c.lock) panic(plainError(\"close of closed channel\")) } // 关闭channnel标志 c.closed = 1 // Goroutine集合 var glist gList // 接受者的 sudog 等待队列（recvq）加入到待清除队列 glist 中 for { sg := c.recvq.dequeue() if sg == nil { break } if sg.elem != nil { typedmemclr(c.elemtype, sg.elem) sg.elem = nil } if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g gp.param = nil if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) } // 发送方的sudog也加入到到待清除队列 glist 中 for { sg := c.sendq.dequeue() if sg == nil { break } // 要关闭的goroutine，发送的值设为nil sg.elem = nil if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g gp.param = nil if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) } // 释放了发送方和接收方后，释放锁就可以了。 unlock(\u0026c.lock) // 将所有 glist 中的 goroutine 状态从 _Gwaiting 设置为 _Grunnable 状态，等待调度器的调度。 // 我们既然是从sendq和recvq中获取的goroutine，状态都是挂起状态，所以需要唤醒他们，走后面的流程。 for !glist.empty() { gp := glist.pop() gp.schedlink = 0 goready(gp, 3) } } 这里逻辑还是比较简单，归纳总结一下： 一个为nil的channel不允许进行关闭 不可以重复关闭channel 获取当前正在阻塞的发送或者接收的goroutine，他们都处于挂起状态，然后进行唤醒。这是发送方不允许在向channel发送数据了，但是不影响接收方继续接收元素，如果没有元素，获取到的元素是零值。使用val,ok := \u003c-ch可以判断当前channel是否被关闭。 ","date":"2021-06-28","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:6:0","tags":["标准库"],"title":"Go语言源码剖析channel的设计与实现","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["Go源码"],"content":"总结 哇塞，开往幼儿园的车终于停了，小松子唠唠叨叨一路了，你们学会了吗？ 我们从入门开始到最后的源码剖析，其实channel的设计一点也不复杂，源码也是很容易看懂的，本质就是维护了一个循环队列嘛，发送数据遵循FIFO（First In First Out）原语，数据传递依赖于内存拷贝。不懂的可以再看一遍，很容易理解的哦～。 最后我想说的是：channel内部也是使用互斥锁，那么channel和互斥锁谁更轻量呢？（评论区我们一起探讨一下）。 素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！我是asong，我们下期见。 创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：关注公众号获取。更多学习资料请到公众号领取。 推荐往期文章： Go语言如何实现可重入锁？ Go语言中new和make你使用哪个来分配内存？ 源码剖析panic与recover，看不懂你打我好了！ 空结构体引发的大型打脸现场 Leaf—Segment分布式ID生成系统（Golang实现版本） 面试官：两个nil比较结果是什么？ 面试官：你能用Go写段代码判断当前系统的存储方式吗? 面试中如果这样写二分查找 ","date":"2021-06-28","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:7:0","tags":["标准库"],"title":"Go语言源码剖析channel的设计与实现","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90channel%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["Go源码"],"content":"前言 哈喽，大家好，我是asong。今天与大家分享一下Go标准库sort.Search是如何实现二分查找的，为什么突然想到分享这个函数呢。起因是这周在刷leetcode的一道题时，需要使用到二分查找，最开始是自己实现了一版，后面就想Go语言标准库这么全，应该会有这个封装，果然被我找到了，顺便看了一下他是怎么实现的，感觉挺有意思的，就赶紧来分享一下。 小声逼逼一下，最近有读者反馈说最近发文不够频繁，在这里同步一下我最近干什么： 工作太忙了 正在写一个本地缓存，后面会分享出来 正在筹备我的第一个开源项目，敬请期待 ","date":"2021-06-15","objectID":"https://asong2020.github.io/go%E6%A0%87%E5%87%86%E5%BA%93%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84/:1:0","tags":["标准库"],"title":"Go标准库是如何实现二分查找的","uri":"https://asong2020.github.io/go%E6%A0%87%E5%87%86%E5%BA%93%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84/"},{"categories":["Go源码"],"content":"什么是二分查找 以下来自百度百科： 二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。 总结一下，使用二分查找必须要符合两个要求： 必须采用顺序存储结构 必须按关键字大小有序排列 我们来举个例子，就很容易理解了，就拿我和我女朋友的聊天内容做个例子吧： 我家宝宝每次买一件新衣服，就会习惯性的问我一句，小松子，来猜一猜我这次花了多少钱？ 小松子：50？ 臭宝：你埋汰我呢？欠打！ 小松子：500？ 臭宝：你当我是富婆呢？能不能有点智商！ 小松子：250？ 臭宝：我感觉你在骂我，可我还没有证据。少啦，少啦！！！ 小松子：哎呀，好难猜呀，290？ 臭宝：啊！你这臭男人，就是在骂我！气死啦，气死啦！多啦，多啦！ 小松子：难道是260？ 臭宝：哎呦，挺厉害呀，竟然猜对了！ 后面对话内容就省略啦….. 这里我只需要5次就成功猜出来了，这就是二分查找的思想，每一次猜测，我们都选取一段整数范围的中位数，根据条件帮我们逐步缩小范围，每一次都以让剩下的选择范围缩小一半，效率提高。 二分查找的时间复杂度 二分查找每次把搜索区域减少一半，时间复杂度为O(logn)。（n代表集合中元素的个数）。 空间复杂度为O(1)。 ","date":"2021-06-15","objectID":"https://asong2020.github.io/go%E6%A0%87%E5%87%86%E5%BA%93%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84/:2:0","tags":["标准库"],"title":"Go标准库是如何实现二分查找的","uri":"https://asong2020.github.io/go%E6%A0%87%E5%87%86%E5%BA%93%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84/"},{"categories":["Go源码"],"content":"自己实现一个二分查找 二分算法的实现还是比较简单的，可以分两种方式实现：递归和非递归方式实现，示例代码如下： 非递归方式实现： // 二分查找非递归实现 func binarySearch(target int64, nums []int64) int { left := 0 right := len(nums) for left \u003c= right { mid := left + (right - left) / 2 if target == nums[mid] { return mid } if target \u003e nums[mid] { left = mid + 1 continue } if target \u003c nums[mid] { right = mid - 1 continue } } return -1 } 总体思路很简单，每次我们都选取一段整数范围的中位数，然后根据条件让剩下的选择范围缩小一半。这里有一个要注意的点就是我们在获取中位数时使用的写法是 mid := left + (right - left) / 2，而不是mid = （left +right）/2的写法，这是因为后者有可能会造成位数的溢出，也就会导致结果出问题。 递归方式实现： func Search(nums []int64, target int64) int { return binarySearchRecursive(target, nums, 0, len(nums)) } func binarySearchRecursive(target int64, nums []int64, left, right int) int { if left \u003e right { return -1 } mid := left + (right - left) / 2 if target == nums[mid] { return mid } if nums[mid] \u003c target { return binarySearchRecursive(target, nums, mid+1, right) } if nums[mid] \u003e target { return binarySearchRecursive(target, nums, left, mid-1) } return -1 } ","date":"2021-06-15","objectID":"https://asong2020.github.io/go%E6%A0%87%E5%87%86%E5%BA%93%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84/:3:0","tags":["标准库"],"title":"Go标准库是如何实现二分查找的","uri":"https://asong2020.github.io/go%E6%A0%87%E5%87%86%E5%BA%93%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84/"},{"categories":["Go源码"],"content":"Go标准库是如何实现二分查找的？ 我们先看一下标准库中的代码实现： func Search(n int, f func(int) bool) int { // Define f(-1) == false and f(n) == true. // Invariant: f(i-1) == false, f(j) == true. i, j := 0, n for i \u003c j { h := int(uint(i+j) \u003e\u003e 1) // avoid overflow when computing h // i ≤ h \u003c j if !f(h) { i = h + 1 // preserves f(i-1) == false } else { j = h // preserves f(j) == true } } // i == j, f(i-1) == false, and f(j) (= f(i)) == true =\u003e answer is i. return i } 初一看，与我们上面的实现一点也不同呢，我们来分析一下。 入参n就是代表要查找序列的长度，入参f就是我们自定义的条件。这段代码很短，大概思路就是： 定义好这段序列的开始、结尾的位置 使用位移操作获取中位数，这样能更好的避免溢出 然后根据我们传入的条件判断是否符合条件，逐渐缩小范围 这段代码与我实现的不同在于，它并不是在用户传入的比较函数f返回true就结束查找，而是继续在当前[i, j)区间的前半段查找，并且，当f为false时，也不比较当前元素与要查找的元素的大小关系，而是直接在后半段查找。所以for循环退出的唯一条件就是i\u003e=j，如果我们这样使用，就会出现问题： func main() { nums := []int64{1, 2, 3, 4, 5, 6, 7} fmt.Println(sort.Search(len(nums), func(i int) bool{ return nums[i] == 1 })) } 运行结果竟然是7，而不是1，如果我们把条件改成return nums[i] \u003e=1，运行结果就对了。这是因为我们传入的条件并不是让用户确认目标条件，这里的思想是让我们逐步缩小范围，通过这个条件，我们每次都可以缩小范围，说的有点饶，就上面的代码举个例子。现在是一个升序数组，我们要找的数值是1，我们传入的条件是return nums[i]\u003e=1，第一进入函数Search，我们获取中的中位数h是3，当前元素是大于目标数值的，所以我们只能在前半段查找，就是这样不断缩小范围，找到我们最终的那个数值，如果当前序列中没有我们要找的目标数值，那么就会返回我们可以插入的位置，也就是最后一位元素的坐标+1的位置。 这个逻辑说实话，我也是第一次接触，仔细思考了一下，这种实现还是有一些优点的： 使用移位操作，避免因为i+j太大而造成的溢出 如果我们查找序列中有多个元素相等时，且我们要找的元素就是这个时，我们总会找到下标最小的那个元素 如果我们没找到要找的目标元素时，返回的下标是我们可插入的位置，我们在进行数据插入时，依然可以保证数据的有序 注意：使用sort.Search时，入参条件是根据要查找的序列是升序序列还是降序序列来决定的，如果是升序序列，则传入的条件应该是\u003e=目标元素值，如果是降序序列，则传入的条件应该是\u003c=目标元素值 ","date":"2021-06-15","objectID":"https://asong2020.github.io/go%E6%A0%87%E5%87%86%E5%BA%93%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84/:4:0","tags":["标准库"],"title":"Go标准库是如何实现二分查找的","uri":"https://asong2020.github.io/go%E6%A0%87%E5%87%86%E5%BA%93%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84/"},{"categories":["Go源码"],"content":"解析int(uint(i+j) \u003e\u003e 1)这段代码 这里我想单独解析一下这段代码，因为很少见，所以可以当作一个知识点记一下。这里使用到的是移位操作，通过向右移动一位，正好可以得到/2的结果。具体什么原因呢，我画了一个图，手工画的，看完你就懂了： 懂了吧，兄弟们！移位实现要比乘除发的效率高很多，我们在平常开发中可以使用这种方式来提升效率。 这里还有一个点就是使用uint数据类型，因为uint的数据范围是2^32即0到4294967295。使用uint可以避免因为i+j太大而造成的溢出。 ","date":"2021-06-15","objectID":"https://asong2020.github.io/go%E6%A0%87%E5%87%86%E5%BA%93%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84/:4:1","tags":["标准库"],"title":"Go标准库是如何实现二分查找的","uri":"https://asong2020.github.io/go%E6%A0%87%E5%87%86%E5%BA%93%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84/"},{"categories":["Go源码"],"content":"总结 好啦，今天的文章到这里就结束了，最后我想说的是，没事大家可以专研一下Go标准库中的一些方法是怎样实现的，好的思想我们要借鉴过来。如果我们在面试中使用这种方式写出二分查找，那得到的offer的几率不就又增加了嘛～。 素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！我是asong，我们下期见。 创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：关注公众号获取。更多学习资料请到公众号领取。 推荐往期文章： Go语言如何实现可重入锁？ Go语言中new和make你使用哪个来分配内存？ 源码剖析panic与recover，看不懂你打我好了！ 空结构体引发的大型打脸现场 Leaf—Segment分布式ID生成系统（Golang实现版本） 面试官：两个nil比较结果是什么？ 面试官：你能用Go写段代码判断当前系统的存储方式吗? 如何平滑切换线上Elasticsearch索引 ","date":"2021-06-15","objectID":"https://asong2020.github.io/go%E6%A0%87%E5%87%86%E5%BA%93%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84/:5:0","tags":["标准库"],"title":"Go标准库是如何实现二分查找的","uri":"https://asong2020.github.io/go%E6%A0%87%E5%87%86%E5%BA%93%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84/"},{"categories":["Go面试"],"content":"前言 哈喽，大家好，我是asong。为什么会有今天这篇文章呢？前天在一个群里看到了一份Go语言面试的八股文，其中有一道题就是\"字符串转成byte数组，会发生内存拷贝吗？\"；这道题挺有意思的，本质就是在问你string和[]byte的转换原理，考验你的基本功底。今天我们就来好好的探讨一下两者之间的转换方式。 ","date":"2021-06-15","objectID":"https://asong2020.github.io/string%E5%92%8Cbyte%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86/:1:0","tags":["内存拷贝"],"title":"Go语言中string和[]byte的转换原理","uri":"https://asong2020.github.io/string%E5%92%8Cbyte%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"categories":["Go面试"],"content":"byte类型 我们看一下官方对byte的定义： // byte is an alias for uint8 and is equivalent to uint8 in all ways. It is // used, by convention, to distinguish byte values from 8-bit unsigned // integer values. type byte = uint8 我们可以看到byte就是uint8的别名，它是用来区分字节值和8位无符号整数值。 其实可以把byte当作一个ASCII码的一个字符。 示例： var ch byte = 65 var ch byte = '\\x41' var ch byte = 'A' ","date":"2021-06-15","objectID":"https://asong2020.github.io/string%E5%92%8Cbyte%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86/:2:0","tags":["内存拷贝"],"title":"Go语言中string和[]byte的转换原理","uri":"https://asong2020.github.io/string%E5%92%8Cbyte%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"categories":["Go面试"],"content":"[]byte类型 []byte就是一个byte类型的切片，切片本质也是一个结构体，定义如下： // src/runtime/slice.go type slice struct { array unsafe.Pointer len int cap int } 这里简单说明一下这几个字段，array代表底层数组的指针，len代表切片长度，cap代表容量。看一个简单示例： func main() { sl := make([]byte,0,2) sl = append(sl, 'A') sl = append(sl,'B') fmt.Println(sl) } 根据这个例子我们可以画一个图：","date":"2021-06-15","objectID":"https://asong2020.github.io/string%E5%92%8Cbyte%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86/:3:0","tags":["内存拷贝"],"title":"Go语言中string和[]byte的转换原理","uri":"https://asong2020.github.io/string%E5%92%8Cbyte%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"categories":["Go面试"],"content":"string类型 先来看一下string的官方定义： // string is the set of all strings of 8-bit bytes, conventionally but not // necessarily representing UTF-8-encoded text. A string may be empty, but // not nil. Values of string type are immutable. type string string string是一个8位字节的集合，通常但不一定代表UTF-8编码的文本。string可以为空，但是不能为nil。string的值是不能改变的。 看一个简单的例子： func main() { str := \"asong\" fmt.Println(str) } string类型本质也是一个结构体，定义如下： type stringStruct struct { str unsafe.Pointer len int } stringStruct和slice还是很相似的，str指针指向的是某个数组的首地址，len代表的就是数组长度。怎么和slice这么相似，底层指向的也是数组，是什么数组呢？我们看看他在实例化时调用的方法： //go:nosplit func gostringnocopy(str *byte) string { ss := stringStruct{str: unsafe.Pointer(str), len: findnull(str)} s := *(*string)(unsafe.Pointer(\u0026ss)) return s } 入参是一个byte类型的指针，从这我们可以看出string类型底层是一个byte类型的数组，所以我们可以画出这样一个图片： ","date":"2021-06-15","objectID":"https://asong2020.github.io/string%E5%92%8Cbyte%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86/:4:0","tags":["内存拷贝"],"title":"Go语言中string和[]byte的转换原理","uri":"https://asong2020.github.io/string%E5%92%8Cbyte%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"categories":["Go面试"],"content":"string和[]byte有什么区别 上面我们一起分析了string类型，其实他底层本质就是一个byte类型的数组，那么问题就来了，string类型为什么还要在数组的基础上再进行一次封装呢？ 这是因为在Go语言中string类型被设计为不可变的，不仅是在Go语言，其他语言中string类型也是被设计为不可变的，这样的好处就是：在并发场景下，我们可以在不加锁的控制下，多次使用同一字符串，在保证高效共享的情况下而不用担心安全问题。 string类型虽然是不能更改的，但是可以被替换，因为stringStruct中的str指针是可以改变的，只是指针指向的内容是不可以改变的。看个例子： func main() { str := \"song\" fmt.Printf(\"%p\\n\",[]byte(str)) str = \"asong\" fmt.Printf(\"%p\\n\",[]byte(str)) } // 运行结果 0xc00001a090 0xc00001a098 我们可以看出来，指针指向的位置发生了变化，也就说每一个更改字符串，就需要重新分配一次内存，之前分配的空间会被gc回收。 ","date":"2021-06-15","objectID":"https://asong2020.github.io/string%E5%92%8Cbyte%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86/:5:0","tags":["内存拷贝"],"title":"Go语言中string和[]byte的转换原理","uri":"https://asong2020.github.io/string%E5%92%8Cbyte%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"categories":["Go面试"],"content":"string和[]byte标准转换 Go语言中提供了标准方式对string和[]byte进行转换，先看一个例子： func main() { str := \"asong\" by := []byte(str) str1 := string(by) fmt.Println(str1) } 标准转换用起来还是比较简单的，那你知道他们内部是怎样实现转换的吗？我们来分析一下： string类型转换到[]byte类型 我们对上面的代码执行如下指令go tool compile -N -l -S ./string_to_byte/string.go，可以看到调用的是runtime.stringtoslicebyte： // runtime/string.go go 1.15.7 const tmpStringBufSize = 32 type tmpBuf [tmpStringBufSize]byte func stringtoslicebyte(buf *tmpBuf, s string) []byte { var b []byte if buf != nil \u0026\u0026 len(s) \u003c= len(buf) { *buf = tmpBuf{} b = buf[:len(s)] } else { b = rawbyteslice(len(s)) } copy(b, s) return b } // rawbyteslice allocates a new byte slice. The byte slice is not zeroed. func rawbyteslice(size int) (b []byte) { cap := roundupsize(uintptr(size)) p := mallocgc(cap, nil, false) if cap != uintptr(size) { memclrNoHeapPointers(add(p, uintptr(size)), cap-uintptr(size)) } *(*slice)(unsafe.Pointer(\u0026b)) = slice{p, size, int(cap)} return } 这里分了两种状况，通过字符串长度来决定是否需要重新分配一块内存。也就是说预先定义了一个长度为32的数组，字符串的长度超过了这个数组的长度，就说明[]byte不够用了，需要重新分配一块内存了。这也算是一种优化吧，32是阈值，只有超过32才会进行内存分配。 最后我们会通过调用copy方法实现string到[]byte的拷贝，具体实现在src/runtime/slice.go中的slicestringcopy方法，这里就不贴这段代码了，这段代码的核心思路就是：将string的底层数组从头部复制n个到[]byte对应的底层数组中去 []byte类型转换到string类型 []byte类型转换到string类型本质调用的就是runtime.slicebytetostring： // 以下无关的代码片段 func slicebytetostring(buf *tmpBuf, ptr *byte, n int) (str string) { if n == 0 { return \"\" } if n == 1 { p := unsafe.Pointer(\u0026staticuint64s[*ptr]) if sys.BigEndian { p = add(p, 7) } stringStructOf(\u0026str).str = p stringStructOf(\u0026str).len = 1 return } var p unsafe.Pointer if buf != nil \u0026\u0026 n \u003c= len(buf) { p = unsafe.Pointer(buf) } else { p = mallocgc(uintptr(n), nil, false) } stringStructOf(\u0026str).str = p stringStructOf(\u0026str).len = n memmove(p, unsafe.Pointer(ptr), uintptr(n)) return } 这段代码我们可以看出会根据[]byte的长度来决定是否重新分配内存，最后通过memove可以拷贝数组到字符串。 ","date":"2021-06-15","objectID":"https://asong2020.github.io/string%E5%92%8Cbyte%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86/:6:0","tags":["内存拷贝"],"title":"Go语言中string和[]byte的转换原理","uri":"https://asong2020.github.io/string%E5%92%8Cbyte%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"categories":["Go面试"],"content":"string和[]byte强转换 标准的转换方法都会发生内存拷贝，所以为了减少内存拷贝和内存申请我们可以使用强转换的方式对两者进行转换。在标准库中有对这两种方法实现： // runtime/string.go func slicebytetostringtmp(ptr *byte, n int) (str string) { stringStructOf(\u0026str).str = unsafe.Pointer(ptr) stringStructOf(\u0026str).len = n return } func stringtoslicebytetmp(s string) []byte { str := (*stringStruct)(unsafe.Pointer(\u0026s)) ret := slice{array: unsafe.Pointer(str.str), len: str.len, cap: str.len} return *(*[]byte)(unsafe.Pointer(\u0026ret)) } 通过这两个方法我们可知道，主要使用的就是unsafe.Pointer进行指针替换，为什么这样可以呢？因为string和slice的结构字段是相似的： type stringStruct struct { str unsafe.Pointer len int } type slice struct { array unsafe.Pointer len int cap int } 唯一不同的就是cap字段，array和str是一致的，len是一致的，所以他们的内存布局上是对齐的，这样我们就可以直接通过unsafe.Pointer进行指针替换。 ","date":"2021-06-15","objectID":"https://asong2020.github.io/string%E5%92%8Cbyte%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86/:7:0","tags":["内存拷贝"],"title":"Go语言中string和[]byte的转换原理","uri":"https://asong2020.github.io/string%E5%92%8Cbyte%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"categories":["Go面试"],"content":"两种转换如何取舍 当然是推荐大家使用标准转换方式了，毕竟标准转换方式是更安全的！但是如果你是在高性能场景下使用，是可以考虑使用强转换的方式的，但是要注意强转换的使用方式，他不是安全的，这里举个例子： func stringtoslicebytetmp(s string) []byte { str := (*reflect.StringHeader)(unsafe.Pointer(\u0026s)) ret := reflect.SliceHeader{Data: str.Data, Len: str.Len, Cap: str.Len} return *(*[]byte)(unsafe.Pointer(\u0026ret)) } func main() { str := \"hello\" by := stringtoslicebytetmp(str) by[0] = 'H' } 运行结果： unexpected fault address 0x109d65f fatal error: fault [signal SIGBUS: bus error code=0x2 addr=0x109d65f pc=0x107eabc] 我们可以看到程序直接发生严重错误了，即使使用defer+recover也无法捕获。原因是什么呢？ 我们前面介绍过，string类型是不能改变的，也就是底层数据是不能更改的，这里因为我们使用的是强转换的方式，那么by指向了str的底层数组，现在对这个数组中的元素进行更改，就会出现这个问题，导致整个程序down掉！ ","date":"2021-06-15","objectID":"https://asong2020.github.io/string%E5%92%8Cbyte%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86/:8:0","tags":["内存拷贝"],"title":"Go语言中string和[]byte的转换原理","uri":"https://asong2020.github.io/string%E5%92%8Cbyte%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"categories":["Go面试"],"content":"总结 本文我们一起分析byte和string类型的基本定义，也分析了[]byte和string的两种转换方式，应该还差最后一环，也就是大家最关心的性能测试，这个我没有做，我觉得没有很大意义，通过前面的分析就可以得出结论，强转换的方式性能肯定要比标准转换要好。对于这两种方式的使用，大家还是根据实际场景来选择，脱离场景的谈性能就是耍流氓！！！ 素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！我是asong，我们下期见。 创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：关注公众号获取。更多学习资料请到公众号领取。 推荐往期文章： 学习channel设计：从入门到放弃 Go语言如何实现可重入锁？ Go语言中new和make你使用哪个来分配内存？ 源码剖析panic与recover，看不懂你打我好了！ 空结构体引发的大型打脸现场 Leaf—Segment分布式ID生成系统（Golang实现版本） 面试官：两个nil比较结果是什么？ 面试官：你能用Go写段代码判断当前系统的存储方式吗? 面试中如果这样写二分查找 ","date":"2021-06-15","objectID":"https://asong2020.github.io/string%E5%92%8Cbyte%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86/:9:0","tags":["内存拷贝"],"title":"Go语言中string和[]byte的转换原理","uri":"https://asong2020.github.io/string%E5%92%8Cbyte%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"categories":["Go源码"],"content":"前言 哈喽，兄弟们，我是asong。今天与大家聊一聊Go语言中的神奇函数init，为什么叫他神奇函数呢？因为该函数可以在所有程序执行开始前被调用，并且每个包下可以有多个init函数。这个函数使用起来比较简单，但是你们知道他的执行顺序是怎样的嘛？本文我们就一起来解密。 ","date":"2021-06-07","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%A5%9E%E5%A5%87%E5%87%BD%E6%95%B0init/:1:0","tags":["标准库"],"title":"Go语言中的神奇函数init","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%A5%9E%E5%A5%87%E5%87%BD%E6%95%B0init/"},{"categories":["Go源码"],"content":"init函数的特性 先简单介绍一下init函数的基本特性： init 函数先于main函数自动执行 每个包中可以有多个init函数，每个包中的源文件中也可以有多个init函数 init函数没有输入参数、返回值，也未声明，所以无法引用 不同包的init函数按照包导入的依赖关系决定执行顺序 无论包被导入多少次，init函数只会被调用一次，也就是只执行一次 ","date":"2021-06-07","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%A5%9E%E5%A5%87%E5%87%BD%E6%95%B0init/:2:0","tags":["标准库"],"title":"Go语言中的神奇函数init","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%A5%9E%E5%A5%87%E5%87%BD%E6%95%B0init/"},{"categories":["Go源码"],"content":"init函数的执行顺序 我在刚学习init函数时就对他的执行顺序很好奇，在谷歌上搜了几篇文章，他们都有一样的图： 下图来源于网络： 这张图片很清晰的反应了init函数的加载顺序： 包加载优先级排在第一位，先层层递归进行包加载 每个包中加载顺序为：const \u003e var \u003e init，首先进行初始化的是常量，然后是变量，最后才是init函数。针对包级别的变量初始化顺序，Go官方文档给出这样一个例子： var ( a = c + b // == 9 b = f() // == 4 c = f() // == 5 d = 3 // == 5 after initialization has finished ) func f() int { d++ return d } 变量的初始化按出现的顺序从前往后进行，假若某个变量需要依赖其他变量，则被依赖的变量先初始化。所以这个例子中，初始化顺序是 d -\u003e b -\u003e c -\u003e a。 上图只是表达了init函数大概的加载顺序，有些细节我们还是不知道的，比如：当前包下有多个init函数，按照什么顺序执行，当前源文件下有多个init函数，这又按照什么顺序执行呢？本来想写个例子挨个验证一下的，后来一看Go官方文档中都有说明，也就没有必要再写一个例子啦，直接说结论吧： 如果当前包下有多个init函数，首先按照源文件名的字典序从前往后执行。 若一个文件中出现多个init函数，则按照出现顺序从前往后执行。 前面说的有点乱，对init函数的加载顺序做一个小结： 从当前包开始，如果当前包包含多个依赖包，则先初始化依赖包，层层递归初始化各个包，在每一个包中，按照源文件的字典序从前往后执行，每一个源文件中，优先初始化常量、变量，最后初始化init函数，当出现多个init函数时，则按照顺序从前往后依次执行，每一个包完成加载后，递归返回，最后在初始化当前包！ ","date":"2021-06-07","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%A5%9E%E5%A5%87%E5%87%BD%E6%95%B0init/:3:0","tags":["标准库"],"title":"Go语言中的神奇函数init","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%A5%9E%E5%A5%87%E5%87%BD%E6%95%B0init/"},{"categories":["Go源码"],"content":"init函数的使用场景 还记得我之前的这篇文章吗：go解锁设计模式之单例模式，借用init函数的加载机制我们可以实现单例模式中的饿汉模式，具体怎么实现可以参考这篇文章，这里就不在写一遍了。 init函数的使用场景还是挺多的，比如进行服务注册、进行数据库或各种中间件的初始化连接等。Go的标准库中也有许多地方使用到了init函数，比如我们经常使用的pprof工具，他就使用到了init函数，在init函数里面进行路由注册： //go/1.15.7/libexec/src/cmd/trace/pprof.go func init() { http.HandleFunc(\"/io\", serveSVGProfile(pprofByGoroutine(computePprofIO))) http.HandleFunc(\"/block\", serveSVGProfile(pprofByGoroutine(computePprofBlock))) http.HandleFunc(\"/syscall\", serveSVGProfile(pprofByGoroutine(computePprofSyscall))) http.HandleFunc(\"/sched\", serveSVGProfile(pprofByGoroutine(computePprofSched))) http.HandleFunc(\"/regionio\", serveSVGProfile(pprofByRegion(computePprofIO))) http.HandleFunc(\"/regionblock\", serveSVGProfile(pprofByRegion(computePprofBlock))) http.HandleFunc(\"/regionsyscall\", serveSVGProfile(pprofByRegion(computePprofSyscall))) http.HandleFunc(\"/regionsched\", serveSVGProfile(pprofByRegion(computePprofSched))) } 这里就不扩展太多了，更多标准库中的使用方法大家可以自己去探索一下。 在这最后总结一下使用init要注意的问题吧： 编程时不要依赖init的顺序 一个源文件下可以有多个init函数，代码比较长时可以考虑分多个init函数 复杂逻辑不建议使用init函数，会增加代码的复杂性，可读性也会下降 在init函数中也可以启动goroutine，也就是在初始化的同时启动新的goroutine，这并不会影响初始化顺序 init函数不应该依赖任何在main函数里创建的变量，因为init函数的执行是在main函数之前的 init函数在代码中不能被显示的调用，不能被引用（赋值给函数变量），否则会出现编译错误。 导入包不要出现循环依赖，这样会导致程序编译失败 Go程序仅仅想要用一个package的init执行，我们可以这样使用：import _ \"test_xxxx\"，导入包的时候加上下划线就ok了 包级别的变量初始化、init函数执行，这两个操作都是在同一个goroutine中调用的，按顺序调用，一次一个包 ","date":"2021-06-07","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%A5%9E%E5%A5%87%E5%87%BD%E6%95%B0init/:4:0","tags":["标准库"],"title":"Go语言中的神奇函数init","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%A5%9E%E5%A5%87%E5%87%BD%E6%95%B0init/"},{"categories":["Go源码"],"content":"总结 好啦，这篇文章到这里就结束了，本身init函数就很好理解，写这篇文章的目的就是让大家了解他的执行顺序，这样在日常开发中才不会写出bug。希望本文对大家有所帮助，我们下期见！ 素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！我是asong，我们下期见。 创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：关注公众号获取。更多学习资料请到公众号领取。 推荐往期文章： Go语言如何实现可重入锁？ Go语言中new和make你使用哪个来分配内存？ 源码剖析panic与recover，看不懂你打我好了！ 空结构体引发的大型打脸现场 Leaf—Segment分布式ID生成系统（Golang实现版本） 面试官：两个nil比较结果是什么？ 面试官：你能用Go写段代码判断当前系统的存储方式吗? 如何平滑切换线上Elasticsearch索引 ","date":"2021-06-07","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%A5%9E%E5%A5%87%E5%87%BD%E6%95%B0init/:5:0","tags":["标准库"],"title":"Go语言中的神奇函数init","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%A5%9E%E5%A5%87%E5%87%BD%E6%95%B0init/"},{"categories":["Go应用"],"content":"前言 哈喽，大家好，我是asong。前几天一个读者问我如何使用Go语言实现可重入锁，突然想到Go语言中好像没有这个概念，平常在业务开发中也没有要用到可重入锁的概念，一时懵住了。之前在写java的时候，就会使用到可重入锁，然而写了这么久的Go，却没有使用过，这是怎么回事呢？这一篇文章就带你来解密～ ","date":"2021-05-31","objectID":"https://asong2020.github.io/go%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/:1:0","tags":["锁"],"title":"Go语言如何实现可重入锁","uri":"https://asong2020.github.io/go%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/"},{"categories":["Go应用"],"content":"什么是可重入锁 之前写过java的同学对这个概念应该了如指掌，可重入锁又称为递归锁，是指在同一个线程在外层方法获取锁的时候，在进入该线程的内层方法时会自动获取锁，不会因为之前已经获取过还没释放而阻塞。美团技术团队的一篇关于锁的文章当中针对可重入锁进行了举例： 假设现在有多个村民在水井排队打水，有管理员正在看管这口水井，村民在打水时，管理员允许锁和同一个人的多个水桶绑定，这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。 下图摘自美团技术团队分享的文章： 如果是非可重入锁，，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。 下图依旧摘自美团技术团队分享的文章： ","date":"2021-05-31","objectID":"https://asong2020.github.io/go%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/:2:0","tags":["锁"],"title":"Go语言如何实现可重入锁","uri":"https://asong2020.github.io/go%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/"},{"categories":["Go应用"],"content":"用Go实现可重入锁 既然我们想自己实现一个可重入锁，那我们就要了解java中可重入锁是如何实现的，查看了ReentrantLock的源码，大致实现思路如下： ReentrantLock继承了父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0，当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。 总结一下实现一个可重入锁需要这两点： 记住持有锁的线程 统计重入的次数 统计重入的次数很容易实现，接下来我们考虑一下怎么实现记住持有锁的线程？ 我们都知道Go语言最大的特色就是从语言层面支持并发，Goroutine是Go中最基本的执行单元，每一个Go程序至少有一个Goroutine，主程序也是一个Goroutine，称为主Goroutine，当程序启动时，他会自动创建。每个Goroutine也是有自己唯一的编号，这个编号只有在panic场景下才会看到，Go语言却刻意没有提供获取该编号的接口，官方给出的原因是为了避免滥用。但是我们还是通过一些特殊手段来获取Goroutine ID的，可以使用runtime.Stack函数输出当前栈帧信息，然后解析字符串获取Goroutine ID，具体代码可以参考开源项目 - goid。 因为go语言中的Goroutine有Goroutine ID，那么我们就可以通过这个来记住当前的线程，通过这个来判断是否持有锁，就可以了，因此我们可以定义如下结构体： type ReentrantLock struct { lock *sync.Mutex cond *sync.Cond recursion int32 host int64 } 其实就是包装了Mutex锁，使用host字段记录当前持有锁的goroutine id，使用recursion字段记录当前goroutine的重入次数。这里有一个特别要说明的就是sync.Cond，使用Cond的目的是，当多个Goroutine使用相同的可重入锁时，通过cond可以对多个协程进行协调，如果有其他协程正在占用锁，则当前协程进行阻塞，直到其他协程调用释放锁。具体sync.Cond的使用大家可以参考我之前的一篇文章：源码剖析sync.cond(条件变量的实现机制）。 构造函数 func NewReentrantLock() sync.Locker{ res := \u0026ReentrantLock{ lock: new(sync.Mutex), recursion: 0, host: 0, } res.cond = sync.NewCond(res.lock) return res } Lock func (rt *ReentrantLock) Lock() { id := GetGoroutineID() rt.lock.Lock() defer rt.lock.Unlock() if rt.host == id{ rt.recursion++ return } for rt.recursion != 0{ rt.cond.Wait() } rt.host = id rt.recursion = 1 } 这里逻辑比较简单，大概解释一下： 首先我们获取当前Goroutine的ID，然后我们添加互斥锁锁住当前代码块，保证并发安全，如果当前Goroutine正在占用锁，则增加resutsion的值，记录当前线程加锁的数量，然后返回即可。如果当前Goroutine没有占用锁，则判断当前可重入锁是否被其他Goroutine占用，如果有其他Goroutine正在占用可重入锁，则调用cond.wait方法进行阻塞，直到其他协程释放锁。 Unlock func (rt *ReentrantLock) Unlock() { rt.lock.Lock() defer rt.lock.Unlock() if rt.recursion == 0 || rt.host != GetGoroutineID() { panic(fmt.Sprintf(\"the wrong call host: (%d); current_id: %d; recursion: %d\", rt.host,GetGoroutineID(),rt.recursion)) } rt.recursion-- if rt.recursion == 0{ rt.cond.Signal() } } 大概解释如下： 首先我们添加互斥锁锁住当前代码块，保证并发安全，释放可重入锁时，如果非持有锁的Goroutine释放锁则会导致程序出现panic，这个一般是由于用户用法错误导致的。如果当前Goroutine释放了锁，则调用cond.Signal唤醒其他协程。 测试例子就不在这里贴了，代码已上传github:https://github.com/asong2020/Golang_Dream/tree/master/code_demo/reentrantLock，欢迎star。 ","date":"2021-05-31","objectID":"https://asong2020.github.io/go%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/:3:0","tags":["锁"],"title":"Go语言如何实现可重入锁","uri":"https://asong2020.github.io/go%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/"},{"categories":["Go应用"],"content":"为什么Go语言中没有可重入锁 这问题的答案，我在：https://stackoverflow.com/questions/14670979/recursive-locking-in-go#14671462，这里找到了答案。Go语言的发明者认为，如果当你的代码需要重入锁时，那就说明你的代码有问题了，我们正常写代码时，从入口函数开始，执行的层次都是一层层往下的，如果有一个锁需要共享给几个函数，那么就在调用这几个函数的上面，直接加上互斥锁就好了，不需要在每一个函数里面都添加锁，再去释放锁。 举个例子，假设我们现在一段这样的代码： func F() { mu.Lock() //... do some stuff ... G() //... do some more stuff ... mu.Unlock() } func G() { mu.Lock() //... do some stuff ... mu.Unlock() } 函数F()和G()使用了相同的互斥锁，并且都在各自函数内部进行了加锁，这要使用就会出现死锁，使用可重入锁可以解决这个问题，但是更好的方法是改变我们的代码结构，我们进行分解代码，如下： func call(){ F() G() } func F() { mu.Lock() ... do some stuff mu.Unlock() } func g() { ... do some stuff ... } func G() { mu.Lock() g() mu.Unlock() } 这样不仅避免了死锁，而且还对代码进行了解耦。这样的代码按照作用范围进行了分层，就像金字塔一样，上层调用下层的函数，越往上作用范围越大；各层有自己的锁。 总结：Go语言中完全没有必要使用可重入锁，如果我们发现我们的代码要使用到可重入锁了，那一定是我们写的代码有问题了，请检查代码结构，修改他！！！ ","date":"2021-05-31","objectID":"https://asong2020.github.io/go%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/:4:0","tags":["锁"],"title":"Go语言如何实现可重入锁","uri":"https://asong2020.github.io/go%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/"},{"categories":["Go应用"],"content":"总结 这篇文章我们知道了什么是可重入锁，并用Go语言实现了可重入锁，大家只需要知道这个概念就好了，实际开发中根本不需要。最后还是建议大家没事多思考一下自己的代码结构，好的代码都是经过深思熟虑的，最后希望大家都能写出漂亮的代码。 好啦，这篇文章到此结束啦，素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！我是asong，我们下期见。 创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：关注公众号获取。更多学习资料请到公众号领取。 推荐往期文章： Go看源码必会知识之unsafe包 Go语言中new和make你使用哪个来分配内存？ 源码剖析panic与recover，看不懂你打我好了！ 空结构体引发的大型打脸现场 Leaf—Segment分布式ID生成系统（Golang实现版本） 面试官：两个nil比较结果是什么？ 面试官：你能用Go写段代码判断当前系统的存储方式吗? 如何平滑切换线上Elasticsearch索引 ","date":"2021-05-31","objectID":"https://asong2020.github.io/go%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/:5:0","tags":["锁"],"title":"Go语言如何实现可重入锁","uri":"https://asong2020.github.io/go%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/"},{"categories":["Go面试"],"content":"背景 哈喽，大家好，我是正在学习PS技术的asong，上周读者问了我一道题，觉得挺有意义的，就在这里分享一下，我们先来看一下这个题： type User struct { } func FPrint(u User) { fmt.Printf(\"FPrint %p\\n\", \u0026u) } func main() { u := User{} FPrint(u) fmt.Printf(\"main: %p\\n\", \u0026u) } // 运行结果 FPrint 0x118eff0 main: 0x118eff0 看了运行结果，大多数朋友应该和我一样，一脸懵逼？Go语言不是只有值传递嘛？之前我还写过一篇关于\"Go语言参数传递是传值还是传引用吗？\"，已经得出明确的结论，Go语言的确是只有值传递，这不是打脸了嘛。。。 既然已经出现了这样的结果，那么就要给出一个合理的解释，不要再让气氛尴尬下去，于是我给出了我的猜想，如下： 猜想一：这是一个bug 猜想二：结构体的特殊特性导致的 猜想一有点天马行空的感觉，暂时也无法验证，所以我们先来验证猜想二，请开始我的表演，都坐下，我要装逼了。。。。 ","date":"2021-05-20","objectID":"https://asong2020.github.io/go%E4%B9%8B%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93/:1:0","tags":["结构体"],"title":"Go语言空结构体引发的大型打脸现场","uri":"https://asong2020.github.io/go%E4%B9%8B%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["Go面试"],"content":"验证猜想二：结构体的特殊特性导致的 上面的那道题中传参是一个空结构体，如果改成一个带字段的结构体会是什么样呢？我们来看一下： type UserIsEmpty struct { } type UserHasField struct { Age uint64 `json:\"age\"` } func FPrint(uIsEmpty UserIsEmpty, uHasField UserHasField) { fmt.Printf(\"FPrint uIsEmpty:%p uHasField:%p\\n\", \u0026uIsEmpty, \u0026uHasField) } func main() { uIsEmpty := UserIsEmpty{} uHasField := UserHasField{ Age: 10, } FPrint(uIsEmpty, uHasField) fmt.Printf(\"main: uIsEmpty:%p uHasField:%p\\n\", \u0026uIsEmpty, \u0026uHasField) } // 运行结果： FPrint uIsEmpty:0x118fff0 uHasField:0xc0000ba008 main: uIsEmpty:0x118fff0 uHasField:0xc0000ba000 从结果我们可以看出来，带字段的结构体确实是值传递，那么就证明空结构体有猫腻，有进展了，带着这个线索，我们来看一看这段代码的汇编部分，执行go tool compile -N -l -S test.go，可以得到汇编部分，截取重要部分： 从结果上我们看到有调用runtime.newobject(SB)来进行分配内存，顺着这个在runtme/malloc.go中找到了他的实现： func newobject(typ *_type) unsafe.Pointer { return mallocgc(typ.size, typ, true) } newobject()中主要是调用了mallocgc()方法，在这里我找到了答案。因为mallocgc()代码比较长，这里我截取关键部分： func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer { if gcphase == _GCmarktermination { throw(\"mallocgc called with gcphase == _GCmarktermination\") } if size == 0 { return unsafe.Pointer(\u0026zerobase) } .......... } 如果 size 为 0 的时候，统一返回的都是全局变量 zerobase 的地址。到这里可能还会有一些伙伴有疑惑，这个跟上面的题有什么关系？那是因为你还不知道一个知识点：正常struct是占用一小块内存的，并且结构体的大小是要经过边界，长度的对齐的，但是“空结构体”是不占内存的，size 为 0。现在一切都可以说的清了，总结原因： 因为空结构体是不占用内存的，所以size为0，在内存分配时，size为0会统一返回zerobase的地址，所以空结构体在进行参数传递时，发生值拷贝后地址都是一样的，才造成了这个质疑Go不是值传递的假象。 ","date":"2021-05-20","objectID":"https://asong2020.github.io/go%E4%B9%8B%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93/:2:0","tags":["结构体"],"title":"Go语言空结构体引发的大型打脸现场","uri":"https://asong2020.github.io/go%E4%B9%8B%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["Go面试"],"content":"空结构体特性延伸 既然说到了空结构体，就在这里补充一个关于空结构体的知识点：空结构体做为结构体内置字段时是否进行内存对齐。 先来看一个例子： func main(){ fmt.Println(unsafe.Sizeof(Test1{})) fmt.Println(unsafe.Sizeof(Test2{})) fmt.Println(unsafe.Sizeof(Test3{})) } type Test1 struct { s struct{} n byte m byte } type Test2 struct { n byte s struct{} c byte } type Test3 struct { b byte s struct{} } //运行结果 2 2 2 根据运行结果我们可以得出结论： 空结构体在结构体中的前面和中间时，是不占用空间的，但是当空结构体放到结构体中的最后时，会进行特殊填充，struct { } 作为最后一个字段，会被填充对齐到前一个字段的大小，地址偏移对齐规则不变； ","date":"2021-05-20","objectID":"https://asong2020.github.io/go%E4%B9%8B%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93/:3:0","tags":["结构体"],"title":"Go语言空结构体引发的大型打脸现场","uri":"https://asong2020.github.io/go%E4%B9%8B%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["Go面试"],"content":"总结 最后做一个全文总结吧： 空结构体也是一个结构体，不过他的size为0，所有的空结构体内存分配都是同一个地址，都是zerobase的地址； 空结构体作为内嵌字段时要注意放置的顺序，当作为最后一个字段时会进行特殊填充，会被填充对齐到前一个字段的大小，地址偏移对齐规则不变； 好啦，这篇文章就到这里啦，素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！ 创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：加我vx拉你入群，或者公众号获取入群二维码 结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。 我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。 翻译了一份Machinery中文文档，会定期进行维护，有需要的小伙伴们后台回复[machinery]即可获取。 **我是asong，一名普普通通的程序猿，让我们一起慢慢变强吧。欢迎各位的关注，我们下期见~~~** 推荐往期文章： Go看源码必会知识之unsafe包 源码剖析panic与recover，看不懂你打我好了！ 详解并发编程基础之原子操作(atomic包) 详解defer实现机制 真的理解interface了嘛 Leaf—Segment分布式ID生成系统（Golang实现版本） 十张动图带你搞懂排序算法(附go实现代码) go参数传递类型 手把手教姐姐写消息队列 常见面试题之缓存雪崩、缓存穿透、缓存击穿 详解Context包，看这一篇就够了！！！ 高并发系统的限流策略：漏桶和令牌桶(附源码剖析) 面试官：go中for-range使用过吗？这几个问题你能解释一下原因吗 ","date":"2021-05-20","objectID":"https://asong2020.github.io/go%E4%B9%8B%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93/:4:0","tags":["结构体"],"title":"Go语言空结构体引发的大型打脸现场","uri":"https://asong2020.github.io/go%E4%B9%8B%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["Go面试"],"content":"前言 哈喽，大家好，我是拖更好久的鸽子asong。因为5.1去找女朋友，所以一直没有时间写文章啦，想着回来就抓紧学习，无奈，依然沉浸在5.1的甜蜜生活中，一拖再拖，就到现在啦。果然女人影响了我拔刀的速度，但是我很喜欢，略略略。 好啦，不撒狗粮了，开始进入正题，今天我们就来探讨一下Go语言中的make和new到底怎么使用？它们又有什么不同？ ","date":"2021-05-05","objectID":"https://asong2020.github.io/make%E5%92%8Cnew%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/:1:0","tags":["关键字"],"title":"Go语言中make和new有什么区别？","uri":"https://asong2020.github.io/make%E5%92%8Cnew%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"},{"categories":["Go面试"],"content":"分配内存之new 官方文档定义： // The new built-in function allocates memory. The first argument is a type, // not a value, and the value returned is a pointer to a newly // allocated zero value of that type. func new(Type) *Type 翻译出来就是：new是一个分配内存的内置函数，第一个参数是类型，而不是值，返回的值是指向该类型新分配的零值的指针。 我们平常在使用指针的时候是需要分配内存空间的，未分配内存空间的指针直接使用会使程序崩溃，比如这样： var a *int64 *a = 10 我们声明了一个指针变量，直接就去使用它，就会使用程序触发panic，因为现在这个指针变量a在内存中没有块地址属于它，就无法直接使用该指针变量，所以new函数的作用就出现了，通过new来分配一下内存，就没有问题了： var a *int64 = new(int64) *a = 10 上面的例子，我们是针对普通类型int64进行new处理的，如果是复合类型，使用new会是什么样呢？来看一个示例： func main(){ // 数组 array := new([5]int64) fmt.Printf(\"array: %p %#v \\n\", \u0026array, array)// array: 0xc0000ae018 \u0026[5]int64{0, 0, 0, 0, 0} (*array)[0] = 1 fmt.Printf(\"array: %p %#v \\n\", \u0026array, array)// array: 0xc0000ae018 \u0026[5]int64{1, 0, 0, 0, 0} // 切片 slice := new([]int64) fmt.Printf(\"slice: %p %#v \\n\", \u0026slice, slice) // slice: 0xc0000ae028 \u0026[]int64(nil) (*slice)[0] = 1 fmt.Printf(\"slice: %p %#v \\n\", \u0026slice, slice) // panic: runtime error: index out of range [0] with length 0 // map map1 := new(map[string]string) fmt.Printf(\"map1: %p %#v \\n\", \u0026map1, map1) // map1: 0xc00000e038 \u0026map[string]string(nil) (*map1)[\"key\"] = \"value\" fmt.Printf(\"map1: %p %#v \\n\", \u0026map1, map1) // panic: assignment to entry in nil map // channel channel := new(chan string) fmt.Printf(\"channel: %p %#v \\n\", \u0026channel, channel) // channel: 0xc0000ae028 (*chan string)(0xc0000ae030) channel \u003c- \"123\" // Invalid operation: channel \u003c- \"123\" (send to non-chan type *chan string) } 从运行结果可以看出，我们使用new函数分配内存后，只有数组在初始化后可以直接使用，slice、map、chan初始化后还是不能使用，会触发panic，这是因为slice、map、chan基本数据结构是一个struct，也就是说他里面的成员变量仍未进行初始化，所以他们初始化要使用make来进行，make会初始化他们的内部结构，我们下面一节细说。还是回到struct初始化的问题上，先看一个例子： type test struct { A *int64 } func main(){ t := new(test) *t.A = 10 // panic: runtime error: invalid memory address or nil pointer dereference // [signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x10a89fd] fmt.Println(t.A) } 从运行结果得出使用new()函数初始化结构体时，我们只是初始化了struct这个类型的，而它的成员变量是没有初始化的，所以初始化结构体不建议使用new函数，使用键值对进行初始化效果更佳。 其实 new 函数在日常工程代码中是比较少见的，因为它是可以被代替，使用T{}方式更加便捷方便。 ","date":"2021-05-05","objectID":"https://asong2020.github.io/make%E5%92%8Cnew%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/:2:0","tags":["关键字"],"title":"Go语言中make和new有什么区别？","uri":"https://asong2020.github.io/make%E5%92%8Cnew%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"},{"categories":["Go面试"],"content":"初始化内置结构之make 在上一节我们说到了，make函数是专门支持 slice、map、channel 三种数据类型的内存创建，其官方定义如下： // The make built-in function allocates and initializes an object of type // slice, map, or chan (only). Like new, the first argument is a type, not a // value. Unlike new, make's return type is the same as the type of its // argument, not a pointer to it. The specification of the result depends on // the type: // Slice: The size specifies the length. The capacity of the slice is // equal to its length. A second integer argument may be provided to // specify a different capacity; it must be no smaller than the // length. For example, make([]int, 0, 10) allocates an underlying array // of size 10 and returns a slice of length 0 and capacity 10 that is // backed by this underlying array. // Map: An empty map is allocated with enough space to hold the // specified number of elements. The size may be omitted, in which case // a small starting size is allocated. // Channel: The channel's buffer is initialized with the specified // buffer capacity. If zero, or the size is omitted, the channel is // unbuffered. func make(t Type, size ...IntegerType) Type 大概翻译最上面一段：make内置函数分配并初始化一个slice、map或chan类型的对象。像new函数一样，第一个参数是类型，而不是值。与new不同，make的返回类型与其参数的类型相同，而不是指向它的指针。结果的取决于传入的类型。 使用make初始化传入的类型也是不同的，具体可以这样区分： Func Type T res make(T, n) slice slice of type T with length n and capacity n make(T, n, m) slice slice of type T with length n and capacity m make(T) map map of type T make(T, n) map map of type T with initial space for approximately n elements make(T) channel unbuffered channel of type T make(T, n) channel buffered channel of type T, buffer size n 不同的类型初始化可以使用不同的姿势，主要区别主要是长度（len）和容量（cap）的指定，有的类型是没有容量这一说法，因此自然也就无法指定。如果确定长度和容量大小，能很好节省内存空间。 写个简单的示例： func main(){ slice := make([]int64, 3, 5) fmt.Println(slice) // [0 0 0] map1 := make(map[int64]bool, 5) fmt.Println(map1) // map[] channel := make(chan int, 1) fmt.Println(channel) // 0xc000066070 } 这里有一个需要注意的点，就是slice在进行初始化时，默认会给零值，在开发中要注意这个问题，我就犯过这个错误，导致数据不一致。 ","date":"2021-05-05","objectID":"https://asong2020.github.io/make%E5%92%8Cnew%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/:3:0","tags":["关键字"],"title":"Go语言中make和new有什么区别？","uri":"https://asong2020.github.io/make%E5%92%8Cnew%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"},{"categories":["Go面试"],"content":"new和make区别总结 new函数主要是为类型申请一片内存空间，返回执行内存的指针 make函数能够分配并初始化类型所需的内存空间和结构，返回复合类型的本身。 make函数仅支持 channel、map、slice 三种类型，其他类型不可以使用使用make。 new函数在日常开发中使用是比较少的，可以被替代。 make函数初始化slice会初始化零值，日常开发要注意这个问题。 ","date":"2021-05-05","objectID":"https://asong2020.github.io/make%E5%92%8Cnew%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/:4:0","tags":["关键字"],"title":"Go语言中make和new有什么区别？","uri":"https://asong2020.github.io/make%E5%92%8Cnew%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"},{"categories":["Go面试"],"content":"make函数底层实现 我还是比较好奇make底层实现是怎样的，所以执行汇编指令：go tool compile -N -l -S file.go，我们可以看到make函数初始化slice、map、chan分别调用的是runtime.makeslice、runtime.makemap_small、runtime.makechan这三个方法，因为不同类型底层数据结构不同，所以初始化方式也不同，我们只看一下slice的内部实现就好了，其他的交给大家自己去看，其实都是大同小异的。 func makeslice(et *_type, len, cap int) unsafe.Pointer { mem, overflow := math.MulUintptr(et.size, uintptr(cap)) if overflow || mem \u003e maxAlloc || len \u003c 0 || len \u003e cap { // NOTE: Produce a 'len out of range' error instead of a // 'cap out of range' error when someone does make([]T, bignumber). // 'cap out of range' is true too, but since the cap is only being // supplied implicitly, saying len is clearer. // See golang.org/issue/4085. mem, overflow := math.MulUintptr(et.size, uintptr(len)) if overflow || mem \u003e maxAlloc || len \u003c 0 { panicmakeslicelen() } panicmakeslicecap() } return mallocgc(mem, et, true) } 这个函数功能其实也比较简单： 检查切片占用的内存空间是否溢出。 调用mallocgc在堆上申请一片连续的内存。 检查内存空间这里是根据切片容量进行计算的，根据当前切片元素的大小与切片容量的乘积得出当前内存空间的大小，检查溢出的条件有四个： 内存空间大小溢出了 申请的内存空间大于最大可分配的内存 传入的len小于0，cap的大小只小于len mallocgc函数实现比较复杂，我暂时还没有看懂，不过也不是很重要，大家有兴趣可以自行学习。 ","date":"2021-05-05","objectID":"https://asong2020.github.io/make%E5%92%8Cnew%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/:5:0","tags":["关键字"],"title":"Go语言中make和new有什么区别？","uri":"https://asong2020.github.io/make%E5%92%8Cnew%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"},{"categories":["Go面试"],"content":"new函数底层实现 new函数底层主要是调用runtime.newobject： // implementation of new builtin // compiler (both frontend and SSA backend) knows the signature // of this function func newobject(typ *_type) unsafe.Pointer { return mallocgc(typ.size, typ, true) } 内部实现就是直接调用mallocgc函数去堆上申请内存，返回值是指针类型。 ","date":"2021-05-05","objectID":"https://asong2020.github.io/make%E5%92%8Cnew%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/:6:0","tags":["关键字"],"title":"Go语言中make和new有什么区别？","uri":"https://asong2020.github.io/make%E5%92%8Cnew%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"},{"categories":["Go面试"],"content":"总结 今天这篇文章我们主要介绍了make和new的使用场景、以及其不同之处，其实他们都是用来分配内存的，只不过make函数为slice、map、chan这三种类型服务。日常开发中使用make初始化slice时要注意零值问题，否则又是一个p0事故。 好啦，这篇文章到此结束啦，素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！我是asong，我们下期见。 创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：关注公众号获取。更多学习资料请到公众号领取。 推荐往期文章： Go看源码必会知识之unsafe包 源码剖析panic与recover，看不懂你打我好了！ 空结构体引发的大型打脸现场 Leaf—Segment分布式ID生成系统（Golang实现版本） 面试官：两个nil比较结果是什么？ 面试官：你能用Go写段代码判断当前系统的存储方式吗? 如何平滑切换线上Elasticsearch索引 ","date":"2021-05-05","objectID":"https://asong2020.github.io/make%E5%92%8Cnew%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/:7:0","tags":["关键字"],"title":"Go语言中make和new有什么区别？","uri":"https://asong2020.github.io/make%E5%92%8Cnew%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"},{"categories":["Go面试"],"content":"背景 哈喽，大家好，我是asong。前几天在一个交流群里看到了一道非常有意思的面试题，今天把它分享出来，我们先来看一下这个道题： fmt.Println(nil== nil) 两个nil的比较结果是什么？ true、false、还是无法编译？ 大家先思考着，文中揭晓答案。 写在开始：建议你们看一下这个视频：https://www.youtube.com/watch?v=ynoY2xz-F8s 需要翻墙哈，看完这个你对nil会有一个新的理解。 ","date":"2021-05-05","objectID":"https://asong2020.github.io/%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/:1:0","tags":["关键字"],"title":"Go语言中两个nil的比较结果是什么？","uri":"https://asong2020.github.io/%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/"},{"categories":["Go面试"],"content":"Go中nil的定义 在Go官方文档中，对nil的定义如下： // nil is a predeclared identifier representing the zero value for a // pointer, channel, func, interface, map, or slice type. var nil Type // Type must be a pointer, channel, func, interface, map, or slice type nil是一个预先声明的标识符，代表指针(pointer)、通道(channel)、函数(func)、接口(interface)、map、切片(slice)。也可以这么理解：指针、通道、函数、接口、map、切片的零值就是nil，就像布尔类型的零值是false、整型的零值是0。 ","date":"2021-05-05","objectID":"https://asong2020.github.io/%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/:2:0","tags":["关键字"],"title":"Go语言中两个nil的比较结果是什么？","uri":"https://asong2020.github.io/%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/"},{"categories":["Go面试"],"content":"深入理解nil ","date":"2021-05-05","objectID":"https://asong2020.github.io/%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/:3:0","tags":["关键字"],"title":"Go语言中两个nil的比较结果是什么？","uri":"https://asong2020.github.io/%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/"},{"categories":["Go面试"],"content":"nil根本不是关键字 我们先来看一段代码： func main() { nil := \"this is nil\" fmt.Println(nil) } // 运行结果 this is nil 那再改成这样呢？ func main() { nil := \"this is nil\" fmt.Println(nil) var slice []string = nil fmt.Println(slice) } // 运行结果 # command-line-arguments ./nil.go:10:6: cannot use nil (type string) as type []string in assignment 编译的时候直接报错了，因为这个nil是一个string类型，所以从这里确定nil在Go语言中并不是关键字，我们可以随意定义变量名为nil（不过不建议这么用）。 ","date":"2021-05-05","objectID":"https://asong2020.github.io/%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/:3:1","tags":["关键字"],"title":"Go语言中两个nil的比较结果是什么？","uri":"https://asong2020.github.io/%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/"},{"categories":["Go面试"],"content":"nil的默认类型 一般预声明标识符都会有一个默认类型，比如Go语言中的itoa默认类型就是int，那么nil的默认类型呢？我们写个例子来看一下： func main() { const val1 = iota fmt.Printf(\"%T\\n\",val1) var val2 = nil fmt.Printf(\"%T\\n\",val2) } // 运行结果 # command-line-arguments ./nil.go:10:6: use of untyped nil 在编译时就已经报错，编译器告诉我们使用了无类型的nil，所以我们可以得出结论： nil是没有默认类型的，它的类型具有不确定性，我们在使用它时必须要提供足够的信息能够让编译器推断nil期望的类型。 ","date":"2021-05-05","objectID":"https://asong2020.github.io/%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/:3:2","tags":["关键字"],"title":"Go语言中两个nil的比较结果是什么？","uri":"https://asong2020.github.io/%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/"},{"categories":["Go面试"],"content":"nil的比较 nil的比较我们可以分为以下两种情况： nil标识符的比较 nil的值比较 我们先来看一下nil标识符的比较，也就是我们开头那一道面试题，先看一下运行结果呢： # command-line-arguments ./nil.go:8:18: invalid operation: nil == nil (operator == not defined on nil) 通过编译结果我们可以看出==符号对于nil来说是一种未定义的操作，所以是不可以比较两个nil的。 接着我们来看一看nil的值比较，因为nil是没有类型的，是在编译期根据上下文确定的，所以要比较nil的值也就是比较不同类型的nil，这又分为同一个类型的nil值比较和不同类型nil值的比较，分这两种情况我们分别来验证一下。 同一个类型的nil值比较 func main() { // 指针类型的nil比较 fmt.Println((*int64)(nil) == (*int64)(nil)) // channel 类型的nil比较 fmt.Println((chan int)(nil) == (chan int)(nil)) // func类型的nil比较 fmt.Println((func())(nil) == (func())(nil)) // func() 只能与nil进行比较 // interface类型的nil比较 fmt.Println((interface{})(nil) == (interface{})(nil)) // map类型的nil比较 fmt.Println((map[string]int)(nil) == (map[string]int)(nil)) // map 只能与nil进行比较 // slice类型的nil比较 fmt.Println(([]int)(nil) == ([]int)(nil)) // slice 只能与nil进行比较 } 运行结果： # command-line-arguments ./nil.go:13:28: invalid operation: (func())(nil) == (func())(nil) (func can only be compared to nil) ./nil.go:17:36: invalid operation: (map[string]int)(nil) == (map[string]int)(nil) (map can only be compared to nil) ./nil.go:19:27: invalid operation: ([]int)(nil) == ([]int)(nil) (slice can only be compared to nil) 从运行结果我们可以看出，指针类型nil、channel类型的nil、interface类型可以相互比较，而func类型、map类型、slice类型只能与nil标识符比较，两个类型相互比较是不合法的。 不同类型的nil值比较 func main() { var ptr *int64 = nil var cha chan int64 = nil var fun func() = nil var inter interface{} = nil var ma map[string]string = nil var slice []int64 = nil fmt.Println(ptr == cha) fmt.Println(ptr == fun) fmt.Println(ptr == inter) fmt.Println(ptr == ma) fmt.Println(ptr == slice) fmt.Println(cha == fun) fmt.Println(cha == inter) fmt.Println(cha == ma) fmt.Println(cha == slice) fmt.Println(fun == inter) fmt.Println(fun == ma) fmt.Println(fun == slice) fmt.Println(inter == ma) fmt.Println(inter == slice) fmt.Println(ma == slice) } 运行结果： # command-line-arguments ./nil.go:14:18: invalid operation: ptr == cha (mismatched types *int64 and chan int64) ./nil.go:15:18: invalid operation: ptr == fun (mismatched types *int64 and func()) ./nil.go:17:18: invalid operation: ptr == ma (mismatched types *int64 and map[string]string) ./nil.go:18:18: invalid operation: ptr == slice (mismatched types *int64 and []int64) ./nil.go:20:18: invalid operation: cha == fun (mismatched types chan int64 and func()) ./nil.go:22:18: invalid operation: cha == ma (mismatched types chan int64 and map[string]string) ./nil.go:23:18: invalid operation: cha == slice (mismatched types chan int64 and []int64) ./nil.go:25:18: invalid operation: fun == inter (operator == not defined on func) ./nil.go:26:18: invalid operation: fun == ma (mismatched types func() and map[string]string) ./nil.go:27:18: invalid operation: fun == slice (mismatched types func() and []int64) ./nil.go:27:18: too many errors 从运行结果我们可以得出，只有指针类型和channel类型与接口类型可以比较，其他类型的之间是不可以相互比较的。为什么指针类型、channel类型可以和接口类型进行比较呢？ 这个答案，先空着，因为我也没有想明白，不是说/任何类型都实现了interface{}类型吗？这里没想明白，期待你们的解答。 ","date":"2021-05-05","objectID":"https://asong2020.github.io/%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/:3:3","tags":["关键字"],"title":"Go语言中两个nil的比较结果是什么？","uri":"https://asong2020.github.io/%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/"},{"categories":["Go面试"],"content":"nil在不同类型中使用需要注意的问题 ","date":"2021-05-05","objectID":"https://asong2020.github.io/%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/:4:0","tags":["关键字"],"title":"Go语言中两个nil的比较结果是什么？","uri":"https://asong2020.github.io/%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/"},{"categories":["Go面试"],"content":"interface与nil比较要注意的一个点 我们先来看一个例子： func main() { err := Todo() fmt.Println(err == nil) } type Err interface { } type err struct { Code int64 Msg string } func Todo() Err { var res *err return res } // 运行结果 false 输出结果是false，在Todo方法内我们声明了一个变量res，这个变量是一个指针类型，零值是nil，返回的是接口类型，按理说返回值接口类型也应是nil才对，但是结果却不是这样。这是因为我们忽略了接口类型的一个概念，interface 不是单纯的值，而是分为类型和值。所以必须要类型和值同时都为 nil 的情况下，interface 的 nil 判断才会为 true。 这是一个新手很容易出现的问题，大家一定要注意这个问题。 ","date":"2021-05-05","objectID":"https://asong2020.github.io/%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/:4:1","tags":["关键字"],"title":"Go语言中两个nil的比较结果是什么？","uri":"https://asong2020.github.io/%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/"},{"categories":["Go面试"],"content":"一个nil的map读写数据是否会发生panic 对于这种问题，我们直接写个例子测试一下就好： func main() { var m map[string]string fmt.Println(m[\"asoong\"]) m[\"asong\"] = \"Golang梦工厂\" } // 运行结果 panic: assignment to entry in nil map goroutine 1 [running]: main.main() go/src/asong.cloud/Golang_Dream/code_demo/slice_demo/nil.go:10 +0xed 根据运行结果我们可以看出，一个nil的map可以读数据，但是不可以写入数据，否则会发生panic，所以要使用map一定要使用make进行初始化。 ","date":"2021-05-05","objectID":"https://asong2020.github.io/%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/:4:2","tags":["关键字"],"title":"Go语言中两个nil的比较结果是什么？","uri":"https://asong2020.github.io/%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/"},{"categories":["Go面试"],"content":"关闭nil的channel会引发panic func main() { var cha chan int close(cha) } 运行结果： panic: close of nil channel goroutine 1 [running]: main.main() /go/src/asong.cloud/Golang_Dream/code_demo/slice_demo/nil.go:5 +0x2a 根据运行结果我们可以得出关闭一个nil的channel会导致程序panic，在使用上我们要注意这个问题，还有有一个需要注意的问题：一个nil的channel读写数据都会造成永远阻塞。 ","date":"2021-05-05","objectID":"https://asong2020.github.io/%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/:4:3","tags":["关键字"],"title":"Go语言中两个nil的比较结果是什么？","uri":"https://asong2020.github.io/%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/"},{"categories":["Go面试"],"content":"一个为nil的slice使用注意事项 func main() { var slice []int64 = nil fmt.Println(len(slice)) fmt.Println(cap(slice)) for range slice{ } fmt.Println(slice[0]) } // 运行结果 0 0 panic: runtime error: index out of range [0] with length 0 goroutine 1 [running]: main.main() /go/src/asong.cloud/Golang_Dream/code_demo/slice_demo/nil.go:14 +0xf2 根据这个例子，我们可以得出如下结论： 一个为nil的索引，不可以进行索引，否则会引发panic，其他操作是可以。 ","date":"2021-05-05","objectID":"https://asong2020.github.io/%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/:4:4","tags":["关键字"],"title":"Go语言中两个nil的比较结果是什么？","uri":"https://asong2020.github.io/%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/"},{"categories":["Go面试"],"content":"方法接收者为nil时是否会引发panic func main() { var m *man fmt.Println(m.GetName()) } type man struct { } func (m *man)GetName() string { return \"asong\" } // 运行结果 asong 根据运行结果我们可以看出，方法接收者为nil时，我们仍然可以访问对应的方法，但是要注意方法内的写法，否则也会引发panic。上面的代码改成这样： func main() { var m *man fmt.Println(m.GetName()) } type man struct { Name string } func (m *man)GetName() string { return m.Name } // 运行结果 panic: runtime error: invalid memory address or nil pointer dereference [signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x10a6ec3] goroutine 1 [running]: main.(*man).GetName(...) go/src/asong.cloud/Golang_Dream/code_demo/slice_demo/nil.go:18 main.main() go/src/asong.cloud/Golang_Dream/code_demo/slice_demo/nil.go:9 +0x23 这样就是直接引发panic，所以为了程序健壮性我们要做一次指针判空处理。 ","date":"2021-05-05","objectID":"https://asong2020.github.io/%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/:4:5","tags":["关键字"],"title":"Go语言中两个nil的比较结果是什么？","uri":"https://asong2020.github.io/%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/"},{"categories":["Go面试"],"content":"空指针是一个没有任何值的指针 func main() { var a = (*int64)(unsafe.Pointer(uintptr(0x0))) fmt.Println(a == nil) //true } // 运行结果 true 这里我们用了0x0做了一个小实验，正好证明了空指针就是一个没有指向任何值的指针。 ","date":"2021-05-05","objectID":"https://asong2020.github.io/%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/:4:6","tags":["关键字"],"title":"Go语言中两个nil的比较结果是什么？","uri":"https://asong2020.github.io/%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/"},{"categories":["Go面试"],"content":"总结 文章接近尾声啦，我们来揭晓一下文章开始的答案，用文中nil比较的知识点正好可以解答这个问题，nil标识符是没有类型的，所以==对于nil来说是一种未定义的操作，不可以进行比较，而这个在python中是可以比较的，在 python 中，两个 None 值永远相等，不要弄混了朋友们。 最后建议你们看一下这个视频：https://www.youtube.com/watch?v=ynoY2xz-F8s 需要翻墙哈，看完这个你对nil会有一个新的理解。 好啦，这篇文章就到这里啦，素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！ 创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：加我vx拉你入群，或者公众号获取入群二维码 结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。 我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。 翻译了一份Machinery中文文档，会定期进行维护，有需要的小伙伴们后台回复[machinery]即可获取。 **我是asong，一名普普通通的程序猿，让我们一起慢慢变强吧。欢迎各位的关注，我们下期见~~~** 推荐往期文章： Go看源码必会知识之unsafe包 源码剖析panic与recover，看不懂你打我好了！ 详解并发编程基础之原子操作(atomic包) 详解defer实现机制 空结构体引发的大型打脸现场 Leaf—Segment分布式ID生成系统（Golang实现版本） 十张动图带你搞懂排序算法(附go实现代码) go参数传递类型 手把手教姐姐写消息队列 常见面试题之缓存雪崩、缓存穿透、缓存击穿 详解Context包，看这一篇就够了！！！ 面试官：你能用Go写段代码判断当前系统的存储方式吗? 如何平滑切换线上Elasticsearch索引 ","date":"2021-05-05","objectID":"https://asong2020.github.io/%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/:5:0","tags":["关键字"],"title":"Go语言中两个nil的比较结果是什么？","uri":"https://asong2020.github.io/%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/"},{"categories":["Go源码"],"content":"前言 哈喽，everyBody，我是asong，今天我们一起来探索一下interface的类型断言是如何实现的。我们通常使用interface有两种方式，一种是带方法的interface，一种是空的interface。因为Go中是没有泛型，所以我们可以用空的interface{}来作为一种伪泛型使用，当我们使用到空的interface{}作为入参或返回值时，就会使用到类型断言，来获取我们所需要的类型，所以平常我们会在代码中看到大量的类型断言使用，你就不好奇它是怎么实现的嘛？你就不好奇它的性能损耗是多少嘛？反正我很好奇，略～。 ","date":"2021-04-18","objectID":"https://asong2020.github.io/interface%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:1:0","tags":["关键字"],"title":"Go语言中interface的类型断言实现原理及性能分析","uri":"https://asong2020.github.io/interface%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["Go源码"],"content":"类型断言的基本使用 Type Assertion（断言）是用于interface value的一种操作，语法是x.(T)，x是interface type的表达式，而T是asserted type，被断言的类型。举个例子看一下基本使用： func main() { var demo interface{} = \"Golang梦工厂\" str := demo.(string) fmt.Printf(\"value: %v\", str) } 上面我们声明了一个接口对象demo，通过类型断言的方式断言一个接口对象demo是不是nil，并判断接口对象demo存储的值的类型是T，如果断言成功，就会返回值给str，如果断言失败，就会触发panic。这段代码加上如果这样写，就会触发panic： number := demo.(int64) fmt.Printf(\"value： %v\\n\", number) 所以为了安全起见，我们还可以这样使用： func main() { var demo interface{} = \"Golang梦工厂\" number, ok := demo.(int64) if !ok { fmt.Printf(\"assert failed\") return } fmt.Printf(\"value： %v\\n\", number) } 运行结果：assert failed 这里使用的表达式是t,ok:=i.(T)，这个表达式也是可以断言一个接口对象（i）里不是 nil，并且接口对象（i）存储的值的类型是 T，如果断言成功，就会返回其类型给 t，并且此时 ok 的值 为 true，表示断言成功。如果接口值的类型，并不是我们所断言的 T，就会断言失败，但和第一种表达式不同的是这个不会触发 panic，而是将 ok 的值设为false，表示断言失败，此时t 为T的零值。所以推荐使用这种方式，可以保证代码的健壮性。 如果我们想要区分多种类型，可以使用type switch断言，使用这种方法就不需要我们按上面的方式去一个一个的进行类型断言了，更简单，更高效。上面的代码我们可以改成这样： func main() { var demo interface{} = \"Golang梦工厂\" switch demo.(type) { case nil: fmt.Printf(\"demo type is nil\\n\") case int64: fmt.Printf(\"demo type is int64\\n\") case bool: fmt.Printf(\"demo type is bool\\n\") case string: fmt.Printf(\"demo type is string\\n\") default: fmt.Printf(\"demo type unkonwn\\n\") } } type switch的一个典型应用是在go.uber.org/zap库中的zap.Any()方法，里面就用到了类型断言，把所有的类型的case都列举出来了，default分支使用的是Reflect，也就是当所有类型都不匹配时使用反射获取相应的值，具体大家可以去看一下源码。 ","date":"2021-04-18","objectID":"https://asong2020.github.io/interface%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:2:0","tags":["关键字"],"title":"Go语言中interface的类型断言实现原理及性能分析","uri":"https://asong2020.github.io/interface%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["Go源码"],"content":"类型断言实现源码剖析 非空接口和空接口都可以使用类型断言，我们分两种进行剖析。 ","date":"2021-04-18","objectID":"https://asong2020.github.io/interface%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:3:0","tags":["关键字"],"title":"Go语言中interface的类型断言实现原理及性能分析","uri":"https://asong2020.github.io/interface%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["Go源码"],"content":"空接口 我们先来写一段测试代码： type User struct { Name string } func main() { var u interface{} = \u0026User{Name: \"asong\"} val, ok := u.(int) if !ok { fmt.Printf(\"%v\\n\", val) } } 老样子，我们将上述代码转换成汇编代码看一下： go tool compile -S -N -l main.go \u003e main.s4 2\u003e\u00261 截取部分重要汇编代码如下： 0x002f 00047 (main.go:12) XORPS X0, X0 0x0032 00050 (main.go:12) MOVUPS X0, \"\"..autotmp_8+136(SP) 0x003a 00058 (main.go:12) PCDATA $2, $1 0x003a 00058 (main.go:12) PCDATA $0, $0 0x003a 00058 (main.go:12) LEAQ \"\"..autotmp_8+136(SP), AX 0x0042 00066 (main.go:12) MOVQ AX, \"\"..autotmp_7+96(SP) 0x0047 00071 (main.go:12) TESTB AL, (AX) 0x0049 00073 (main.go:12) MOVQ $5, \"\"..autotmp_8+144(SP) 0x0055 00085 (main.go:12) PCDATA $2, $2 0x0055 00085 (main.go:12) LEAQ go.string.\"asong\"(SB), CX 0x005c 00092 (main.go:12) PCDATA $2, $1 0x005c 00092 (main.go:12) MOVQ CX, \"\"..autotmp_8+136(SP) 0x0064 00100 (main.go:12) MOVQ AX, \"\"..autotmp_3+104(SP) 0x0069 00105 (main.go:12) PCDATA $2, $2 0x0069 00105 (main.go:12) PCDATA $0, $2 0x0069 00105 (main.go:12) LEAQ type.*\"\".User(SB), CX 0x0070 00112 (main.go:12) PCDATA $2, $1 0x0070 00112 (main.go:12) MOVQ CX, \"\".u+120(SP) 0x0075 00117 (main.go:12) PCDATA $2, $0 0x0075 00117 (main.go:12) MOVQ AX, \"\".u+128(SP) 上面这段汇编代码的作用就是赋值给空接口，数据都存在栈上，因为空interface{}的结构是eface，所以就是组装了一个eface在内存中，内存布局如下： 我们知道空接口的数据结构中只有两个字段，一个_type字段，一个data字段，从上图中，我们可以看出来，eface的_type存储在内存的+120(SP)处，unsafe.Pointer存在了+128（SP）处，现在我们知道了他是怎么存的了，接下来我们看一下空接口的类型断言汇编是怎么实现的： 0x007d 00125 (main.go:13) PCDATA $2, $1 0x007d 00125 (main.go:13) MOVQ \"\".u+128(SP), AX 0x0085 00133 (main.go:13) PCDATA $0, $0 0x0085 00133 (main.go:13) MOVQ \"\".u+120(SP), CX 0x008a 00138 (main.go:13) PCDATA $2, $3 0x008a 00138 (main.go:13) LEAQ type.int(SB), DX 0x0091 00145 (main.go:13) PCDATA $2, $1 0x0091 00145 (main.go:13) CMPQ CX, DX 0x0094 00148 (main.go:13) JEQ 155 0x0096 00150 (main.go:13) JMP 395 0x009b 00155 (main.go:13) PCDATA $2, $0 0x009b 00155 (main.go:13) MOVQ (AX), AX 0x009e 00158 (main.go:13) MOVL $1, CX 0x00a3 00163 (main.go:13) JMP 165 0x00a5 00165 (main.go:13) MOVQ AX, \"\"..autotmp_4+80(SP) 0x00aa 00170 (main.go:13) MOVB CL, \"\"..autotmp_5+71(SP) 0x00ae 00174 (main.go:13) MOVQ \"\"..autotmp_4+80(SP), AX 0x00b3 00179 (main.go:13) MOVQ AX, \"\".val+72(SP) 0x00b8 00184 (main.go:13) MOVBLZX \"\"..autotmp_5+71(SP), AX 0x00bd 00189 (main.go:13) MOVB AL, \"\".ok+70(SP) 0x00c1 00193 (main.go:14) CMPB \"\".ok+70(SP), $0 从上面这段汇编我们可以看出来，空接口的类型断言是通过判断eface中的_type字段和比较的类型进行对比，相同就会去准备接下来的返回值，如果类型断言正确，经过中间临时变量的传递，最终val保存在内存中+72(SP)处。ok保存在内存+70(SP)处。 0x018b 00395 (main.go:15) XORL AX, AX 0x018d 00397 (main.go:15) XORL CX, CX 0x018f 00399 (main.go:13) JMP 165 0x0194 00404 (main.go:13) NOP 如果断言失败，就会清空AX和CX寄存器，因为AX和CX中存的是eface结构体里面的字段。 最后总结一下空接口类型断言实现流程：空接口类型断言实质是将eface中_type与要匹配的类型进行对比，匹配成功在内存中组装返回值，匹配失败直接清空寄存器，返回默认值。 ","date":"2021-04-18","objectID":"https://asong2020.github.io/interface%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:3:1","tags":["关键字"],"title":"Go语言中interface的类型断言实现原理及性能分析","uri":"https://asong2020.github.io/interface%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["Go源码"],"content":"非空接口 老样子，还是先写一个例子，然后我们在看他的汇编实现： type Basic interface { GetName() string SetName(name string) error } type User struct { Name string } func (u *User) GetName() string { return u.Name } func (u *User) SetName(name string) error { u.Name = name return nil } func main() { var u Basic = \u0026User{Name: \"asong\"} switch u.(type) { case *User: u1 := u.(*User) fmt.Println(u1.Name) default: fmt.Println(\"failed to match\") } } 使用汇编指令看一下他的汇编代码如下： 0x002f 00047 (main.go:26) PCDATA $2, $0 0x002f 00047 (main.go:26) PCDATA $0, $1 0x002f 00047 (main.go:26) XORPS X0, X0 0x0032 00050 (main.go:26) MOVUPS X0, \"\"..autotmp_5+152(SP) 0x003a 00058 (main.go:26) PCDATA $2, $1 0x003a 00058 (main.go:26) PCDATA $0, $0 0x003a 00058 (main.go:26) LEAQ \"\"..autotmp_5+152(SP), AX 0x0042 00066 (main.go:26) MOVQ AX, \"\"..autotmp_4+64(SP) 0x0047 00071 (main.go:26) TESTB AL, (AX) 0x0049 00073 (main.go:26) MOVQ $5, \"\"..autotmp_5+160(SP) 0x0055 00085 (main.go:26) PCDATA $2, $2 0x0055 00085 (main.go:26) LEAQ go.string.\"asong\"(SB), CX 0x005c 00092 (main.go:26) PCDATA $2, $1 0x005c 00092 (main.go:26) MOVQ CX, \"\"..autotmp_5+152(SP) 0x0064 00100 (main.go:26) MOVQ AX, \"\"..autotmp_2+72(SP) 0x0069 00105 (main.go:26) PCDATA $2, $2 0x0069 00105 (main.go:26) PCDATA $0, $2 0x0069 00105 (main.go:26) LEAQ go.itab.*\"\".User,\"\".Basic(SB), CX 0x0070 00112 (main.go:26) PCDATA $2, $1 0x0070 00112 (main.go:26) MOVQ CX, \"\".u+104(SP) 0x0075 00117 (main.go:26) PCDATA $2, $0 0x0075 00117 (main.go:26) MOVQ AX, \"\".u+112(SP) 上面这段汇编代码作用就是赋值给非空接口的iface结构，组装了iface的内存布局，因为上面分析了非空接口的，这里就不细讲了，理解他的意思就好。接下来我们看一下他是如何进行类型断言的。 0x00df 00223 (main.go:29) PCDATA $2, $1 0x00df 00223 (main.go:29) PCDATA $0, $2 0x00df 00223 (main.go:29) MOVQ \"\".u+112(SP), AX 0x00e4 00228 (main.go:29) PCDATA $0, $0 0x00e4 00228 (main.go:29) MOVQ \"\".u+104(SP), CX 0x00e9 00233 (main.go:29) PCDATA $2, $3 0x00e9 00233 (main.go:29) LEAQ go.itab.*\"\".User,\"\".Basic(SB), DX 0x00f0 00240 (main.go:29) PCDATA $2, $1 0x00f0 00240 (main.go:29) CMPQ CX, DX 0x00f3 00243 (main.go:29) JEQ 250 0x00f5 00245 (main.go:29) JMP 583 0x00fa 00250 (main.go:29) MOVQ AX, \"\".u1+56(SP) 上面代码我们可以看到调用iface结构中的itab字段，这里为什么这么调用呢？因为我们类型推断的是一个具体的类型，编译器会直接构造出iface，不会去调用已经在runtime/iface.go实现好的断言方法。上述代码中，先构造出 iface，其中*itab存在内存 +104(SP) 中，unsafe.Pointer 存在 +112(SP) 中。然后在类型推断的时候又重新构造了一遍 *itab，最后将新的 *itab 和前一次 +104(SP) 里的 *itab 进行对比。 后面的赋值操作也就不再细说了，没有什么特别的。 这里还有一个要注意的问题，如果我们类型断言的是接口类型，那么我们在就会看到这样的汇编代码： // 代码修改 func main() { var u Basic = \u0026User{Name: \"asong\"} v, ok := u.(Basic) if !ok { fmt.Printf(\"%v\\n\", v) } } // 部分汇编代码 0x008c 00140 (main.go:27) MOVUPS X0, \"\"..autotmp_4+168(SP) 0x0094 00148 (main.go:27) PCDATA $2, $1 0x0094 00148 (main.go:27) MOVQ \"\".u+128(SP), AX 0x009c 00156 (main.go:27) PCDATA $0, $0 0x009c 00156 (main.go:27) MOVQ \"\".u+120(SP), CX 0x00a1 00161 (main.go:27) PCDATA $2, $4 0x00a1 00161 (main.go:27) LEAQ type.\"\".Basic(SB), DX 0x00a8 00168 (main.go:27) PCDATA $2, $1 0x00a8 00168 (main.go:27) MOVQ DX, (SP) 0x00ac 00172 (main.go:27) MOVQ CX, 8(SP) 0x00b1 00177 (main.go:27) PCDATA $2, $0 0x00b1 00177 (main.go:27) MOVQ AX, 16(SP) 0x00b6 00182 (main.go:27) CALL runtime.assertI2I2(SB) 我们可以看到，直接调用的是runtime.assertI2I2()方法进行类型断言，这个方法的实现代码如下： func assertI2I(inter *interfacetype, i iface) (r iface) { tab := i.tab if tab == nil { // explicit conversions require non-nil interface value. panic(\u0026TypeAssertionError{nil, nil, \u0026inter.typ, \"\"}) } if tab.inter == inter { r.tab = tab r.data = i.data return } r.tab = getitab(inter, tab._type, false) r.data = i.data return } 上述代码逻辑很简单，如果 iface 中的 itab.inter 和第一个入参 *interfacetype 相同，说明类型相同，直接返回入参 iface 的相同类型，布尔值为 true；如果 iface 中的 itab.inter 和第一个入参 *interfacetype 不相同，则重新根据 *interfacetype 和 iface.tab 去构造 tab。构造的过程会查找 itabTable。如果类型不匹配，或者不是属于同一个 interface 类型，都会失败。getitab() 方法第三个参数是 canfail，这里传入了 true，表示构建 *itab 允许失败，失败以后返回 nil。 差异：如果我们断言的类型是具体类型，编译器会直接构造出iface，不会去调用已经在runtime/iface.go实现好的断言方法。如果我们断言的类型是接口类型，将会去调用相应的断言方法进行判断。 小结：非空接口类型断言的实质是 iface 中 *itab 的对比。*itab 匹配成功会在内存中组装返回值。匹配失败直接清空寄存器，返回默认值。 ","date":"2021-04-18","objectID":"https://asong2020.github.io/interface%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:3:2","tags":["关键字"],"title":"Go语言中interface的类型断言实现原理及性能分析","uri":"https://asong2020.github.io/interface%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["Go源码"],"content":"类型断言的性能损耗 前面我们已经分析了断言的底层原理，下面我们来看一下不同场景下进行断言的代价。 针对不同的场景可以写出测试文件如下（截取了部分代码，全部代码获取戳这里）: var dst int64 // 空接口类型直接类型断言具体的类型 func Benchmark_efaceToType(b *testing.B) { b.Run(\"efaceToType\", func(b *testing.B) { var ebread interface{} = int64(666) for i := 0; i \u003c b.N; i++ { dst = ebread.(int64) } }) } // 空接口类型使用TypeSwitch 只有部分类型 func Benchmark_efaceWithSwitchOnlyIntType(b *testing.B) { b.Run(\"efaceWithSwitchOnlyIntType\", func(b *testing.B) { var ebread interface{} = 666 for i := 0; i \u003c b.N; i++ { OnlyInt(ebread) } }) } // 空接口类型使用TypeSwitch 所有类型 func Benchmark_efaceWithSwitchAllType(b *testing.B) { b.Run(\"efaceWithSwitchAllType\", func(b *testing.B) { var ebread interface{} = 666 for i := 0; i \u003c b.N; i++ { Any(ebread) } }) } //直接使用类型转换 func Benchmark_TypeConversion(b *testing.B) { b.Run(\"typeConversion\", func(b *testing.B) { var ebread int32 = 666 for i := 0; i \u003c b.N; i++ { dst = int64(ebread) } }) } // 非空接口类型判断一个类型是否实现了该接口 两个方法 func Benchmark_ifaceToType(b *testing.B) { b.Run(\"ifaceToType\", func(b *testing.B) { var iface Basic = \u0026User{} for i := 0; i \u003c b.N; i++ { iface.GetName() iface.SetName(\"1\") } }) } // 非空接口类型判断一个类型是否实现了该接口 12个方法 func Benchmark_ifaceToTypeWithMoreMethod(b *testing.B) { b.Run(\"ifaceToTypeWithMoreMethod\", func(b *testing.B) { var iface MoreMethod = \u0026More{} for i := 0; i \u003c b.N; i++ { iface.Get() iface.Set() iface.One() iface.Two() iface.Three() iface.Four() iface.Five() iface.Six() iface.Seven() iface.Eight() iface.Nine() iface.Ten() } }) } // 直接调用方法 func Benchmark_DirectlyUseMethod(b *testing.B) { b.Run(\"directlyUseMethod\", func(b *testing.B) { m := \u0026More{ Name: \"asong\", } m.Get() }) } 运行结果： goos: darwin goarch: amd64 pkg: asong.cloud/Golang_Dream/code_demo/assert_test Benchmark_efaceToType/efaceToType-16 1000000000 0.507 ns/op Benchmark_efaceWithSwitchOnlyIntType/efaceWithSwitchOnlyIntType-16 384958000 3.00 ns/op Benchmark_efaceWithSwitchAllType/efaceWithSwitchAllType-16 351172759 3.33 ns/op Benchmark_TypeConversion/typeConversion-16 1000000000 0.473 ns/op Benchmark_ifaceToType/ifaceToType-16 355683139 3.38 ns/op Benchmark_ifaceToTypeWithMoreMethod/ifaceToTypeWithMoreMethod-16 85421563 12.8 ns/op Benchmark_DirectlyUseMethod/directlyUseMethod-16 1000000000 0.000000 ns/op PASS ok asong.cloud/Golang_Dream/code_demo/assert_test 7.797s 从结果我们可以分析一下： 空接口类型的类型断言代价并不高，与直接类型转换几乎没有性能差异 空接口类型使用type switch进行类型断言时，随着case的增多性能会直线下降 非空接口类型进行类型断言时，随着接口中方法的增多，性能会直线下降 直接进行方法调用要比非接口类型进行类型断言要高效很多 好啦，现在我们也知道怎样使用类型断言能提高性能啦，又可以和同事吹水一手啦。 ","date":"2021-04-18","objectID":"https://asong2020.github.io/interface%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:4:0","tags":["关键字"],"title":"Go语言中interface的类型断言实现原理及性能分析","uri":"https://asong2020.github.io/interface%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["Go源码"],"content":"总结 好啦，本文到这里就已经接近尾声了，在最后做一个小小的总结： 空接口类型断言实现流程：空接口类型断言实质是将eface中_type与要匹配的类型进行对比，匹配成功在内存中组装返回值，匹配失败直接清空寄存器，返回默认值。 非空接口类型断言的实质是 iface 中 *itab 的对比。*itab 匹配成功会在内存中组装返回值。匹配失败直接清空寄存器，返回默认值 泛型是在编译期做的事情，使用类型断言会消耗一点性能，类型断言使用方式不同，带来的性能损耗也不同，具体请看上面的章节。 文中代码已上传github：https://github.com/asong2020/Golang_Dream/tree/master/code_demo/assert_test，欢迎star 好啦，这篇文章就到这里啦，素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！ 创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：加我vx拉你入群，或者公众号获取入群二维码 结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。 我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。 翻译了一份Machinery中文文档，会定期进行维护，有需要的小伙伴们后台回复[machinery]即可获取。 **我是asong，一名普普通通的程序猿，让我们一起慢慢变强吧。欢迎各位的关注，我们下期见~~~** 推荐往期文章： Go看源码必会知识之unsafe包 源码剖析panic与recover，看不懂你打我好了！ 详解并发编程基础之原子操作(atomic包) 详解defer实现机制 空结构体引发的大型打脸现场 Leaf—Segment分布式ID生成系统（Golang实现版本） 十张动图带你搞懂排序算法(附go实现代码) go参数传递类型 手把手教姐姐写消息队列 常见面试题之缓存雪崩、缓存穿透、缓存击穿 详解Context包，看这一篇就够了！！！ 面试官：你能用Go写段代码判断当前系统的存储方式吗? 如何平滑切换线上Elasticsearch索引 ","date":"2021-04-18","objectID":"https://asong2020.github.io/interface%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:5:0","tags":["关键字"],"title":"Go语言中interface的类型断言实现原理及性能分析","uri":"https://asong2020.github.io/interface%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["架构设计杂谈"],"content":"前言 哈喽，大家好，我是asong，今天与大家聊一聊如何平滑切换线上的ES索引。使用过ES的朋友们都知道，修改索引真的是一件费时又费力的工作，所以我们应该在创建索引的时候就尽量设计好索引能够满足需求，当然这几乎是不可能的，毕竟存在着万恶的产品经理，所以掌握\"平滑切换线上的ES索引\"就很必要，接下来我们就来看一看如何实现！ ","date":"2021-04-10","objectID":"https://asong2020.github.io/%E5%A6%82%E4%BD%95%E5%B9%B3%E6%BB%91%E5%88%87%E6%8D%A2%E7%BA%BF%E4%B8%8A%E7%9A%84es%E7%B4%A2%E5%BC%95/:1:0","tags":["ElasticSearch"],"title":"如何平滑切换线上的ElasticSearch索引","uri":"https://asong2020.github.io/%E5%A6%82%E4%BD%95%E5%B9%B3%E6%BB%91%E5%88%87%E6%8D%A2%E7%BA%BF%E4%B8%8A%E7%9A%84es%E7%B4%A2%E5%BC%95/"},{"categories":["架构设计杂谈"],"content":"前置条件 能够平滑切换线上的ES索引需要有两个先决条件，只有满足了这两个条件才能去执行接下来的平滑切换操作，否则一切操作都是白费。 ","date":"2021-04-10","objectID":"https://asong2020.github.io/%E5%A6%82%E4%BD%95%E5%B9%B3%E6%BB%91%E5%88%87%E6%8D%A2%E7%BA%BF%E4%B8%8A%E7%9A%84es%E7%B4%A2%E5%BC%95/:2:0","tags":["ElasticSearch"],"title":"如何平滑切换线上的ElasticSearch索引","uri":"https://asong2020.github.io/%E5%A6%82%E4%BD%95%E5%B9%B3%E6%BB%91%E5%88%87%E6%8D%A2%E7%BA%BF%E4%B8%8A%E7%9A%84es%E7%B4%A2%E5%BC%95/"},{"categories":["架构设计杂谈"],"content":"前置条件之使用别名访问索引 重建索引的问题是必须更新应用中的索引名称，索引别名就是用来解决这个问题的。索引别名就像一个快捷方式或软连接，可以指向一个或多个索引，也可以给任何一个需要索引名的API来使用。别名 带给我们极大的灵活性，允许我们做下面这些： 在运行的集群中可以无缝的从一个索引切换到另一个索引 给多个索引分组 给索引的一个子集创建 视图 索引与索引别名的关系，我们画个图来说一下： 上图中user_index就是索引别名，user_index_v1、user_index_v2、user_index_v3分别是三个索引，这里索引别名user_index与user_index_v1进行了关联，所以我们搜索的时候使用索引别名，也就是去索引user_index_v1上查询。假设现在我们不想使用索引user_index_v1了，想使用索引user_index_v2，那么直接使用_aliases操作执行原子操作(后面介绍具体使用)，将索引别名user_index与索引user_index_v2进行关联，现在使用索引别名user_index搜索的就是索引user_index_v2的数据了。 ","date":"2021-04-10","objectID":"https://asong2020.github.io/%E5%A6%82%E4%BD%95%E5%B9%B3%E6%BB%91%E5%88%87%E6%8D%A2%E7%BA%BF%E4%B8%8A%E7%9A%84es%E7%B4%A2%E5%BC%95/:2:1","tags":["ElasticSearch"],"title":"如何平滑切换线上的ElasticSearch索引","uri":"https://asong2020.github.io/%E5%A6%82%E4%BD%95%E5%B9%B3%E6%BB%91%E5%88%87%E6%8D%A2%E7%BA%BF%E4%B8%8A%E7%9A%84es%E7%B4%A2%E5%BC%95/"},{"categories":["架构设计杂谈"],"content":"前置条件之足够空间 既然要重建ES索引，就一定保证你有足够的空间存储数据，可以使用如下指令查看ES每个节点的可用磁盘空间： curl http://localhost:9200/_cat/allocation\\?v 获得结果如下： ","date":"2021-04-10","objectID":"https://asong2020.github.io/%E5%A6%82%E4%BD%95%E5%B9%B3%E6%BB%91%E5%88%87%E6%8D%A2%E7%BA%BF%E4%B8%8A%E7%9A%84es%E7%B4%A2%E5%BC%95/:2:2","tags":["ElasticSearch"],"title":"如何平滑切换线上的ElasticSearch索引","uri":"https://asong2020.github.io/%E5%A6%82%E4%BD%95%E5%B9%B3%E6%BB%91%E5%88%87%E6%8D%A2%E7%BA%BF%E4%B8%8A%E7%9A%84es%E7%B4%A2%E5%BC%95/"},{"categories":["架构设计杂谈"],"content":"如何平滑切换 因为大家使用的ES场景不同，所以平滑切换的步骤会稍有偏差，但是都离不开这几个步骤： 创建新索引 同步数据/数据迁移到新索引 切换索引 先介绍一下数据迁移和切换索引使用什么指令操作： 数据迁移 使用ES中提供的reindex api就可以将数据copy到新索引中，比如： curl --location --request POST 'http://localhost:9200/_reindex' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"conflicts\": \"proceed\", \"source\": { \"index\": \"user_index_v1\" }, \"dest\": { \"index\": \"user_index_v2\", \"op_type\": \"create\", \"version_type\": \"external\" } }' 介绍一下上面几个字段的意义： \"source\":{\"index\": \"user_index_v1\"}：这里代表我们要迁移数据的源索引； \"dest\":{\"index\": \"user_index_v2\"}：这里代表我们要迁移的目标索引； \"conflicts\": \"proceed\"：默认情况下，版本冲突会导致_reindex操作终止，可以设置这个字段使该请求遇到冲突时不会终止，而是统计冲突数量； \"version_type\": \"extrenal\"：这个字段介绍起来比较复杂，且听我细细道来。_reindex指令会生成源索引的快照，它的目标索引必须是一个不同的索引[新索引]，以便避免版本冲突。如果不设置version_type字段，默认为internal，ES会直接将文档转存储到目标索引中(dest index)，直接覆盖任何具有相同类型和id的document，不会产生版本冲突。如果把version_type设置为extertral，那么ES会从源索引(source index)中读取version字段，当遇到具有相同类型和id的document时，只会保留new version，即最新的version对应的数据。此时可能会有冲突产生，比如当把op_tpye设置为create，对于产生的冲突现象，返回体中的 failures 会携带冲突的数据信息【类似详细的日志可以查看】。 op_type：op_type 参数控制着写入数据的冲突处理方式，如果把 op_type 设置为 create【默认值】，在 _reindex API 中，表示写入时只在 dest index 中添加不存在的 doucment，如果相同的 document 已经存在，则会报 version confilct 的错误，那么索引操作就会失败。【这种方式与使用 _create API 时效果一致】。 更多_redinx api使用方法可以移步官方文档学习：https://www.elastic.co/guide/en/elasticsearch/reference/5.6/docs-reindex.html 上面只是举一个简单的例子，具体要在数据迁移中使用哪些参数需要根据场景而定。 什么时候可以选择数据迁移： 当我们新创建的索引只改变了mapping结构时，例如：删除字段，更新字段的类型，这种场景就可以直接使用_reindex进行数据迁移； 新创建的索引中添加了新字段，但是新的字段都是由老的字段计算得到的，这种情况，也可以使用_reindex进行数据迁移，api中使用script参数，编写你的脚本即可。 注意：使用_redindex接口时要注意一个问题，接口会在reindex结束后返回，接口超时控制只有30s，如果reindex时间过长，建议加上wait_for_completion=false参数，这样redindex就变成异步任务，返回的是taskID，查看进度可以通过 _tasks API 进行查看。 切换索引 ES中两种方式管理别名：_alias用于单个操作，_aliases用于执行多个原子级操作。 因为我们这里要做的是切换索引，主要分为两个步骤： 移除当前索引与索引别名的关联 将新建的索引与索引别名进行关联 所以我们可以选择_alisases执行原子操作： curl --location --request POST 'http://localhost:9200/_aliases' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"actions\": [ {\"remove\": {\"index\": \"user_index_v2\", \"alias\": \"user_index\"}}, { \"add\": {\"index\": \"user_index_v1\", \"alias\": \"user_index\"}} ] }' ","date":"2021-04-10","objectID":"https://asong2020.github.io/%E5%A6%82%E4%BD%95%E5%B9%B3%E6%BB%91%E5%88%87%E6%8D%A2%E7%BA%BF%E4%B8%8A%E7%9A%84es%E7%B4%A2%E5%BC%95/:3:0","tags":["ElasticSearch"],"title":"如何平滑切换线上的ElasticSearch索引","uri":"https://asong2020.github.io/%E5%A6%82%E4%BD%95%E5%B9%B3%E6%BB%91%E5%88%87%E6%8D%A2%E7%BA%BF%E4%B8%8A%E7%9A%84es%E7%B4%A2%E5%BC%95/"},{"categories":["架构设计杂谈"],"content":"举例子 假设我们有一个user_index_v1，他的mapping结构如下； { \"mappings\":{ \"properties\":{ \"id\":{ \"type\":\"byte\" }, \"Name\":{ \"type\":\"text\" }, \"Age\":{ \"type\":\"byte\" } } } } 现在这个v1索引中，我们的id字段使用的byte类型，显然范围是比较小的，随着数据量增多，id数值的增大，该字段已经不能满足存储需求了，所以需要把它换成long类型，因此可以创建v2索引： { \"mappings\":{ \"properties\":{ \"id\":{ \"type\":\"long\" }, \"Name\":{ \"type\":\"text\" }, \"Age\":{ \"type\":\"byte\" } } } } 现在我们就来考虑一下，如何平滑的进行索引切换。这里假设我们ES中数据同步采用的消息队列推送完成的，所以在切换索引时要考虑数据损失的问题。 这里我们可以列举几种方案如下： 方案一：直接创建v2索引，使用_aliases切换索引，进行数据迁移，优点是直接切换别名和索引的关联，简单方便，缺点是出现问题回退到旧索引，会有数据损失，直接切换到v2索引会导致服务在数据没有迁移完之前不可用。 方案二：创建v2索引，添加v2索引与别名的关联，进行数据迁移，_alias操作解除别名和v2索引的关联。优点是不会造成服务不可用，缺点是在解除别名和v1关联之前，一个别名关联两个索引，单索引操作无法执行，只能搜索，搜索也会出现数据重复，并且也会造成数据损失。 方案三：创建v2索引，添加v2索引与别名的关联，修改代码写入操作使用v2索引，搜索操作使用别名索引，进行数据迁移，解除v1索引与别名的关联，优点是搜索和写入操作分开了，缺点是回退需要修改代码，并且会出现数据损失，如果v2索引不可用了，不能立刻回退索引。 方案四：创建v2索引，进行数据迁移，然后切换索引；优点是同步数据到v2期间搜索功能正常使用，回退无数据损失；缺点是会造成数据丢失。 方案五：创建v2索引，添加两个别名索引read和write，添加别名read和v1索引、v2索引的关联，添加别名write和v2索引的关联，进行数据迁移，解除别名read和v1索引的关联；优点是搜索和写入分开了，更新索引时只需要创建新索引，数据同步完成后，解除别名read和旧索引关联即可；缺点是数据迁移完成之前，搜索结果会出现重复，回退到旧索引，会有数据损失。 这里总共列举了5种方案，我也不推荐具体使用那个方案比较好，各有利弊，大家可以根据自己的业务场景来进行选择。 这里以选择方案四为例子，给出我的脚本数据，作为样例； 创建user_index_v2索引： #!/bin/bash url=$1 index=$2 echo `curl --location --request GET ${url}/${index}` echo `curl --location --request PUT ${url}/${index} \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"mappings\":{ \"properties\":{ \"id\":{ \"type\":\"long\" }, \"Name\":{ \"type\":\"text\" }, \"Age\":{ \"type\":\"byte\" } } } }'` echo `curl --location --request GET ${url}/${index}` 运行指令：./create_index.sh http://localhost:9200 user_index_v2 进行数据迁移(数据量比较大时建议分批and异步处理) #!/bin/bash url=$1 echo `curl --location --request POST ${url}/'_reindex?wait_for_completion=false' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"conflicts\": \"proceed\", \"source\": { \"index\": \"user_index_v1\" }, \"dest\": { \"index\": \"user_index_v2\", \"op_type\": \"create\", \"version_type\": \"external\" } }'` 运行指令：./reindex.sh http://localhost:9200 切换索引 #!/bin/bash url=$1 aliasIndex=$2 oldIndex=$3 newIndex=$4 echo `curl --location --request GET ${url}/${aliasIndex}` echo `curl --location --request POST ${url}/_aliases --header 'Content-Type: application/json' --data-raw '{\"actions\": [{\"remove\": {\"index\": \"'$oldIndex'\", \"alias\": \"'$aliasIndex'\"}},{ \"add\": {\"index\": \"'$newIndex'\", \"alias\": \"'$aliasIndex'\"}}]}'` echo `curl --location --request GET ${url}/${aliasIndex}` 运行指令：./aliases.sh http://localhost:9200 user_index user_index_v1 user_index_v2 ","date":"2021-04-10","objectID":"https://asong2020.github.io/%E5%A6%82%E4%BD%95%E5%B9%B3%E6%BB%91%E5%88%87%E6%8D%A2%E7%BA%BF%E4%B8%8A%E7%9A%84es%E7%B4%A2%E5%BC%95/:3:1","tags":["ElasticSearch"],"title":"如何平滑切换线上的ElasticSearch索引","uri":"https://asong2020.github.io/%E5%A6%82%E4%BD%95%E5%B9%B3%E6%BB%91%E5%88%87%E6%8D%A2%E7%BA%BF%E4%B8%8A%E7%9A%84es%E7%B4%A2%E5%BC%95/"},{"categories":["架构设计杂谈"],"content":"总结 本文例举了几种平滑切换ES索引的方案，可以看出修改索引真不是一件容易的事情，要考虑的事情比较多，所以最好在第一次创建索引的时候就多考虑一下以后的使用场景，确定好字段和类型，这样就可以避免重建ES索引。当然随着产品的需求变更，重建ES索引也是不可避免的，上面几种仅供大家参考，根据自己的场景去选择就好啦。 好啦，这篇文章就到这里啦，素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！ 创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：加我vx拉你入群，或者公众号获取入群二维码 结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。 我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。 翻译了一份Machinery中文文档，会定期进行维护，有需要的小伙伴们后台回复[machinery]即可获取。 **我是asong，一名普普通通的程序猿，让我们一起慢慢变强吧。欢迎各位的关注，我们下期见~~~** 推荐往期文章： Go看源码必会知识之unsafe包 源码剖析panic与recover，看不懂你打我好了！ 详解并发编程基础之原子操作(atomic包) 详解defer实现机制 空结构体引发的大型打脸现场 Leaf—Segment分布式ID生成系统（Golang实现版本） 十张动图带你搞懂排序算法(附go实现代码) go参数传递类型 手把手教姐姐写消息队列 常见面试题之缓存雪崩、缓存穿透、缓存击穿 详解Context包，看这一篇就够了！！！ 面试官：你能用Go写段代码判断当前系统的存储方式吗? ","date":"2021-04-10","objectID":"https://asong2020.github.io/%E5%A6%82%E4%BD%95%E5%B9%B3%E6%BB%91%E5%88%87%E6%8D%A2%E7%BA%BF%E4%B8%8A%E7%9A%84es%E7%B4%A2%E5%BC%95/:4:0","tags":["ElasticSearch"],"title":"如何平滑切换线上的ElasticSearch索引","uri":"https://asong2020.github.io/%E5%A6%82%E4%BD%95%E5%B9%B3%E6%BB%91%E5%88%87%E6%8D%A2%E7%BA%BF%E4%B8%8A%E7%9A%84es%E7%B4%A2%E5%BC%95/"},{"categories":["Go源码"],"content":"前言 有看源码的朋友应该会发现，Go标准库中大量使用了unsafe.pointer，要想更好的理解源码实现，就要知道unsafe.pointer到底是什么？所以今天就与大家来聊一聊unsafe包。 ","date":"2021-03-10","objectID":"https://asong2020.github.io/%E6%A0%87%E5%87%86%E5%BA%93unsafe%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:1:0","tags":["unsafe"],"title":"Go语言标准库unsafe包源码解析","uri":"https://asong2020.github.io/%E6%A0%87%E5%87%86%E5%BA%93unsafe%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"什么是unsafe 众所周知，Go语言被设计成一门强类型的静态语言，那么他的类型就不能改变了，静态也是意味着类型检查在运行前就做了。所以在Go语言中是不允许两个指针类型进行转换的，使用过C语言的朋友应该知道这在C语言中是可以实现的，Go中不允许这么使用是处于安全考虑，毕竟强制转型会引起各种各样的麻烦，有时这些麻烦很容易被察觉，有时他们却又隐藏极深，难以察觉。大多数读者可能不明白为什么类型转换是不安全的，这里用C语言举一个简单的例子： int main(){ double pi = 3.1415926; double *pv = \u0026pi; void *temp = pd; int *p = temp; } 在标准C语言中，任何非void类型的指针都可以和void类型的指针相互指派，也可以通过void类型指针作为中介，实现不同类型的指针间接相互转换。上面示例中，指针pv指向的空间本是一个双精度数据，占8个字节，但是经过转换后，p指向的是一个4字节的int类型。这种发生内存截断的设计缺陷会在转换后进行内存访问是存在安全隐患。我想这就是Go语言被设计成强类型语言的原因之一吧。 虽然类型转换是不安全的，但是在一些特殊场景下，使用了它，可以打破Go的类型和内存安全机制，可以绕过类型系统低效，提高运行效率。所以Go标准库中提供了一个unsafe包，之所以叫这个名字，就是不推荐大家使用，但是不是不能用，如果你掌握的特别好，还是可以实践的。 ","date":"2021-03-10","objectID":"https://asong2020.github.io/%E6%A0%87%E5%87%86%E5%BA%93unsafe%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:2:0","tags":["unsafe"],"title":"Go语言标准库unsafe包源码解析","uri":"https://asong2020.github.io/%E6%A0%87%E5%87%86%E5%BA%93unsafe%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"unsafe 实现原理 在使用之前我们先来看一下unsafe的源码部分，标准库unsafe包中只提供了3种方法，分别是: func Sizeof(x ArbitraryType) uintptr func Offsetof(x ArbitraryType) uintptr func Alignof(x ArbitraryType) uintptr Sizeof(x ArbitrayType)方法主要作用是用返回类型x所占据的字节数，但并不包含x所指向的内容的大小，与C语言标准库中的Sizeof()方法功能一样，比如在32位机器上，一个指针返回大小就是4字节。 Offsetof(x ArbitraryType)方法主要作用是返回结构体成员在内存中的位置离结构体起始处(结构体的第一个字段的偏移量都是0)的字节数，即偏移量，我们在注释中看一看到其入参必须是一个结构体，其返回值是一个常量。 Alignof(x ArbitratyType)的主要作用是返回一个类型的对齐值，也可以叫做对齐系数或者对齐倍数。对齐值是一个和内存对齐有关的值，合理的内存对齐可以提高内存读写的性能。一般对齐值是2^n，最大不会超过8(受内存对齐影响).获取对齐值还可以使用反射包的函数，也就是说：unsafe.Alignof(x)等价于reflect.TypeOf(x).Align()。对于任意类型的变量x，unsafe.Alignof(x)至少为1。对于struct结构体类型的变量x，计算x每一个字段f的unsafe.Alignof(x，f)，unsafe.Alignof(x)等于其中的最大值。对于array数组类型的变量x，unsafe.Alignof(x)等于构成数组的元素类型的对齐倍数。没有任何字段的空struct{}和没有任何元素的array占据的内存空间大小为0，不同大小为0的变量可能指向同一块地址。 细心的朋友会发发现这三个方法返回的都是uintptr类型，这个目的就是可以和unsafe.poniter类型相互转换，因为*T是不能计算偏移量的，也不能进行计算，但是uintptr是可以的，所以可以使用uintptr类型进行计算，这样就可以可以访问特定的内存了，达到对不同的内存读写的目的。三个方法的入参都是ArbitraryType类型，代表着任意类型的意思，同时还提供了一个Pointer指针类型，即像void *一样的通用型指针。 type ArbitraryType int type Pointer *ArbitraryType // uintptr 是一个整数类型，它足够大，可以存储 type uintptr uintptr 上面说了这么多，可能会有点懵，在这里对三种指针类型做一个总结： *T：普通类型指针类型，用于传递对象地址，不能进行指针运算。 unsafe.poniter：通用指针类型，用于转换不同类型的指针，不能进行指针运算，不能读取内存存储的值(需转换到某一类型的普通指针) uintptr：用于指针运算，GC不把uintptr当指针，uintptr无法持有对象。uintptr类型的目标会被回收。 三者关系就是：unsafe.Pointer是桥梁，可以让任意类型的指针实现相互转换，也可以将任意类型的指针转换为uintptr进行指针运算，也就说uintptr是用来与unsafe.Pointer打配合，用于指针运算。画个图表示一下： 基本原理就说到这里啦，接下来我们一起来看看如何使用~ ","date":"2021-03-10","objectID":"https://asong2020.github.io/%E6%A0%87%E5%87%86%E5%BA%93unsafe%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:3:0","tags":["unsafe"],"title":"Go语言标准库unsafe包源码解析","uri":"https://asong2020.github.io/%E6%A0%87%E5%87%86%E5%BA%93unsafe%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"unsafe.Pointer基本使用 我们在上一篇分析atomic.Value源码时，看到atomic/value.go中定义了一个ifaceWords结构，其中typ和data字段类型就是unsafe.Poniter，这里使用unsafe.Poniter类型的原因是传入的值就是interface{}类型，使用unsafe.Pointer强转成ifaceWords类型，这样可以把类型和值都保存了下来，方便后面的写入类型检查。截取部分代码如下： // ifaceWords is interface{} internal representation. type ifaceWords struct { typ unsafe.Pointer data unsafe.Pointer } // Load returns the value set by the most recent Store. // It returns nil if there has been no call to Store for this Value. func (v *Value) Load() (x interface{}) { vp := (*ifaceWords)(unsafe.Pointer(v)) for { typ := LoadPointer(\u0026vp.typ) // 读取已经存在值的类型 /** ..... 中间省略 **/ // First store completed. Check type and overwrite data. if typ != xp.typ { //当前类型与要存入的类型做对比 panic(\"sync/atomic: store of inconsistently typed value into Value\") } } 上面就是源码中使用unsafe.Pointer的一个例子，有一天当你准备读源码时，unsafe.pointer的使用到处可见。好啦，接下来我们写一个简单的例子，看看unsafe.Pointer是如何使用的。 func main() { number := 5 pointer := \u0026number fmt.Printf(\"number:addr:%p, value:%d\\n\",pointer,*pointer) float32Number := (*float32)(unsafe.Pointer(pointer)) *float32Number = *float32Number + 3 fmt.Printf(\"float64:addr:%p, value:%f\\n\",float32Number,*float32Number) } 运行结果： number:addr:0xc000018090, value:5 float64:addr:0xc000018090, value:3.000000 由运行可知使用unsafe.Pointer强制类型转换后指针指向的地址是没有改变，只是类型发生了改变。这个例子本身没什么意义，正常项目中也不会这样使用。 总结一下基本使用：先把*T类型转换成unsafe.Pointer类型，然后在进行强制转换转成你需要的指针类型即可。 ","date":"2021-03-10","objectID":"https://asong2020.github.io/%E6%A0%87%E5%87%86%E5%BA%93unsafe%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:4:0","tags":["unsafe"],"title":"Go语言标准库unsafe包源码解析","uri":"https://asong2020.github.io/%E6%A0%87%E5%87%86%E5%BA%93unsafe%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"Sizeof、Alignof、Offsetof三个函数的基本使用 先看一个例子： type User struct { Name string Age uint32 Gender bool // 男:true 女：false 就是举个例子别吐槽我这么用。。。。 } func func_example() { // sizeof fmt.Println(unsafe.Sizeof(true)) fmt.Println(unsafe.Sizeof(int8(0))) fmt.Println(unsafe.Sizeof(int16(10))) fmt.Println(unsafe.Sizeof(int(10))) fmt.Println(unsafe.Sizeof(int32(190))) fmt.Println(unsafe.Sizeof(\"asong\")) fmt.Println(unsafe.Sizeof([]int{1,3,4})) // Offsetof user := User{Name: \"Asong\", Age: 23,Gender: true} userNamePointer := unsafe.Pointer(\u0026user) nNamePointer := (*string)(unsafe.Pointer(userNamePointer)) *nNamePointer = \"Golang梦工厂\" nAgePointer := (*uint32)(unsafe.Pointer(uintptr(userNamePointer) + unsafe.Offsetof(user.Age))) *nAgePointer = 25 nGender := (*bool)(unsafe.Pointer(uintptr(userNamePointer)+unsafe.Offsetof(user.Gender))) *nGender = false fmt.Printf(\"u.Name: %s, u.Age: %d, u.Gender: %v\\n\", user.Name, user.Age,user.Gender) // Alignof var b bool var i8 int8 var i16 int16 var i64 int64 var f32 float32 var s string var m map[string]string var p *int32 fmt.Println(unsafe.Alignof(b)) fmt.Println(unsafe.Alignof(i8)) fmt.Println(unsafe.Alignof(i16)) fmt.Println(unsafe.Alignof(i64)) fmt.Println(unsafe.Alignof(f32)) fmt.Println(unsafe.Alignof(s)) fmt.Println(unsafe.Alignof(m)) fmt.Println(unsafe.Alignof(p)) } 为了省事，把三个函数的使用示例放到了一起，首先看sizeof方法，我们可以知道各个类型所占字节大小，这里重点说一下int类型，Go语言中的int类型的具体大小是跟机器的 CPU 位数相关的。如果 CPU 是 32 位的，那么int就占4字节，如果 CPU 是64位的，那么 int 就占 8 字节，这里我的电脑是64位的，所以结果就是8字节。 然后我们在看Offsetof函数，我想要修改结构体中成员变量，第一个成员变量是不需要进行偏移量计算的，直接取出指针后转换为unsafe.pointer，在强制给他转换成字符串类型的指针值即可。如果要修改其他成员变量，需要进行偏移量计算，才可以对其内存地址修改，所以Offsetof方法就可返回成员变量在结构体中的偏移量，也就是返回结构体初始位置到成员变量之间的字节数。看代码时大家应该要住uintptr的使用，不可以用一个临时变量存储uintptr类型，前面我们提到过用于指针运算，GC不把uintptr当指针，uintptr无法持有对象。uintptr类型的目标会被回收，所以你不知道他什么时候会被GC掉，那样接下来的内存操作会发生什么样的错误，咱也不知道。比如这样一个例子： // 切记不要这样使用 p1 := uintptr(userNamePointer) nAgePointer := (*uint32)(unsafe.Pointer(p1 + unsafe.Offsetof(user.Age))) 最后看一下Alignof函数，主要是获取变量的对齐值，除了int、uintptr这些依赖CPU位数的类型，基本类型的对齐值都是固定的，结构体中对齐值取他的成员对齐值的最大值，结构体的对齐涉及到内存对齐，我们在下面详细介绍。 ","date":"2021-03-10","objectID":"https://asong2020.github.io/%E6%A0%87%E5%87%86%E5%BA%93unsafe%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:5:0","tags":["unsafe"],"title":"Go语言标准库unsafe包源码解析","uri":"https://asong2020.github.io/%E6%A0%87%E5%87%86%E5%BA%93unsafe%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"经典应用：string与[]byte的相互转换 实现string与byte的转换，正常情况下，我们可能会写出这样的标准转换： // string to []byte str1 := \"Golang梦工厂\" by := []byte(s1) // []byte to string str2 := string(by) 使用这种方式进行转换都会涉及底层数值的拷贝，所以想要实现零拷贝，我们可以使用unsafe.Pointer来实现，通过强转换直接完成指针的指向，从而使string和[]byte指向同一个底层数据。在reflect包中有·string和slice对应的结构体，他们的分别是： type StringHeader struct { Data uintptr Len int } type SliceHeader struct { Data uintptr Len int Cap int } StringHeader代表的是string运行时的表现形式(SliceHeader同理)，通过对比string和slice运行时的表达可以看出，他们只有一个Cap字段不同，所以他们的内存布局是对齐的，所以可以通过unsafe.Pointer进行转换，因为可以写出如下代码： func stringToByte(s string) []byte { header := (*reflect.StringHeader)(unsafe.Pointer(\u0026s)) newHeader := reflect.SliceHeader{ Data: header.Data, Len: header.Len, Cap: header.Len, } return *(*[]byte)(unsafe.Pointer(\u0026newHeader)) } func bytesToString(b []byte) string{ header := (*reflect.SliceHeader)(unsafe.Pointer(\u0026b)) newHeader := reflect.StringHeader{ Data: header.Data, Len: header.Len, } return *(*string)(unsafe.Pointer(\u0026newHeader)) } 上面的代码我们通过重新构造slice header和string header完成了类型转换，其实[]byte转换成string可以省略掉自己构造StringHeader的方式，直接使用强转就可以，因为string的底层也是[]byte，强转会自动构造，省略后的代码如下： func bytesToString(b []byte) string { return *(* string)(unsafe.Pointer(\u0026b)) } 虽然这种方式更高效率，但是不推荐大家使用，前面也提高到了，这要是不安全的，使用当不当会出现极大的隐患，一些严重的情况recover也不能捕获。 ","date":"2021-03-10","objectID":"https://asong2020.github.io/%E6%A0%87%E5%87%86%E5%BA%93unsafe%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:6:0","tags":["unsafe"],"title":"Go语言标准库unsafe包源码解析","uri":"https://asong2020.github.io/%E6%A0%87%E5%87%86%E5%BA%93unsafe%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"内存对齐 现在计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就对齐。 对齐的作用和原因：CPU访问内存时，并不是逐个字节访问，而是以字长（word size)单位访问。比如32位的CPU，字长为4字节，那么CPU访问内存的单位也是4字节。这样设计可以减少CPU访问内存的次数，加大CPU访问内存的吞吐量。假设我们需要读取8个字节的数据，一次读取4个字节那么就只需读取2次就可以。内存对齐对实现变量的原子性操作也是有好处的，每次内存访问都是原子的，如果变量的大小不超过字长，那么内存对齐后，对该变量的访问就是原子的，这个特性在并发场景下至关重要。 我们来看这样一个例子： // 64位平台，对齐参数是8 type User1 struct { A int32 // 4 B []int32 // 24 C string // 16 D bool // 1 } type User2 struct { B []int32 A int32 D bool C string } type User3 struct { D bool B []int32 A int32 C string } func main() { var u1 User1 var u2 User2 var u3 User3 fmt.Println(\"u1 size is \",unsafe.Sizeof(u1)) fmt.Println(\"u2 size is \",unsafe.Sizeof(u2)) fmt.Println(\"u3 size is \",unsafe.Sizeof(u3)) } // 运行结果 MAC: 64位 u1 size is 56 u2 size is 48 u3 size is 56 从结果可以看出，字段放置不同的顺序，占用内存也不一样，这就是因为内存对齐影响了struct的大小，所以有时候合理的字段可以减少内存的开销。下面我们就一起来分析一下内存对齐，首先要明白什么是内存对齐的规则，C语言的对齐规则与Go语言一样，所以C语言的对齐规则对Go同样适用： 对于结构的各个成员，第一个成员位于偏移为0的位置，结构体第一个成员的偏移量（offset）为0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。 除了结构成员需要对齐，结构本身也需要对齐，结构的长度必须是编译器默认的对齐长度和成员中最长类型中最小的数据大小的倍数对齐。 好啦，知道规则了，我们现在来分析一下上面的例子，根据我的mac使用的64位CPU,对齐参数是8来分析，int32、[]int32、string、bool对齐值分别是4、8、8、1，占用内存大小分别是4、24、16、1，我们先根据第一条对齐规则分析User1： 第一个字段类型是int32，对齐值是4，大小为4，所以放在内存布局中的第一位. 第二个字段类型是[]int32，对齐值是8，大小为24，所以他的内存偏移值必须是8的倍数，所以在当前user1中，就不能从第4位开始了，必须从第5位开始，也就偏移量为8。第4,5,6,7位由编译器进行填充，一般为0值，也称之为空洞。第9位到第32位为第二个字段B. 第三个字段类型是string，对齐值是8，大小为16，所以他的内存偏移值必须是8的倍数，因为user1前两个字段就已经排到了第32位，所以下一位的偏移量正好是32，正好是字段C的对齐值的倍数，不用填充，可以直接排列第三个字段，也就是从第32位到48位第三个字段C. 第三个字段类型是bool，对齐值是1，大小为1，所以他的内存偏移值必须是1的倍数，因为user1前两个字段就已经排到了第48位，所以下一位的偏移量正好是48。正好是字段D的对齐值的倍数，不用填充，可以直接排列到第四个字段，也就是从48到第49位是第三个字段D. 好了现在第一条内存对齐规则后，内存长度已经为49字节，我们开始使用内存的第2条规则进行对齐。根据第二条规则，默认对齐值是8，字段中最大类型程度是24，取最小的那一个，所以求出结构体的对齐值是8，我们目前的内存长度是49，不是8的倍数，所以需要补齐，所以最终的结果就是56，补了7位。 说了这么多，画个图看一下吧： 现在你们应该懂了吧，按照这个思路再去分析其他两个struct吧，这里就不再分析了。 对于内存对齐这里还有一最后需要注意的知识点，空struct不占用任何存储空间，空 struct{} 大小为 0，作为其他 struct 的字段时，一般不需要内存对齐。但是有一种情况除外：即当 struct{} 作为结构体最后一个字段时，需要内存对齐。因为如果有指针指向该字段, 返回的地址将在结构体之外，如果此指针一直存活不释放对应的内存，就会有内存泄露的问题（该内存不因结构体释放而释放）。来看一个例子： func main() { fmt.Println(unsafe.Sizeof(test1{})) // 8 fmt.Println(unsafe.Sizeof(test2{})) // 4 } type test1 struct { a int32 b struct{} } type test2 struct { a struct{} b int32 } 简单来说，对于任何占用0大小空间的类型，像struct {}或者[0]byte这些，如果该类型出现在结构体末尾，那么我们就假设它占用1个字节的大小。因此对于test1结构体，他看起来就是这样：` type test1 struct { a int32 // b struct{} b [1]byte } 因此在内存对齐时，最后结构体占用的字节就是8了。 重点要注意的问题：不要在结构体定义的最后添加零大小的类型 ","date":"2021-03-10","objectID":"https://asong2020.github.io/%E6%A0%87%E5%87%86%E5%BA%93unsafe%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:7:0","tags":["unsafe"],"title":"Go语言标准库unsafe包源码解析","uri":"https://asong2020.github.io/%E6%A0%87%E5%87%86%E5%BA%93unsafe%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"总结 好啦，终于又到文章的末尾了，我们来简单的总结一下，unsafe 包绕过了 Go 的类型系统，达到直接操作内存的目的，使用它有一定的风险性。但是在某些场景下，使用 unsafe 包提供的函数会提升代码的效率，Go 源码中也是大量使用 unsafe 包。 unsafe 包定义了 Pointer 和三个函数： type ArbitraryType int type Pointer *ArbitraryType func Sizeof(x ArbitraryType) uintptr func Offsetof(x ArbitraryType) uintptr func Alignof(x ArbitraryType) uintptr uintptr 可以和 unsafe.Pointer 进行相互转换，uintptr 可以进行数学运算。这样，通过 uintptr 和 unsafe.Pointer 的结合就解决了 Go 指针不能进行数学运算的限制。通过 unsafe 相关函数，可以获取结构体私有成员的地址，进而对其做进一步的读写操作，突破 Go 的类型安全限制。 最后我们又学习了内存对齐的知识，这样设计可以减少CPU访问内存的次数，加大CPU访问内存的吞吐量，所以结构体中字段合理的排序可以更节省内存，注意：不要在结构体定义的最后添加零大小的类型。 好啦，这篇文章就到这里啦，素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！ 创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：加我vx拉你入群，或者公众号获取入群二维码 结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。 我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。 翻译了一份Machinery中文文档，会定期进行维护，有需要的小伙伴们后台回复[machinery]即可获取。 **我是asong，一名普普通通的程序猿，让我们一起慢慢变强吧。欢迎各位的关注，我们下期见~~~** 推荐往期文章： machinery-go异步任务队列 源码剖析panic与recover，看不懂你打我好了！ 详解并发编程基础之原子操作(atomic包) 详解defer实现机制 真的理解interface了嘛 Leaf—Segment分布式ID生成系统（Golang实现版本） 十张动图带你搞懂排序算法(附go实现代码) go参数传递类型 手把手教姐姐写消息队列 常见面试题之缓存雪崩、缓存穿透、缓存击穿 详解Context包，看这一篇就够了！！！ 详解并发编程之sync.Once的实现(附上三道面试题) 面试官：go中for-range使用过吗？这几个问题你能解释一下原因吗 ","date":"2021-03-10","objectID":"https://asong2020.github.io/%E6%A0%87%E5%87%86%E5%BA%93unsafe%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:8:0","tags":["unsafe"],"title":"Go语言标准库unsafe包源码解析","uri":"https://asong2020.github.io/%E6%A0%87%E5%87%86%E5%BA%93unsafe%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"前言 哈喽，大家好，我是asong，这是我并发编程系列的第三篇文章，上一篇我们一起分析了sync.once的使用与实现，今天我们一起来看一看sync.WaitGroup的使用与实现. 快过年了，这是年前最后一篇推文了，待我积累一下，年后加大力度写干货，在这里先预祝大家新春快乐，身体健康，万事如意！ ","date":"2021-02-10","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:1:0","tags":["并发编程","sync包"],"title":"Go语言并发编程之sync.waitGroup的源码解析","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"什么是sync.WaitGroup 官方文档对sync.WatiGroup的描述是：一个waitGroup对象可以等待一组协程结束，也就等待一组goroutine返回。有了sync.Waitgroup我们可以将原本顺序执行的代码在多个Goroutine中并发执行，加快程序处理的速度。其实他与java中的CountdownLatch，阻塞等待所有任务完成之后再继续执行。我们来看官网给的一个例子，这个例子使用waitGroup阻塞主进程，并发获取多个URL，直到完成所有获取： package main import ( \"sync\" ) type httpPkg struct{} func (httpPkg) Get(url string) {} var http httpPkg func main() { var wg sync.WaitGroup var urls = []string{ \"http://www.golang.org/\", \"http://www.google.com/\", \"http://www.somestupidname.com/\", } for _, url := range urls { // Increment the WaitGroup counter. wg.Add(1) // Launch a goroutine to fetch the URL. go func(url string) { // Decrement the counter when the goroutine completes. defer wg.Done() // Fetch the URL. http.Get(url) }(url) } // Wait for all HTTP fetches to complete. wg.Wait() } 首先我们需要声明一个sync.WaitGroup对象，在主gorourine调用Add()方法设置要等待的goroutine数量，每一个Goroutine在运行结束时要调用Done()方法，同时使用Wait()方法进行阻塞直到所有的goroutine完成。 ","date":"2021-02-10","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:2:0","tags":["并发编程","sync包"],"title":"Go语言并发编程之sync.waitGroup的源码解析","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"为什么要用sync.waitGroup 我们在日常开发中为了提高接口响应时间，有一些场景需要在多个goroutine中做一些互不影响的业务，这样可以节省不少时间，但是需要协调多个goroutine，没有sync.WaitGroup的时候，我们可以使用通道来解决这个问题，我们把主Goroutine当成铜锣扛把子a song，把每一个Goroutine当成一个马仔，asong管理这些马仔，让这些马仔去收保护费，我今天派10个马仔去收保护费，每一个马仔收好了保护费就在账本上打一个✅，当所有马仔都收好了保护费，账本上就被打满了✅，活全被干完了，很出色，然后酒吧走起，浪一浪，全场的消费松公子买单，写成代码可以这样表示： func exampleImplWaitGroup() { done := make(chan struct{}) // 收10份保护费 count := 10 // 10个马仔 for i:=0;i \u003c count;i++{ go func(i int) { defer func() { done \u003c- struct {}{} }() fmt.Printf(\"马仔%d号收保护费\\n\",i) }(i) } for i:=0;i\u003c count;i++{ \u003c- done fmt.Printf(\"马仔%d号已经收完保护费\\n\",i) } fmt.Println(\"所有马仔已经干完活了，开始酒吧消费～\") } 虽然这样可以实现，但是我们每次使用都要保证主Goroutine最后从通道接收的次数需要与之前其他的Goroutine发送元素的次数相同，实现起来不够优雅，在这种场景下我们就可以选用sync.WaitGroup来帮助我们实现同步。 ","date":"2021-02-10","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:3:0","tags":["并发编程","sync包"],"title":"Go语言并发编程之sync.waitGroup的源码解析","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"源码剖析 前面我们已经知道sync.waitGroup的基本使用了，接下来我们就一起看看他是怎样实现的～，只有知其所以然，才能写出更健壮的代码。 Go version: 1.15.3 首先我们看一下sync.WaitGroup的结构： // A WaitGroup must not be copied after first use. type WaitGroup struct { noCopy noCopy // 64-bit value: high 32 bits are counter, low 32 bits are waiter count. // 64-bit atomic operations require 64-bit alignment, but 32-bit // compilers do not ensure it. So we allocate 12 bytes and then use // the aligned 8 bytes in them as state, and the other 4 as storage // for the sema. state1 [3]uint32 } 总共就有两个字段，nocopy是为了保证该结构不会被进行拷贝，这是一种保护机制，会在后面进行介绍；state1主要是存储着状态和信号量，这里使用的8字节对齐处理的方式很有意思，我先来一起看看这种处理。 ","date":"2021-02-10","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:4:0","tags":["并发编程","sync包"],"title":"Go语言并发编程之sync.waitGroup的源码解析","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"state1状态和信号量处理 state1这里总共被分配了12个字节，这里被设计了三种状态： 其中对齐的8个字节作为状态，高32位为计数的数量，低32位为等待的goroutine数量 其中的4个字节作为信号量存储 提供了(wg *WaitGroup) state() (statep *uint64, semap *uint32)帮助我们从state1字段中取出他的状态和信号量，为什么要这样设计呢？ 我们在分析atomic和Go看源码必会知识之unsafe包有说到过，64位原子操作需要64位对齐，但是32位编译器不能保证这一点，所以为了保证waitGroup在32位平台上使用的话，就必须保证在任何时候，64位操作不会报错。所以也就不能分成两个字段来写，考虑到字段顺序不同、平台不同，内存对齐也就不同。因此这里采用动态识别当前我们操作的64位数到底是不是在8字节对齐的位置上面，我们来分析一下state方法： // state returns pointers to the state and sema fields stored within wg.state1. func (wg *WaitGroup) state() (statep *uint64, semap *uint32) { if uintptr(unsafe.Pointer(\u0026wg.state1))%8 == 0 { return (*uint64)(unsafe.Pointer(\u0026wg.state1)), \u0026wg.state1[2] } else { return (*uint64)(unsafe.Pointer(\u0026wg.state1[1])), \u0026wg.state1[0] } } 当数组的首地址是处于一个8字节对齐的位置上时，那么就将这个数组的前8个字节作为64位值使用表示状态，后4个字节作为32位值表示信号量(semaphore)。同理如果首地址没有处于8字节对齐的位置上时，那么就将前4个字节作为semaphore，后8个字节作为64位数值。画个图表示一下： ","date":"2021-02-10","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:4:1","tags":["并发编程","sync包"],"title":"Go语言并发编程之sync.waitGroup的源码解析","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"Add()、Done()方法 sync.WaitGroup提供了Add()方法增加一个计数器，Done()方法减掉一个计数，Done()方法实现比较简单，内部调用的Add()方法实现的计数器减一操作，也就是增减逻辑都在Add()方法中，所以我们重点看一下Add()是如何实现的： func (wg *WaitGroup) Add(delta int) { // 获取状态(Goroutine Counter 和 Waiter Counter)和信号量 statep, semap := wg.state() if race.Enabled { _ = *statep // trigger nil deref early if delta \u003c 0 { // Synchronize decrements with Wait. race.ReleaseMerge(unsafe.Pointer(wg)) } race.Disable() defer race.Enable() } // 原子操作，goroutine counter累加delta state := atomic.AddUint64(statep, uint64(delta)\u003c\u003c32) // 获取当前goroutine counter的值(高32位) v := int32(state \u003e\u003e 32) // 获取当前waiter counter的值(低32位) w := uint32(state) if race.Enabled \u0026\u0026 delta \u003e 0 \u0026\u0026 v == int32(delta) { // The first increment must be synchronized with Wait. // Need to model this as a read, because there can be // several concurrent wg.counter transitions from 0. race.Read(unsafe.Pointer(semap)) } // Goroutine counter是不允许为负数的，否则会发生panic if v \u003c 0 { panic(\"sync: negative WaitGroup counter\") } // 当wait的Goroutine不为0时，累加后的counter值和delta相等,说明Add()和Wait()同时调用了,所以发生panic,因为正确的做法是先Add()后Wait()，也就是已经调用了wait()就不允许再添加任务了 if w != 0 \u0026\u0026 delta \u003e 0 \u0026\u0026 v == int32(delta) { panic(\"sync: WaitGroup misuse: Add called concurrently with Wait\") } // 正常`Add()`方法后，`goroutine Counter`计数器大于0或者`waiter Counter`计数器等于0时，不需要释放信号量 if v \u003e 0 || w == 0 { return } // 能走到这里说明当前Goroutine Counter计数器为0，Waiter Counter计数器大于0, 到这里数据也就是允许发生变动了，如果发生变动了，则出发panic if *statep != state { panic(\"sync: WaitGroup misuse: Add called concurrently with Wait\") } // 重置状态，并发出信号量告诉wait所有任务已经完成 *statep = 0 for ; w != 0; w-- { runtime_Semrelease(semap, false, 0) } } 上面的代码有一部分是race静态检测，下面的分析会省略这一部分，因为它并不是本文的重点。 注释我都添加到对应的代码行上了，你是否都看懂了，没看懂不要紧，因为Add()是与Wait()方法一块使用的，所以有些逻辑与wait()里的逻辑是相互照应的，所以当我们看完wait()方法的实现在总结一下你们就明白了。 ","date":"2021-02-10","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:5:0","tags":["并发编程","sync包"],"title":"Go语言并发编程之sync.waitGroup的源码解析","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"Wait()方法 sync.Wait()方法会阻塞主Goroutine直到WaitGroup计数器变为0。我们一起来看一下Wait()方法的源码： // Wait blocks until the WaitGroup counter is zero. func (wg *WaitGroup) Wait() { // 获取状态(Goroutine Counter 和 Waiter Counter)和信号量 statep, semap := wg.state() if race.Enabled { _ = *statep // trigger nil deref early race.Disable() } for { // 使用原子操作读取state，是为了保证Add中的写入操作已经完成 state := atomic.LoadUint64(statep) // 获取当前goroutine counter的值(高32位) v := int32(state \u003e\u003e 32) // 获取当前waiter counter的值(低32位) w := uint32(state) // 如果没有任务，或者任务已经在调用`wait`方法前已经执行完成了，就不用阻塞了 if v == 0 { // Counter is 0, no need to wait. if race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(wg)) } return } // 使用CAS操作对`waiter Counter`计数器进行+1操作，外面有for循环保证这里可以进行重试操作 if atomic.CompareAndSwapUint64(statep, state, state+1) { if race.Enabled \u0026\u0026 w == 0 { // Wait must be synchronized with the first Add. // Need to model this is as a write to race with the read in Add. // As a consequence, can do the write only for the first waiter, // otherwise concurrent Waits will race with each other. race.Write(unsafe.Pointer(semap)) } // 在这里获取信号量，使线程进入睡眠状态，与Add方法中最后的增加信号量相对应，也就是当最后一个任务调用Done方法 // 后会调用Add方法对goroutine counter的值减到0，就会走到最后的增加信号量 runtime_Semacquire(semap) // 在Add方法中增加信号量时已经将statep的值设为0了，如果这里不是0，说明在wait之后又调用了Add方法，使用时机不对，触发panic if *statep != 0 { panic(\"sync: WaitGroup is reused before previous Wait has returned\") } if race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(wg)) } return } } } ","date":"2021-02-10","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:5:1","tags":["并发编程","sync包"],"title":"Go语言并发编程之sync.waitGroup的源码解析","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"源码总结 分了源码，我们可以总结如下： Add方法与wait方法不可以并发同时调用，Add方法要在wait方法之前调用. Add()设置的值必须与实际等待的goroutine个数一致，否则会panic. 调用了wait方法后，必须要在wait方法返回以后才能再次重新使用waitGroup，也就是Wait没有返回之前不要在调用Add方法，否则会发生Panic. Done 只是对Add 方法的简单封装，我们可以向 Add方法传入任意负数（需要保证计数器非负）快速将计数器归零以唤醒等待的 Goroutine. waitGroup对象只能有一份，不可以拷贝给其他变量，否则会造成意想不到的Bug. ","date":"2021-02-10","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:5:2","tags":["并发编程","sync包"],"title":"Go语言并发编程之sync.waitGroup的源码解析","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"no copy机制 在前文看waitGroup结构时，有一个nocopy字段，为什么要有nocopy呢？我们先看这样一个例子： type User struct { Name string Info *Info } type Info struct { Age int Number int } func main() { u := User{ Name: \"asong\", Info: \u0026Info{ Age: 10, Number: 24, }, } u1 := u u1.Name = \"Golang梦工厂\" u1.Info.Age = 30 fmt.Println(u.Info.Age,u.Name) fmt.Println(u1.Info.Age,u1.Name) } // 运行结果 30 asong 30 Golang梦工厂 结构体User中有两个字段Name和Info，Name是String类型，Info是指向结构体Info的指针类型，我们首先声明了一个u变量，对他进行复制拷贝得到变量u1，在u1中对两个字段进行改变，可以看到Info字段发生了更改，而Name就没发生更改，这就引发了安全问题，如果结构体对象包含指针字段，当该对象被拷贝时，会使得两个对象中的指针字段变得不再安全。 Go语言中提供了两种copy检查，一种是在运行时进行检查，一种是通过静态检查。不过运行检查是比较影响程序的执行性能的，Go官方目前只提供了strings.Builder和sync.Cond的runtime拷贝检查机制，对于其他需要nocopy对象类型来说，使用go vet工具来做静态编译检查。运行检查的实现可以通过比较所属对象是否发生变更就可以判断，而静态检查是提供了一个nocopy对象，只要是该对象或对象中存在nocopy字段，他就实现了sync.Locker接口, 它拥有Lock()和Unlock()方法，之后，可以通过go vet功能，来检查代码中该对象是否有被copy。 ","date":"2021-02-10","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:6:0","tags":["并发编程","sync包"],"title":"Go语言并发编程之sync.waitGroup的源码解析","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"踩坑事项 在文章的最后总结一下使用waitGroup易错的知识点，防止大家再次犯错。 waitGroup中计数器的值是不能小于0的，源码中我们就可以看到，一旦小于0就会引发panic。 一定要住注意调用Add方法与Wait方法的顺序，不可并发同时调用这两个方法，否则就会引发panic，同时在调用了wait方法在其没有释放前不要再次调用Add方法，这样也会引发panic，waitGroup是可以复用的，但是需要保证其计数周期的完整性。 WaitGroup对象不是一个引用类型，通过函数传值的时候需要使用地址，因为Go语言只有值传递，传递WaitGroup是值的话，就会导致会发生panic，看这样一个例子： func main() { wg := sync.WaitGroup{} wg.Add(1) doDeadLock(wg) wg.Wait() } func doDeadLock(wg sync.WaitGroup) { defer wg.Done() fmt.Println(\"do something\") } //运行结果：panic: sync: negative WaitGroup counter 发生这个问题的原因就是在doDeadLock()方法中wg是一个新对象，直接调用Done方法，计数器就会出现负数，所以引发panic，为了安全起见，对于这种传结构体的场景一般建议都传指针就好了，基本可以避免一些问题。 Add()设置的值必须与实际等待的goroutine个数一致，否则会panic，很重要的一点，也是很容易出错的地方。 ","date":"2021-02-10","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:7:0","tags":["并发编程","sync包"],"title":"Go语言并发编程之sync.waitGroup的源码解析","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"思考题 最后给大家出一个思考题，下面这段代码会不会发生panic： func main() { wg := sync.WaitGroup{} wg.Add(100) for i := 0; i \u003c 100; i++ { go func() { defer wg.Done() fmt.Println(i) }() } wg.Wait() } ","date":"2021-02-10","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:8:0","tags":["并发编程","sync包"],"title":"Go语言并发编程之sync.waitGroup的源码解析","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"结尾 在最后，祝大家新年快乐，心想事成，万事如意～～～ 好啦，这篇文章就到这里啦，素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！ 创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：加我vx拉你入群，或者公众号获取入群二维码 结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。 我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。 翻译了一份Machinery中文文档，会定期进行维护，有需要的小伙伴们后台回复[machinery]即可获取。 **我是asong，一名普普通通的程序猿，让我们一起慢慢变强吧。欢迎各位的关注，我们下期见~~~** 推荐往期文章： Go看源码必会知识之unsafe包 源码剖析panic与recover，看不懂你打我好了！ 详解并发编程基础之原子操作(atomic包) 详解defer实现机制 真的理解interface了嘛 Leaf—Segment分布式ID生成系统（Golang实现版本） 十张动图带你搞懂排序算法(附go实现代码) go参数传递类型 手把手教姐姐写消息队列 常见面试题之缓存雪崩、缓存穿透、缓存击穿 详解Context包，看这一篇就够了！！！ go-ElasticSearch入门看这一篇就够了(一) 面试官：go中for-range使用过吗？这几个问题你能解释一下原因吗 ","date":"2021-02-10","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:9:0","tags":["并发编程","sync包"],"title":"Go语言并发编程之sync.waitGroup的源码解析","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":" 哈喽，大家好，我是asong，这是我并发编程系列的第二篇文章. 上一篇我们一起分析了atomic包，今天我们一起来看一看sync/once的使用与实现. ","date":"2021-01-29","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.once%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:0:0","tags":["并发编程"],"title":"详解并发编程之sync.Once的实现(附上三道面试题)","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.once%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"什么是sync.once Go语言标准库中的sync.Once可以保证go程序在运行期间的某段代码只会执行一次，作用与init类似，但是也有所不同： init函数是在文件包首次被加载的时候执行，且只执行一次。 sync.Once是在代码运行中需要的时候执行，且只执行一次。 还记得我之前写的一篇关于go单例模式,懒汉模式的一种实现就可以使用sync.Once，他可以解决双重检锁带来的每一次访问都要检查两次的问题，因为sync.once的内部实现可以完全解决这个问题(后面分析完源码就知道原因了)，下面我们来看一看这种懒汉模式怎么写： type singleton struct { } var instance *singleton var once sync.Once func GetInstance() *singleton { once.Do(func() { instance = new(singleton) }) return instance } 实现还是比较简单，就不细说了。 ","date":"2021-01-29","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.once%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:1:0","tags":["并发编程"],"title":"详解并发编程之sync.Once的实现(附上三道面试题)","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.once%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"源码解析 sync.Once的源码还是很少的，首先我们看一下他的结构： // Once is an object that will perform exactly one action. type Once struct { // done indicates whether the action has been performed. // It is first in the struct because it is used in the hot path. // The hot path is inlined at every call site. // Placing done first allows more compact instructions on some architectures (amd64/x86), // and fewer instructions (to calculate offset) on other architectures. done uint32 m Mutex } 只有两个字段，字段done用来标识代码块是否执行过，字段m是一个互斥锁。 接下来我们一起来看一下代码实现： func (o *Once) Do(f func()) { if atomic.LoadUint32(\u0026o.done) == 0 { o.doSlow(f) } } func (o *Once) doSlow(f func()) { o.m.Lock() defer o.m.Unlock() if o.done == 0 { defer atomic.StoreUint32(\u0026o.done, 1) f() } } 这里把注释都省略了，反正都是英文，接下来咱用中文解释哈。sync.Once结构对外只提供了一个Do()方法，该方法的参数是一个入参为空的函数，这个函数也就是我们想要执行一次的代码块。接下来我们看一下代码流程： 首先原子性的读取done字段的值是否改变，没有改变则执行doSlow()方法. 一进入doslow()方法就开始执行加锁操作，这样在并发情况下可以保证只有一个线程会执行，在判断一次当前done字段是否发生改变(这里肯定有朋友会感到疑惑，为什么这里还要在判断一次flag？因为如果同时有两个goroutine调用这一行代码，一个goroutine成功CAS设置了标志的话，就会调用f,做资源初始化或者其它的一些事情，这个执行可能会耗费一段时间。同时另外一个goroutine设置不成功，它想当然的认为另外一个goroutine已经执行了f,但是实际上f可能还没有执行完，这就可能代码并发的问题。所以这里是为了保证当前代码块已经执行完)，如果未发生改变，则开始执行代码块，代码块运行结束后会对done字段做原子操作，标识该代码块已经被执行过了. ","date":"2021-01-29","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.once%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:2:0","tags":["并发编程"],"title":"详解并发编程之sync.Once的实现(附上三道面试题)","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.once%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"优化sync.Once 如果让你自己写一个这样的库，你会考虑的这样全面吗？相信聪明的你们也一定会写出这样一段代码。如果要是我来写，上面的代码可能都一样，但是在if o.done == 0 这里我可能会采用CAS原子操作来代替这个判断，如下： type MyOnce struct { flag uint32 lock sync.Mutex } func (m *MyOnce)Do(f func()) { if atomic.LoadUint32(\u0026m.flag) == 0{ m.lock.Lock() defer m.lock.Unlock() if atomic.CompareAndSwapUint32(\u0026m.flag,0,1){ f() } } } func testDo() { mOnce := MyOnce{} for i := 0;i\u003c10;i++{ go func() { mOnce.Do(func() { fmt.Println(\"test my once only run once\") }) }() } } func main() { testDo() time.Sleep(10 * time.Second) } // 运行结果： test my once only run once 我就说原子操作是并发编程的基础吧，你看没有错吧～。 ","date":"2021-01-29","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.once%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:3:0","tags":["并发编程"],"title":"详解并发编程之sync.Once的实现(附上三道面试题)","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.once%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"小试牛刀 上面我们也看了源码的实现，现在我们来看三道题，你认为他们的答案是多少？ ","date":"2021-01-29","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.once%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:4:0","tags":["并发编程"],"title":"详解并发编程之sync.Once的实现(附上三道面试题)","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.once%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"问题一 sync.Once()方法中传入的函数发生了panic，重复传入还会执行吗？ func panicDo() { once := \u0026sync.Once{} defer func() { if err := recover();err != nil{ once.Do(func() { fmt.Println(\"run in recover\") }) } }() once.Do(func() { panic(\"panic i=0\") }) } ","date":"2021-01-29","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.once%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:4:1","tags":["并发编程"],"title":"详解并发编程之sync.Once的实现(附上三道面试题)","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.once%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"问题二 sync.Once()方法传入的函数中再次调用sync.Once()方法会有什么问题吗？ func nestedDo() { once := \u0026sync.Once{} once.Do(func() { once.Do(func() { fmt.Println(\"test nestedDo\") }) }) } ","date":"2021-01-29","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.once%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:4:2","tags":["并发编程"],"title":"详解并发编程之sync.Once的实现(附上三道面试题)","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.once%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"问题三 改成这样呢？ func nestedDo() { once1 := \u0026sync.Once{} once2 := \u0026sync.Once{} once1.Do(func() { once2.Do(func() { fmt.Println(\"test nestedDo\") }) }) } ","date":"2021-01-29","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.once%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:4:3","tags":["并发编程"],"title":"详解并发编程之sync.Once的实现(附上三道面试题)","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.once%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"总结 在本文的最把上面三道题的答案公布一下吧： 问题一：不会打印任何东西，sync.Once.Do 方法中传入的函数只会被执行一次，哪怕函数中发生了 panic； 问题二：发生死锁，根据源码实现我们可以知道在第二个do方法会一直等doshow()中锁的释放导致发生了死锁; 问题三：打印test nestedDo，once1，once2是两个对象，互不影响。所以sync.Once是使方法只执行一次对象的实现。 你们都做对了吗？ 代码已上传：https://github.com/asong2020/Golang_Dream/tree/master/code_demo/once_demo.(欢迎Star) 好啦，这篇文章就到这里啦，素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！ 创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：加我vx拉你入群，或者公众号获取入群二维码 结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。 我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。 翻译了一份Machinery中文文档，会定期进行维护，有需要的小伙伴们后台回复[machinery]即可获取。 **我是asong，一名普普通通的程序猿，让我们一起慢慢变强吧。欢迎各位的关注，我们下期见~~~** 推荐往期文章： machinery-go异步任务队列 源码剖析panic与recover，看不懂你打我好了！ 详解并发编程基础之原子操作(atomic包) 详解defer实现机制 真的理解interface了嘛 Leaf—Segment分布式ID生成系统（Golang实现版本） 十张动图带你搞懂排序算法(附go实现代码) go参数传递类型 手把手教姐姐写消息队列 常见面试题之缓存雪崩、缓存穿透、缓存击穿 详解Context包，看这一篇就够了！！！ go-ElasticSearch入门看这一篇就够了(一) 面试官：go中for-range使用过吗？这几个问题你能解释一下原因吗 ","date":"2021-01-29","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.once%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:5:0","tags":["并发编程"],"title":"详解并发编程之sync.Once的实现(附上三道面试题)","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.once%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"前言 嗨，大家好，我是asong。最近想写一个并发编程系列的文章，使用Go也有一段时间了，但是对并发的理解不是很透彻，借着这次总结，希望能更进一步。我们以\"原子操作\"开篇，对于并发操作而言，原子操作是个非常现实的问题，比较典型的应用的就是i++操作，并发情况下，同时对内存中的i进行读取，就会产生与预期不符的结果，所以Go语言中的sync/atomic就是解决这个问题的，接下来我们一起来看一看Go的原子操作。 ","date":"2021-01-28","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Batmoic%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:1:0","tags":["并发编程"],"title":"详解并发编程基础之原子操作(atomic)","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Batmoic%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"什么是原子性、原子操作 原子(atomic)本意是\"不能被进一步分割的最小粒子\"，而原子操作(atomic operation)意为\"不可中断的一个或一系列操作\"。其实用大白话说出来就是让多个线程对同一块内存的操作是串行的，不会因为并发操作把内存写的不符合预期。我们来看这样一个例子： 假设现在是一个银行账户系统，用户A想要自己从自己的账户中转1万元到用户B的账户上，直到转帐成功完成一个事务，主要做这两件事： 从A的账户中减去1万元，如果A的账户原来就有2万元，现在就变成了1万元 给B的账户添加1万元，如果B的账户原来有2万元，那么现在就变成了3万元 假设在操作一的时候，系统发生了故障，导致给B账户添加款项失败了，那么就要进行回滚。回滚就是回到事务之前的状态，我们把这种要么一起成功的操作叫做原子操作，而原子性就是要么完整的被执行、要么完全不执行。 ","date":"2021-01-28","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Batmoic%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:2:0","tags":["并发编程"],"title":"详解并发编程基础之原子操作(atomic)","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Batmoic%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"如何保证原子性 锁机制 在处理器层面，可以采用总线加锁或者对缓存加锁的方式来实现多处理器之间的原子操作。通过加锁保证从系统内存中读取或写入一个字节是原子的，也就是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。 总线锁：处理器提供一个Lock#信号，当一个处理器上在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。总线锁会把CPU和内存之间的通信锁住了，在锁定期间，其他处理就不能操作其他内存地址的数据，所以总线锁定的开销比较大，所以处理会在某些场合使用缓存锁进行优化。 缓存锁：内存区域如果被缓存在处理器上的缓存行中，并且在Lock#操作期间，那么当它执行操作回写到内存时，处理不在总线上声言Lock#信号，而是修改内部的内存地址，并允许它的缓存一致机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域的数据，其他处理器回写已被锁定的缓存行的数据时，就会使缓存无效。 锁机制虽然可以保证原子性，但是锁机制会存在以下问题： 多线程竞争的情况下，频繁的加锁、释放锁会导致较多的上下文切换和调度延时，性能会很差 当一个线程占用时间比较长时，就多导致其他需要此锁的线程挂起. 上面我们说的都是悲观锁，要解决这种低效的问题，我们可以采用乐观锁，每次不加锁，而是假设没有冲突去完成某项操作，如果因为冲突失败就重试，直到成功为止。也就是我们接下来要说的CAS(compare and swap). CAS(compare and swap) CAS的全称为Compare And Swap，直译就是比较交换。是一条CPU的原子指令，其作用是让CPU先进行比较两个值是否相等，然后原子地更新某个位置的值，其实现方式是给予硬件平台的汇编指令，在intel的CPU中，使用的cmpxchg指令，就是说CAS是靠硬件实现的，从而在硬件层面提升效率。简述过程是这样： 假设包含3个参数内存位置(V)、预期原值(A)和新值(B)。V表示要更新变量的值，E表示预期值，N表示新值。仅当V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程在做更新，则当前线程什么都不做，最后CAS返回当前V的真实值。CAS操作时抱着乐观的态度进行的，它总是认为自己可以成功完成操作。基于这样的原理，CAS操作即使没有锁，也可以发现其他线程对于当前线程的干扰。 伪代码可以这样写： func CompareAndSwap(int *addr,int oldValue,int newValue) bool{ if *addr == nil{ return false } if *addr == oldValue { *addr = newValue return true } return false } 不过上面的代码可能会发生一个问题，也就是ABA问题，因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。 ","date":"2021-01-28","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Batmoic%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:3:0","tags":["并发编程"],"title":"详解并发编程基础之原子操作(atomic)","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Batmoic%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"go语言中如何进行原子操作 在Go语言标准库中，sync/atomic包将底层硬件提供的原子操作封装成了Go的函数，主要分为5个系列的函数，分别是： func SwapXXXX(addr *int32, new int32) (old int32)系列：其实就是原子性的将new值保存到*addr并返回旧值。代码表示： old = *addr *addr = new return old func CompareAndSwapXXXX((addr *int64, old, new int64) (swapped bool)系列：其就是原子性的比较*addr和old的值，如果相同则将new赋值给*addr并返回真，代码表示： if *addr == old{ *addr = new return ture } return false func AddXXXX(addr *int64, delta int64) (new int64)系列：原子性的将val的值添加到*addr并返回新值。代码表示： *addr += delta return *addr func LoadXXXX(addr *uint32) (val uint32)系列：原子性的获取*addr的值 func StoreXXXX(addr *int32, val int32)原子性的将val值保存到*addr Go语言在1.4版本时添加一个新的类型Value，此类型的值就相当于一个容器，可以被用来\"原子地\"存储(store)和加载(Load)任意类型的值。这些使用起来都还比较简单，就不写例子了，接下来我们一起看一看这些方法是如何实现的。 ","date":"2021-01-28","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Batmoic%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:4:0","tags":["并发编程"],"title":"详解并发编程基础之原子操作(atomic)","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Batmoic%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"源码解析 由于系列比较多。底层实现的方法也大同小异样，这里就主要分析一下Value的实现方法吧。为什么不分析其他系列的呢？因为原子操作由底层硬件支持，所以看其他系列实现都要看汇编，Go的汇编是基于Plan9的，这个汇编语言真的资料甚少，我也是真的不懂，水平不够，也不自讨苦吃了，等后面真的能看懂这些汇编了，再来分析吧。这个网站有一些关于plan9汇编的知识，有兴趣可以看一看：http://doc.cat-v.org/plan_9/4th_edition/papers/asm。 ","date":"2021-01-28","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Batmoic%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:5:0","tags":["并发编程"],"title":"详解并发编程基础之原子操作(atomic)","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Batmoic%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"Value结构 我们先来看一下Value的结构： type Value struct { v interface{} } Value结构里就只有一个字段，是interface类型，虽然这里是interface类型，但是这里要注意，第一次Store写入的类型就确定了之后写入的类型，否则会发生panic。因为这里是interface类型，所以为了之后写入与读取操作方便，又在这个包里定义了一个ifaceWords结构，其实他就是一个空interface，他的作用就是将interface 分解成类型和数值。结构如下： // ifaceWords is interface{} internal representation. type ifaceWords struct { typ unsafe.Pointer data unsafe.Pointer } ","date":"2021-01-28","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Batmoic%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:5:1","tags":["并发编程"],"title":"详解并发编程基础之原子操作(atomic)","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Batmoic%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"Value的写入操作 我们一起来看一看他是如何实现写入操作的： // Store sets the value of the Value to x. // All calls to Store for a given Value must use values of the same concrete type. // Store of an inconsistent type panics, as does Store(nil). func (v *Value) Store(x interface{}) { if x == nil { panic(\"sync/atomic: store of nil value into Value\") } vp := (*ifaceWords)(unsafe.Pointer(v)) xp := (*ifaceWords)(unsafe.Pointer(\u0026x)) for { typ := LoadPointer(\u0026vp.typ) if typ == nil { // Attempt to start first store. // Disable preemption so that other goroutines can use // active spin wait to wait for completion; and so that // GC does not see the fake type accidentally. runtime_procPin() if !CompareAndSwapPointer(\u0026vp.typ, nil, unsafe.Pointer(^uintptr(0))) { runtime_procUnpin() continue } // Complete first store. StorePointer(\u0026vp.data, xp.data) StorePointer(\u0026vp.typ, xp.typ) runtime_procUnpin() return } if uintptr(typ) == ^uintptr(0) { // First store in progress. Wait. // Since we disable preemption around the first store, // we can wait with active spinning. continue } // First store completed. Check type and overwrite data. if typ != xp.typ { panic(\"sync/atomic: store of inconsistently typed value into Value\") } StorePointer(\u0026vp.data, xp.data) return } } // Disable/enable preemption, implemented in runtime. func runtime_procPin() func runtime_procUnpin() 这段代码中的注释集已经告诉了我们，调用Store方法写入的类型必须与愿类型相同，不一致便会发生panic。接下来分析代码实现： 首先判断条件写入参数不能为nil，否则触发panic 通过使用unsafe.Pointer将oldValue和newValue转换成ifaceWords类型。方便我们获取他的原始类型(typ)和值(data). 为了保证原子性，所以这里使用一个for换来处理，当已经有Store正在进行写入时，会进行等待. 如果还没写入过数据，那么获取不到原始类型，就会开始第一次写入操作，这里会把先调用runtime_procPin()方法禁止调度器对当前 goroutine 的抢占（preemption），这样也可以防止GC线程看到一假类型。 调用CAS方法来判断当前地址是否有被抢占，这里大家可能对unsafe.Pointer(^uintptr(0))这一句话有点不明白，因为是第一个写入数据，之前是没有数据的，所以通过这样一个中间值来做判断，如果失败就会解除抢占锁，解除禁止调度器，继续循环等待. 设置中间值成功后，我们接下来就可以安全的把v设为传入的新值了，这里会先写入值，在写入类型(typ)，因为我们会根据ty来做完成判断。 第一次写入没完成，我们还会通过uintptr(typ) == ^uintptr(0)来进行判断，因为还是第一次放入的中间类型，他依然会继续等待第一次完成。 如果第一次写入完成，会检查上一次写入的类型与这次写入的类型是否一致，不一致则会抛出panic. 这里代码量没有多少，相信大家一定看懂了吧～。 ","date":"2021-01-28","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Batmoic%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:5:2","tags":["并发编程"],"title":"详解并发编程基础之原子操作(atomic)","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Batmoic%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"Value的读操作 先看一下代码： // Load returns the value set by the most recent Store. // It returns nil if there has been no call to Store for this Value. func (v *Value) Load() (x interface{}) { vp := (*ifaceWords)(unsafe.Pointer(v)) typ := LoadPointer(\u0026vp.typ) if typ == nil || uintptr(typ) == ^uintptr(0) { // First store not yet completed. return nil } data := LoadPointer(\u0026vp.data) xp := (*ifaceWords)(unsafe.Pointer(\u0026x)) xp.typ = typ xp.data = data return } 读取操作的代码就很简单了： 1.第一步使用unsafe.Pointer将oldValue转换成ifaceWords类型，然后获取他的类型，如果没有类型或者类型出去中间值，那么说明现在还没数据或者第一次写入还没有完成。 2. 通过检查后，调用LoadPointer方法可以获取他的值，然后构造一个新interface的typ和data返回。 ","date":"2021-01-28","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Batmoic%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:5:3","tags":["并发编程"],"title":"详解并发编程基础之原子操作(atomic)","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Batmoic%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"小彩蛋 前面我们在说CAS时，说到了ABA问题，所以我就写了demo试一试Go标准库atomic.CompareAndSwapXXX方法是否有解决这个问题，看运行结果是没有，所以这里大家使用的时候要注意一下(虽然我也没想到什么现在什么业务场景会出现这个问题，但是还是要注意一下，需要自己评估)。 func main() { var share uint64 = 1 wg := sync.WaitGroup{} wg.Add(3) // 协程1，期望值是1,欲更新的值是2 go func() { defer wg.Done() swapped := atomic.CompareAndSwapUint64(\u0026share,1,2) fmt.Println(\"goroutine 1\",swapped) }() // 协程2，期望值是1，欲更新的值是2 go func() { defer wg.Done() time.Sleep(5 * time.Millisecond) swapped := atomic.CompareAndSwapUint64(\u0026share,1,2) fmt.Println(\"goroutine 2\",swapped) }() // 协程3，期望值是2，欲更新的值是1 go func() { defer wg.Done() time.Sleep(1 * time.Millisecond) swapped := atomic.CompareAndSwapUint64(\u0026share,2,1) fmt.Println(\"goroutine 3\",swapped) }() wg.Wait() fmt.Println(\"main exit\") } ","date":"2021-01-28","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Batmoic%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:5:4","tags":["并发编程"],"title":"详解并发编程基础之原子操作(atomic)","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Batmoic%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"总结 原子操作是并发编程的一个基础，也是为我学习sync.once打基础，好啦，现在你们应该知道下篇文章的内容是什么啦，敬请期待～。 好啦，这篇文章就到这里啦，素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！ 创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：加我vx拉你入群，或者公众号获取入群二维码 结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。 我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。 翻译了一份Machinery中文文档，会定期进行维护，有需要的小伙伴们后台回复[machinery]即可获取。 **我是asong，一名普普通通的程序猿，让我们一起慢慢变强吧。欢迎各位的关注，我们下期见~~~** 推荐往期文章： machinery-go异步任务队列 详解defer实现机制 真的理解interface了嘛 Leaf—Segment分布式ID生成系统（Golang实现版本） 十张动图带你搞懂排序算法(附go实现代码) go参数传递类型 手把手教姐姐写消息队列 常见面试题之缓存雪崩、缓存穿透、缓存击穿 详解Context包，看这一篇就够了！！！ go-ElasticSearch入门看这一篇就够了(一) 面试官：go中for-range使用过吗？这几个问题你能解释一下原因吗 ","date":"2021-01-28","objectID":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Batmoic%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:6:0","tags":["并发编程"],"title":"详解并发编程基础之原子操作(atomic)","uri":"https://asong2020.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Batmoic%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Go源码"],"content":"前言 哈喽，大家好，我是asong，今天与大家来聊一聊go语言中的\"throw、try…..catch{}\"。如果你之前是一名java程序员，我相信你一定吐槽过go语言错误处理方式，但是这篇文章不是来讨论好坏的，我们本文的重点是带着大家看一看panic与recover是如何实现的。上一文我们讲解了defer是如何实现的，但是没有讲解与defoer紧密相连的recover，想搞懂panic与recover的实现也没那么简单，就放到这一篇来讲解了。废话不多说，直接开整。 ","date":"2021-01-23","objectID":"https://asong2020.github.io/panic%E5%92%8Crecover/:1:0","tags":["panic"],"title":"详解Go语言中的panic和recover","uri":"https://asong2020.github.io/panic%E5%92%8Crecover/"},{"categories":["Go源码"],"content":"什么是panic、recover Go 语言中 panic 关键字主要用于主动抛出异常，类似 java 等语言中的 throw 关键字。panic 能够改变程序的控制流，调用 panic 后会立刻停止执行当前函数的剩余代码，并在当前 Goroutine 中递归执行调用方的 defer； Go 语言中 recover 关键字主要用于捕获异常，让程序回到正常状态，类似 java 等语言中的 try ... catch 。recover 可以中止 panic 造成的程序崩溃。它是一个只能在 defer 中发挥作用的函数，在其他作用域中调用不会发挥作用； recover只能在defer中使用这个在标准库的注释中已经写明白了，我们可以看一下： // The recover built-in function allows a program to manage behavior of a // panicking goroutine. Executing a call to recover inside a deferred // function (but not any function called by it) stops the panicking sequence // by restoring normal execution and retrieves the error value passed to the // call of panic. If recover is called outside the deferred function it will // not stop a panicking sequence. In this case, or when the goroutine is not // panicking, or if the argument supplied to panic was nil, recover returns // nil. Thus the return value from recover reports whether the goroutine is // panicking. func recover() interface{} 这里有一个要注意的点就是recover必须要要在defer函数中使用，否则无法阻止panic。最好的验证方法是先写两个例子： func main() { example1() example2() } func example1() { defer func() { if err := recover(); err !=nil{ fmt.Println(string(Stack())) } }() panic(\"unknown\") } func example2() { defer recover() panic(\"unknown\") } func Stack() []byte { buf := make([]byte, 1024) for { n := runtime.Stack(buf, false) if n \u003c len(buf) { return buf[:n] } buf = make([]byte, 2*len(buf)) } } 运行我们会发现example2()方法的panic是没有被recover住的，导致整个程序直接crash了。这里大家肯定会有疑问，为什么直接写recover()就不能阻止panic了呢。我们在详解defer实现机制(附上三道面试题，我不信你们都能做对)讲解了defer实现原理，一个重要的知识点**defer将语句放入到栈中时，也会将相关的值拷贝同时入栈。**所以defer recover()这种写法在放入defer栈中时就已经被执行过了，panic是发生在之后，所以根本无法阻止住panic。 ","date":"2021-01-23","objectID":"https://asong2020.github.io/panic%E5%92%8Crecover/:2:0","tags":["panic"],"title":"详解Go语言中的panic和recover","uri":"https://asong2020.github.io/panic%E5%92%8Crecover/"},{"categories":["Go源码"],"content":"特性 上面我们简单的介绍了一下什么是panic与recover，下面我一起来看看他们有什么特性，避免我们踩坑。 recover只有在defer函数中使用才有效，上面已经举例说明了，这里就不在赘述了。 panic允许在defer中嵌套多次调用.程序多次调用 panic 也不会影响 defer 函数的正常执行，所以使用 defer 进行收尾工作一般来说都是安全的。写个例子验证一下： func example3() { defer fmt.Println(\"this is a example3 for defer use panic\") defer func() { defer func() { panic(\"panic defer 2\") }() panic(\"panic defer 1\") }() panic(\"panic example3\") } // 运行结果 this is a example3 for defer use panic panic: panic example3 panic: panic defer 1 panic: panic defer 2 .......... 省略 通过运行结果可以看出panic不会影响defer函数的使用，所以他是安全的。 panic只会对当前Goroutine的defer有效，还记得我们上一文分析的deferproc函数吗？在newdefer中分配_defer结构体对象的时，会把分配到的对象链入当前 goroutine的_defer 链表的表头，也就是把延迟调用函数与调用方所在的Goroutine进行关联。因此当程序发生panic时只会调用当前 Goroutine 的延迟调用函数是没有问题的。写个例子验证一下： func main() { go example4() go example5() time.Sleep(10 * time.Second) } func example4() { fmt.Println(\"goroutine example4\") defer func() { fmt.Println(\"test defer\") }() panic(\"unknown\") } func example5() { defer fmt.Println(\"goroutine example5\") time.Sleep(5 * time.Second) } // 运行结果 goroutine example4 test defer panic: unknown ............. 省略部分代码 这里我开了两个协程，一个协程会发生panic，导致程序崩溃，但是只会执行自己所在Goroutine的延迟函数，所以正好验证了多个 Goroutine 之间没有太多的关联，一个 Goroutine 在 panic 时也不应该执行其他 Goroutine 的延迟函数。 ","date":"2021-01-23","objectID":"https://asong2020.github.io/panic%E5%92%8Crecover/:3:0","tags":["panic"],"title":"详解Go语言中的panic和recover","uri":"https://asong2020.github.io/panic%E5%92%8Crecover/"},{"categories":["Go源码"],"content":"典型应用 其实我们在实际项目开发中，经常会遇到panic问题， Go 的 runtime 代码中很多地方都调用了 panic 函数，对于不了解 Go 底层实现的新人来说，这无疑是挖了一堆深坑。我们在实际生产环境中总会出现panic，但是我们的程序仍能正常运行，这是因为我们的框架已经做了recover，他已经为我们兜住底，比如gin，我们看一看他是怎么做的。 先看代码部分吧： func Default() *Engine { debugPrintWARNINGDefault() engine := New() engine.Use(Logger(), Recovery()) return engine } // Recovery returns a middleware that recovers from any panics and writes a 500 if there was one. func Recovery() HandlerFunc { return RecoveryWithWriter(DefaultErrorWriter) } // RecoveryWithWriter returns a middleware for a given writer that recovers from any panics and writes a 500 if there was one. func RecoveryWithWriter(out io.Writer) HandlerFunc { var logger *log.Logger if out != nil { logger = log.New(out, \"\\n\\n\\x1b[31m\", log.LstdFlags) } return func(c *Context) { defer func() { if err := recover(); err != nil { // Check for a broken connection, as it is not really a // condition that warrants a panic stack trace. ...................// 省略 } }() c.Next() } } 我们在使用gin时，第一步会初始化一个Engine实例，调用Default方法会把recovery middleware附上，recovery中使用了defer函数，通过recover来阻止panic，当发生panic时，会返回500错误码。这里有一个需要注意的点是只有主程序中的panic是会被自动recover的,协程中出现panic会导致整个程序crash。还记得我们上面讲的第三个特性嘛，一个协程会发生panic，导致程序崩溃，但是只会执行自己所在Goroutine的延迟函数，所以正好验证了多个 Goroutine 之间没有太多的关联，一个 Goroutine 在 panic 时也不应该执行其他 Goroutine 的延迟函数。 这就能解释通了吧， 所以为了程序健壮性，我们应该自己主动检查我们的协程程序，在我们的协程函数中添加recover是很有必要的，比如这样： func main() { r := gin.Default() r.GET(\"/asong/test/go-panic\", func(ctx *gin.Context) { go func() { defer func() { if err := recover();err != nil{ fmt.Println(err) } }() panic(\"panic\") }() }) r.Run() } 如果使用的Gin框架，切记要检查协程中是否会出现panic，否则线上将付出沉重的代价。非常危险！！！ ","date":"2021-01-23","objectID":"https://asong2020.github.io/panic%E5%92%8Crecover/:4:0","tags":["panic"],"title":"详解Go语言中的panic和recover","uri":"https://asong2020.github.io/panic%E5%92%8Crecover/"},{"categories":["Go源码"],"content":"源码解析 go-version: 1.15.3 我们先来写个简单的代码，看看他的汇编调用： func main() { defer func() { if err:= recover();err != nil{ fmt.Println(err) } }() panic(\"unknown\") } 执行go tool compile -N -l -S main.go就可以看到对应的汇编码了，我们截取部分片段分析： 上面重点部分就是画红线的三处，第一步调用runtime.deferprocStack创建defer对象，这一步大家可能会有疑惑，我上一文忘记讲个这个了，这里先简单概括一下，defer总共有三种模型，编译一个函数里只会有一种defer模式 第一种，堆上分配(deferproc)，基本是依赖运行时来分配\"_defer\"对象并加入延迟参数。在函数的尾部插入deferreturn方法来消费deferlink。 第二种，栈上分配(deferprocStack)，基本上跟堆差不多，只是分配方式改为在栈上分配，压入的函数调用栈存有_defer记录，编译器在ssa过程中会预留defer空间。 第三种，开放编码模式(open coded)，不过是有条件的，默认open-coded最多支持8个defer，超过则取消。在构建ssa时如发现gcflags有N禁止优化的参数 或者 return数量 * defer数量超过了 15不适用open-coded模式。并不能处于循环中。 按理说我们的版本是1.15+，应该使用开放编码模式呀，但是这里怎么还会在栈上分配？注意看呀，伙计们，我在汇编处理时禁止了编译优化，那肯定不会走开放编码模式呀，这个不是重点，我们接着分析上面的汇编。 第二个红线在程序发生panic时会调用runtime.gopanic，现在程序处于panic状态，在函数返回时调用runtime.deferreturn，也就是调用延迟函数处理。上面这一步是主程序执行部分，下面我们在看一下延迟函数中的执行： 这里最重点的就只有一个，调用runtime.gorecover，也就是在这一步，对主程序中的panic进行了恢复了，这就是panic与recover的执行过程，接下来我们就仔细分析一下runtime.gopanic、runtime.gorecover这两个方法是如何实现的！ ","date":"2021-01-23","objectID":"https://asong2020.github.io/panic%E5%92%8Crecover/:5:0","tags":["panic"],"title":"详解Go语言中的panic和recover","uri":"https://asong2020.github.io/panic%E5%92%8Crecover/"},{"categories":["Go源码"],"content":"_panic结构 在讲defer实现机制时，我们一起看过defer的结构，其中有一个字段就是_panic，是触发defer的作用，我们来看看的panic的结构： type _panic struct { argp unsafe.Pointer // pointer to arguments of deferred call run during panic; cannot move - known to liblink arg interface{} // argument to panic link *_panic // link to earlier panic pc uintptr // where to return to in runtime if this panic is bypassed sp unsafe.Pointer // where to return to in runtime if this panic is bypassed recovered bool // whether this panic is over aborted bool // the panic was aborted goexit bool } 简单介绍一下上面的字段： argp是指向defer调用时参数的指针。 arg是我们调用panic时传入的参数 link指向的是更早调用runtime._panic结构，也就是说painc可以被连续调用，他们之间形成链表 recovered 表示当前runtime._panic是否被recover恢复 aborted表示当前的panic是否被强行终止 上面的pc、sp、goexit我们单独讲一下，runtime包中有一个Goexit方法，Goext能够终止调用它的goroutine，其他的goroutine是不受影响的，goexit也会在终止goroutine之前运行所有延迟调用函数，Goexit不是一个panic，所以这些延迟函数中的任何recover调用都将返回nil。如果我们在主函数中调用了Goexit会终止该goroutine但不会返回func main。由于func main没有返回，因此程序将继续执行其他gorountine，直到所有其他goroutine退出，程序才会crash。写个简单的例子： func main() { go func() { defer func() { if err := recover(); err != nil { fmt.Println(err) } }() runtime.Goexit() }() go func() { for true { fmt.Println(\"test\") } }() runtime.Goexit() fmt.Println(\"main\") select { } } 运行上面的例子你就会发现，即使在主goroutine中调用了runtime.Goexit，其他goroutine 是没有任何影响的。所以结构中的pc、sp、goexit三个字段都是为了修复runtime.Goexit，这三个字段就是为了保证该函数的一定会生效，因为如果在defer中发生panic，那么goexit函数就会被取消，所以才有了这三个字段做保护。看这个例子： func main() { maybeGoexit() } func maybeGoexit() { defer func() { fmt.Println(recover()) }() defer panic(\"cancelled Goexit!\") runtime.Goexit() } 英语好的可以看一看这个：https://github.com/golang/go/issues/29226，这就是上面的一个例子，这里就不过多解释了，了解就好。 下面就开始我们的重点吧～。 ","date":"2021-01-23","objectID":"https://asong2020.github.io/panic%E5%92%8Crecover/:5:1","tags":["panic"],"title":"详解Go语言中的panic和recover","uri":"https://asong2020.github.io/panic%E5%92%8Crecover/"},{"categories":["Go源码"],"content":"gopanic gopanic的代码有点长，我们一点一点来分析： 第一部分，判断panic类型： gp := getg() if gp.m.curg != gp { print(\"panic: \") printany(e) print(\"\\n\") throw(\"panic on system stack\") } if gp.m.mallocing != 0 { print(\"panic: \") printany(e) print(\"\\n\") throw(\"panic during malloc\") } if gp.m.preemptoff != \"\" { print(\"panic: \") printany(e) print(\"\\n\") print(\"preempt off reason: \") print(gp.m.preemptoff) print(\"\\n\") throw(\"panic during preemptoff\") } if gp.m.locks != 0 { print(\"panic: \") printany(e) print(\"\\n\") throw(\"panic holding locks\") } 根据不同的类型判断当前发生panic错误，这里没什么多说的，接着往下看。 第二部分，确保每个recover都试图恢复当前协程中最新产生的且尚未恢复的panic var p _panic // 声明一个panic结构 p.arg = e // 把panic传入的值赋给`arg` p.link = gp._panic // 指向runtime.panic结构 gp._panic = (*_panic)(noescape(unsafe.Pointer(\u0026p))) atomic.Xadd(\u0026runningPanicDefers, 1) // By calculating getcallerpc/getcallersp here, we avoid scanning the // gopanic frame (stack scanning is slow...) addOneOpenDeferFrame(gp, getcallerpc(), unsafe.Pointer(getcallersp())) for { d := gp._defer // 获取当前gorourine的 defer if d == nil { break // 如果没有defer直接退出了 } // If defer was started by earlier panic or Goexit (and, since we're back here, that triggered a new panic), // take defer off list. An earlier panic will not continue running, but we will make sure below that an // earlier Goexit does continue running. if d.started { if d._panic != nil { d._panic.aborted = true } d._panic = nil if !d.openDefer { // For open-coded defers, we need to process the // defer again, in case there are any other defers // to call in the frame (not including the defer // call that caused the panic). d.fn = nil gp._defer = d.link freedefer(d) continue } } // Mark defer as started, but keep on list, so that traceback // can find and update the defer's argument frame if stack growth // or a garbage collection happens before reflectcall starts executing d.fn. d.started = true // Record the panic that is running the defer. // If there is a new panic during the deferred call, that panic // will find d in the list and will mark d._panic (this panic) aborted. d._panic = (*_panic)(noescape(unsafe.Pointer(\u0026p))) 上面的代码不太好说的部分，我添加了注释，就不在这解释一遍了，直接看 d.Started部分，这里的意思是如果defer是由先前的panic或Goexit启动的(循环处理回到这里，这触发了新的panic)，将defer从列表中删除。早期的panic将不会继续运行，但我们将确保早期的Goexit会继续运行，代码中的if d._panic != nil{d._panic.aborted =true}就是确保将先前的panic终止掉，将aborted设置为true，在下面执行recover时保证goexit不会被取消。 第三部分，defer内联优化调用性能 if !d.openDefer { // For open-coded defers, we need to process the // defer again, in case there are any other defers // to call in the frame (not including the defer // call that caused the panic). d.fn = nil gp._defer = d.link freedefer(d) continue } done := true if d.openDefer { done = runOpenDeferFrame(gp, d) if done \u0026\u0026 !d._panic.recovered { addOneOpenDeferFrame(gp, 0, nil) } } else { p.argp = unsafe.Pointer(getargp(0)) reflectcall(nil, unsafe.Pointer(d.fn), deferArgs(d), uint32(d.siz), uint32(d.siz)) } 上面的代码都是截图片段，这些部分都是为了判断当前defer是否可以使用开发编码模式，具体怎么操作的就不展开了。 第四部分，gopanic中执行程序恢复 在第三部分进行defer内联优化选择时会执行调用延迟函数(reflectcall就是这个作用)，也就是会调用runtime.gorecover把recoverd = true，具体这个函数的操作留在下面讲，因为runtime.gorecover函数并不包含恢复程序的逻辑，程序的恢复是在gopanic中执行的。先看一下代码： if p.recovered { // 在runtime.gorecover中设置为true gp._panic = p.link if gp._panic != nil \u0026\u0026 gp._panic.goexit \u0026\u0026 gp._panic.aborted { // A normal recover would bypass/abort the Goexit. Instead, // we return to the processing loop of the Goexit. gp.sigcode0 = uintptr(gp._panic.sp) gp.sigcode1 = uintptr(gp._panic.pc) mcall(recovery) throw(\"bypassed recovery failed\") // mcall should not return } atomic.Xadd(\u0026runningPanicDefers, -1) if done { // Remove any remaining non-started, open-coded // defer entries after a recover, since the // corresponding defers will be executed normally // (inline). Any such entry will become stale once // we run the corresponding defers inline and exit // the associated stack frame. d := gp._defer var prev *_defer for d != nil { if d.openDefer { if d.started { // This defer is started but we // are in the middle of a // defer-panic-recover in","date":"2021-01-23","objectID":"https://asong2020.github.io/panic%E5%92%8Crecover/:5:2","tags":["panic"],"title":"详解Go语言中的panic和recover","uri":"https://asong2020.github.io/panic%E5%92%8Crecover/"},{"categories":["Go源码"],"content":"gorecover 这个函数就简单很多了，代码量比较少，先看一下代码吧： // The implementation of the predeclared function recover. // Cannot split the stack because it needs to reliably // find the stack segment of its caller. // // TODO(rsc): Once we commit to CopyStackAlways, // this doesn't need to be nosplit. //go:nosplit func gorecover(argp uintptr) interface{} { // Must be in a function running as part of a deferred call during the panic. // Must be called from the topmost function of the call // (the function used in the defer statement). // p.argp is the argument pointer of that topmost deferred function call. // Compare against argp reported by caller. // If they match, the caller is the one who can recover. gp := getg() p := gp._panic if p != nil \u0026\u0026 !p.goexit \u0026\u0026 !p.recovered \u0026\u0026 argp == uintptr(p.argp) { p.recovered = true return p.arg } return nil } 首先获取当前所在的Goroutine，如果当前Goroutine没有调用panic，那么该函数会直接返回nil，是否能recover住该panic的判断条件必须四个都吻合，p.Goexit判断当前是否是goexit触发的，如果是则无法revocer住，上面讲过会在gopanic中执行进行recover。argp是是最顶层延迟函数调用的实参指针，与调用者的argp进行比较，如果匹配说明调用者是可以recover，直接将recovered字段设置为true就可以了。这里主要的作用就是判断当前panic是否可以recover，具体的恢复逻辑还是由gopanic函数负责的。 ","date":"2021-01-23","objectID":"https://asong2020.github.io/panic%E5%92%8Crecover/:5:3","tags":["panic"],"title":"详解Go语言中的panic和recover","uri":"https://asong2020.github.io/panic%E5%92%8Crecover/"},{"categories":["Go源码"],"content":"流程总结 上面看了一篇源码，肯定也是一脸懵逼吧～。这正常，毕竟文字诉说，只能到这个程度了，还是要自己结合带去去看，这里只是起一个辅助作用，最后做一个流程总结吧。 在程序执行过程中如果遇到panic，那么会调用runtime.gopanic，然后取当前Goroutine的defer链表依次执行。 在调用defer函数是如果有recover就会调用runtime.gorecover，在gorecover中会把runtime._panic中的recoved标记为true，这里只是标记的作用，恢复逻辑仍在runtime.panic中。 在gopanic中会执行defer内联优化、程序恢复逻辑。在程序恢复逻辑中，会进行判断，如果是触发是runtime.Goexit，也会进行recovery。panic也会进行recovery，主要逻辑是runtime.gopanic会从runtime._defer结构体中取出程序计数器pc和栈指针sp并调用runtime.recovery函数恢复程序。runtime.recvoery函数中会根据传入的 pc 和 sp 在gogo中跳转回runtime.deferproc，如果返回值为1，就会调用runtime.deferreturn恢复正常流程。 在gopanic执行完所有的_defer并且也没有遇到recover，那么就会执行runtime.fatalpanic终止程序，并返回错误码2. 这就是这个逻辑流程，累死我了。。。。 ","date":"2021-01-23","objectID":"https://asong2020.github.io/panic%E5%92%8Crecover/:6:0","tags":["panic"],"title":"详解Go语言中的panic和recover","uri":"https://asong2020.github.io/panic%E5%92%8Crecover/"},{"categories":["Go源码"],"content":"小彩蛋 结尾给大家发一个小福利，哈哈，这个福利就是如果避免出现panic，要注意这些： 数组/切片下标越界，对于go这种静态语言来说，下标越界是致命问题。 不要访问未初始化的指针或nil指针 不要往已经close的chan里发送数据 map不是线程安全的，不要并发读写map 这几个是比较典型的，还有很多会发生panic的地方，交给你们自行学习吧～。 ","date":"2021-01-23","objectID":"https://asong2020.github.io/panic%E5%92%8Crecover/:7:0","tags":["panic"],"title":"详解Go语言中的panic和recover","uri":"https://asong2020.github.io/panic%E5%92%8Crecover/"},{"categories":["Go源码"],"content":"总结 好啦，这篇文章就到这里啦，素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！ 创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：加我vx拉你入群，或者公众号获取入群二维码 结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。 我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。 翻译了一份Machinery中文文档，会定期进行维护，有需要的小伙伴们后台回复[machinery]即可获取。 **我是asong，一名普普通通的程序猿，让我们一起慢慢变强吧。欢迎各位的关注，我们下期见~~~** 推荐往期文章： machinery-go异步任务队列 详解defer实现机制 真的理解interface了嘛 Leaf—Segment分布式ID生成系统（Golang实现版本） 十张动图带你搞懂排序算法(附go实现代码) go参数传递类型 手把手教姐姐写消息队列 常见面试题之缓存雪崩、缓存穿透、缓存击穿 详解Context包，看这一篇就够了！！！ go-ElasticSearch入门看这一篇就够了(一) 面试官：go中for-range使用过吗？这几个问题你能解释一下原因吗 ","date":"2021-01-23","objectID":"https://asong2020.github.io/panic%E5%92%8Crecover/:8:0","tags":["panic"],"title":"详解Go语言中的panic和recover","uri":"https://asong2020.github.io/panic%E5%92%8Crecover/"},{"categories":["Go源码"],"content":"前言 嗨，大家好，我是asong，鸽了好久，其实元旦就想写一下这篇文章，但是因为喝酒喝断片了，养了三天才缓过来，就推迟到这个周末了，不过多追溯了，有点丢人。今天与大家来聊一聊go中的关键字defer，目前很多编程语言中都有defer关键字，而go语言的defer用于资源的释放，会在函数返回之前进行调用，它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源。下面我们就深入Go语言源码介绍defer关键字的实现原理。 文末尾给你们留了三道题，检测一下学习成果吧～ ","date":"2021-01-10","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:1:0","tags":["defer"],"title":"详解defer实现机制(附上三道面试题，我不信你们都能做对)","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["Go源码"],"content":"基本使用 我们首先来看一看defer关键字是怎么使用的，一个经典的场景就是我们在使用事务时，发生错误需要回滚，这时我们就可以用使用defer来保证程序退出时保证事务回滚，示例代码如下： // 代码摘自之前写的 Leaf-segment数据库获取ID方案：https://github.com/asong2020/go-algorithm/blob/master/leaf/dao/leaf_dao.go func (l *LeafDao) NextSegment(ctx context.Context, bizTag string) (*model.Leaf, error) { // 开启事务 tx, err := l.sql.Begin() defer func() { if err != nil { l.rollback(tx) } }() if err = l.checkError(err); err != nil { return nil, err } err = l.db.UpdateMaxID(ctx, bizTag, tx) if err = l.checkError(err); err != nil { return nil, err } leaf, err := l.db.Get(ctx, bizTag, tx) if err = l.checkError(err); err != nil { return nil, err } // 提交事务 err = tx.Commit() if err = l.checkError(err); err != nil { return nil, err } return leaf, nil } 上面只是一个简单的应用，defer还有一些特性，如果你不知道，使用起来可能会踩到一些坑，尤其是跟带命名的返回参数一起使用时。下面我们我先来带大家踩踩坑。 ","date":"2021-01-10","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:2:0","tags":["defer"],"title":"详解defer实现机制(附上三道面试题，我不信你们都能做对)","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["Go源码"],"content":"defer的注意事项和细节 ","date":"2021-01-10","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:3:0","tags":["defer"],"title":"详解defer实现机制(附上三道面试题，我不信你们都能做对)","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["Go源码"],"content":"defer调用顺序 我们先来看一道题，你能说他的答案吗？ func main() { fmt.Println(\"reciprocal\") for i := 0; i \u003c 10; i++ { defer fmt.Println(i) } } 答案： reciprocal 9 8 7 6 5 4 3 2 1 0 看到答案，你是不是产生了疑问？这就对了，我最开始学golang时也有这个疑问，这个跟栈一样，即\"先进后出\"特性，越后面的defer表达式越先被调用。所以这里大家关闭依赖资源时一定要注意defer调用顺序。 ","date":"2021-01-10","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:3:1","tags":["defer"],"title":"详解defer实现机制(附上三道面试题，我不信你们都能做对)","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["Go源码"],"content":"defer拷贝 我们先来看这样一段代码，你能说出defer中num1和num2的值是多少吗？ func main() { fmt.Println(Sum(1, 2)) } func Sum(num1, num2 int) int { defer fmt.Println(\"num1:\", num1) defer fmt.Println(\"num2:\", num2) num1++ num2++ return num1 + num2 } 聪明的你一定会说：“这也太简单了，答案就是num1等于2，num2等于3”。很遗憾的告诉你，错了，正确的答案是num1为1,num2为2，这两个变量并不受num1++、num2++的影响，因为defer将语句放入到栈中时，也会将相关的值拷贝同时入栈。 ","date":"2021-01-10","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:3:2","tags":["defer"],"title":"详解defer实现机制(附上三道面试题，我不信你们都能做对)","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["Go源码"],"content":"defer与return的返回时机 这里我先说结论，总结一下就是，函数的整个返回过程应该是： return 对返回变量赋值，如果是匿名返回值就先声明再赋值； 执行 defer 函数； return 携带返回值返回。 下面我们来看两道题，你知道他们的返回值是多少吗？ 匿名返回值函数 // 匿名函数 func Anonymous() int { var i int defer func() { i++ fmt.Println(\"defer2 value is \", i) }() defer func() { i++ fmt.Println(\"defer1 in value is \", i) }() return i } 命名返回值的函数 func HasName() (j int) { defer func() { j++ fmt.Println(\"defer2 in value\", j) }() defer func() { j++ fmt.Println(\"defer1 in value\", j) }() return j } 先来公布一下答案吧： 1. Anonymous()的返回值为0 2. HasName()的返回值为2 从这我们可以看出命名返回值的函数的返回值被 defer 修改了。这里想必大家跟我一样，都很疑惑，带着疑惑我查阅了一下go官方文档，文档指出，defer的执行顺序有以下三个规则： A deferred function’s arguments are evaluated when the defer statement is evaluated. Deferred function calls are executed in Last In First Out order after the surrounding function returns. Deferred functions may read and assign to the returning function’s named return values. 规则3就可以印证为什么命名返回值的函数的返回值被更改了，其实在函数最终返回前，defer 函数就已经执行了，在命名返回值的函数 中，由于返回值已经被提前声明，所以 defer 函数能够在 return 语句对返回值赋值之后，继续对返回值进行操作，操作的是同一个变量，而匿名返回值函数中return先返回，已经进行了一次值拷贝r=i，defer函数中再次对变量i的操作并不会影响返回值。 这里可能有些小伙伴还不是很懂，我在讲一下return返回步骤，相信你们会豁然开朗。 函数在返回时，首先函数返回时会自动创建一个返回变量假设为ret(如果是命名返回值的函数则不会创建)，函数返回时要将变量i赋值给ret，即有ret = i。 然后检查函数中是否有defer存在，若有则执行defer中部分。 最后返回ret 现在你们应该知道上面是什么原因了吧～。 ","date":"2021-01-10","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:4:0","tags":["defer"],"title":"详解defer实现机制(附上三道面试题，我不信你们都能做对)","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["Go源码"],"content":"解密defer源码 写在开头：go版本1.15.3 我们先来写一段代码，查看一下汇编代码： func main() { defer func() { fmt.Println(\"asong 真帅\") }() } 执行如下指令：go tool compile -N -l -S main.go，截取部分汇编指令如下： 我们可以看出来，从执行流程来看首先会调用deferproc来创建defer，然后在函数返回时插入了指令CALL runtime.deferreturn。知道了defer在流程中是通过这两个方法是调用的，接下来我们来看一看defer的结构： // go/src/runtime/runtime2.go type _defer struct { siz int32 // includes both arguments and results started bool heap bool // openDefer indicates that this _defer is for a frame with open-coded // defers. We have only one defer record for the entire frame (which may // currently have 0, 1, or more defers active). openDefer bool sp uintptr // sp at time of defer pc uintptr // pc at time of defer fn *funcval // can be nil for open-coded defers _panic *_panic // panic that is running defer link *_defer // If openDefer is true, the fields below record values about the stack // frame and associated function that has the open-coded defer(s). sp // above will be the sp for the frame, and pc will be address of the // deferreturn call in the function. fd unsafe.Pointer // funcdata for the function associated with the frame varp uintptr // value of varp for the stack frame // framepc is the current pc associated with the stack frame. Together, // with sp above (which is the sp associated with the stack frame), // framepc/sp can be used as pc/sp pair to continue a stack trace via // gentraceback(). framepc uintptr } 这里简单介绍一下runtime._defer结构体中的几个字段： siz代表的是参数和结果的内存大小 sp和pc分别代表栈指针和调用方的程序计数器 fn代表的是defer关键字中传入的函数 _panic是触发延迟调用的结构体，可能为空 openDefer表示的是当前defer是否已经开放编码优化(1.14版本新增) link所有runtime._defer结构体都通过该字段串联成链表 先来我们也知道了defer关键字的数据结构了，下面我们就来重点分析一下deferproc和deferreturn函数是如何调用。 ","date":"2021-01-10","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:5:0","tags":["defer"],"title":"详解defer实现机制(附上三道面试题，我不信你们都能做对)","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["Go源码"],"content":"deferproc函数 deferproc函数也不长，我先贴出来代码； // proc/panic.go // Create a new deferred function fn with siz bytes of arguments. // The compiler turns a defer statement into a call to this. //go:nosplit func deferproc(siz int32, fn *funcval) { // arguments of fn follow fn gp := getg() if gp.m.curg != gp { // go code on the system stack can't defer throw(\"defer on system stack\") } // the arguments of fn are in a perilous state. The stack map // for deferproc does not describe them. So we can't let garbage // collection or stack copying trigger until we've copied them out // to somewhere safe. The memmove below does that. // Until the copy completes, we can only call nosplit routines. sp := getcallersp() argp := uintptr(unsafe.Pointer(\u0026fn)) + unsafe.Sizeof(fn) callerpc := getcallerpc() d := newdefer(siz) if d._panic != nil { throw(\"deferproc: d.panic != nil after newdefer\") } d.link = gp._defer gp._defer = d d.fn = fn d.pc = callerpc d.sp = sp switch siz { case 0: // Do nothing. case sys.PtrSize: *(*uintptr)(deferArgs(d)) = *(*uintptr)(unsafe.Pointer(argp)) default: memmove(deferArgs(d), unsafe.Pointer(argp), uintptr(siz)) } // deferproc returns 0 normally. // a deferred func that stops a panic // makes the deferproc return 1. // the code the compiler generates always // checks the return value and jumps to the // end of the function if deferproc returns != 0. return0() // No code can go here - the C return register has // been set and must not be clobbered. } 上面介绍了rumtiem._defer结构想必这里的入参是什么意思就不用我介绍了吧。 deferproc的函数流程很清晰，首先他会通过newdefer函数分配一个_defer结构对象，然后把需要延迟执行的函数以及该函数需要用到的参数、调用deferproc函数时的rps寄存器的值以及deferproc函数的返回地址保存在_defer结构体对象中，最后通过return0()设置rax寄存器的值为0隐性的给调用者返回一个0值。deferproc主要是靠newdefer来分配_defer结构体对象的，下面我们一起来看看newdefer实现，代码有点长： // proc/panic.go // Allocate a Defer, usually using per-P pool. // Each defer must be released with freedefer. The defer is not // added to any defer chain yet. // // This must not grow the stack because there may be a frame without // stack map information when this is called. // //go:nosplit func newdefer(siz int32) *_defer { var d *_defer sc := deferclass(uintptr(siz)) gp := getg()//获取当前goroutine的g结构体对象 if sc \u003c uintptr(len(p{}.deferpool)) { pp := gp.m.p.ptr() //与当前工作线程绑定的p if len(pp.deferpool[sc]) == 0 \u0026\u0026 sched.deferpool[sc] != nil { // Take the slow path on the system stack so // we don't grow newdefer's stack. systemstack(func() { lock(\u0026sched.deferlock) //把新分配出来的d放入当前goroutine的_defer链表头 for len(pp.deferpool[sc]) \u003c cap(pp.deferpool[sc])/2 \u0026\u0026 sched.deferpool[sc] != nil { d := sched.deferpool[sc] sched.deferpool[sc] = d.link d.link = nil pp.deferpool[sc] = append(pp.deferpool[sc], d) } unlock(\u0026sched.deferlock) }) } if n := len(pp.deferpool[sc]); n \u003e 0 { d = pp.deferpool[sc][n-1] pp.deferpool[sc][n-1] = nil pp.deferpool[sc] = pp.deferpool[sc][:n-1] } } if d == nil { //如果p的缓存中没有可用的_defer结构体对象则从堆上分配 // Allocate new defer+args. //因为roundupsize以及mallocgc函数都不会处理扩栈，所以需要切换到系统栈执行 // Allocate new defer+args. systemstack(func() { total := roundupsize(totaldefersize(uintptr(siz))) d = (*_defer)(mallocgc(total, deferType, true)) }) if debugCachedWork { // Duplicate the tail below so if there's a // crash in checkPut we can tell if d was just // allocated or came from the pool. d.siz = siz //把新分配出来的d放入当前goroutine的_defer链表头 d.link = gp._defer gp._defer = d return d } } d.siz = siz d.heap = true return d } newdefer函数首先会尝试从当前工作线程绑定的p的_defer对象池和全局对象池中获取一个满足大小要求(sizeof(_defer) + siz向上取整至16的倍数)的 _defer 结构体对象，如果没有能够满足要求的空闲 _defer 对象则从堆上分一个，最后把分配到的对象链入当前 goroutine 的 _defer 链表的表头。 到此deferproc函数就分析完了，你们懂了吗? 没懂不要紧，我们再来总结一下这个过程： 首先编译器把defer语句翻译成对应的deferproc函数的调用 然后deferproc函数通过newdefer函数分配一个_defer结构体对象并放入当前的goroutine的_defer链表的表头； 在 _defer 结构体对象中保存被延迟执行的函数 fn 的地址以及 fn 所需的参数 返回到调用 deferproc 的函数继续执行后面的代码。 ","date":"2021-01-10","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:5:1","tags":["defer"],"title":"详解defer实现机制(附上三道面试题，我不信你们都能做对)","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["Go源码"],"content":"deferreturn函数 // Run a deferred function if there is one. // The compiler inserts a call to this at the end of any // function which calls defer. // If there is a deferred function, this will call runtime·jmpdefer, // which will jump to the deferred function such that it appears // to have been called by the caller of deferreturn at the point // just before deferreturn was called. The effect is that deferreturn // is called again and again until there are no more deferred functions. // // Declared as nosplit, because the function should not be preempted once we start // modifying the caller's frame in order to reuse the frame to call the deferred // function. // // The single argument isn't actually used - it just has its address // taken so it can be matched against pending defers. //go:nosplit func deferreturn(arg0 uintptr) { gp := getg() //获取当前goroutine对应的g结构体对象 d := gp._defer //获取当前goroutine对应的g结构体对象 if d == nil { //没有需要执行的函数直接返回，deferreturn和deferproc是配对使用的 //为什么这里d可能为nil？因为deferreturn其实是一个递归调用，这个是递归结束条件之一 return } sp := getcallersp() //获取调用deferreturn时的栈顶位置 if d.sp != sp { // 递归结束条件 //如果保存在_defer对象中的sp值与调用deferretuen时的栈顶位置不一样，直接返回 //因为sp不一样表示d代表的是在其他函数中通过defer注册的延迟调用函数，比如: //a()-\u003eb()-\u003ec()它们都通过defer注册了延迟函数，那么当c()执行完时只能执行在c中注册的函数 return } if d.openDefer { done := runOpenDeferFrame(gp, d) if !done { throw(\"unfinished open-coded defers in deferreturn\") } gp._defer = d.link freedefer(d) return } // Moving arguments around. // // Everything called after this point must be recursively // nosplit because the garbage collector won't know the form // of the arguments until the jmpdefer can flip the PC over to // fn. //把保存在_defer对象中的fn函数需要用到的参数拷贝到栈上，准备调用fn //注意fn的参数放在了调用调用者的栈帧中，而不是此函数的栈帧中 switch d.siz { case 0: // Do nothing. case sys.PtrSize: *(*uintptr)(unsafe.Pointer(\u0026arg0)) = *(*uintptr)(deferArgs(d)) default: memmove(unsafe.Pointer(\u0026arg0), deferArgs(d), uintptr(d.siz)) } fn := d.fn d.fn = nil gp._defer = d.link // 使gp._defer指向下一个_defer结构体对象 //因为需要调用的函数d.fn已经保存在了fn变量中，它的参数也已经拷贝到了栈上，所以释放_defer结构体对象 freedefer(d) // If the defer function pointer is nil, force the seg fault to happen // here rather than in jmpdefer. gentraceback() throws an error if it is // called with a callback on an LR architecture and jmpdefer is on the // stack, because the stack trace can be incorrect in that case - see // issue #8153). _ = fn.fn jmpdefer(fn, uintptr(unsafe.Pointer(\u0026arg0))) } deferreturn函数主要流程还是简单一些的，我们来分析一下： 首先我们通过当前goroutine对应的g结构体对象的_defer链表判断是否有需要执行的defered函数，如果没有则返回；这里的没有是指g._defer== nil 或者defered函数不是在deferteturn的caller函数中注册的函数。 然后我们在从_defer对象中把defered函数需要的参数拷贝到栈上，并释放_defer的结构体对象。 最红调用jmpderfer函数调用defered函数，也就是defer关键字中传入的函数. jmpdefer函数实现挺优雅的，我们一起来看看他是如何实现的： // runtime/asm_amd64.s : 581 // func jmpdefer(fv *funcval, argp uintptr) // argp is a caller SP. // called from deferreturn. // 1. pop the caller // 2. sub 5 bytes from the callers return // 3. jmp to the argument TEXT runtime·jmpdefer(SB), NOSPLIT, $0-16 MOVQ fv+0(FP), DX // fn MOVQ argp+8(FP), BX // caller sp LEAQ -8(BX), SP // caller sp after CALL MOVQ -8(SP), BP // restore BP as if deferreturn returned (harmless if framepointers not in use) SUBQ $5, (SP) // return to CALL again MOVQ 0(DX), BX JMP BX // but first run the deferred function 这里都是汇编，大家可能看不懂，没关系，我只是简单介绍一下这里，有兴趣的同学可以去查阅一下相关知识再来深入了解。 MOVQ fv+0(FP), DX这条指令会把jmpdefer的第一个参数也就是结构体对象fn的地址存放入DX寄存器，之后的代码就可以通过寄存器访问到fn，fn就可以拿到defer关键字中传入的函数，对应上面的例子就是匿名函数func(){}(). MOVQ argp+8(FP), BX这条指令就是把jmpdefer的第二个参数放入BX寄存器，该参数是一个指针，他指向defer关键字中传入的函数的第一个参数. LEAQ -8(BX), SP这条指令的作用是让 SP 寄存器指向 deferreturn 函数的返回地址所在的栈内存单元. MOVQ -8(SP), BP这条指令的作用是调整 BP 寄存器的值，此时SP_8的位置存放的是defer关键字当前所在的函数的rbp寄存器的值，所以这条指令在调整rbp寄存器的值使其指向当前所在函数的栈帧的适当位置. SUBQ $5, (SP)这里的作用是完成defer函数的参数以及执行完函数后返回地址在栈上的构造.因为在执行这条指令时，rsp寄存器指向的是deferreturn函数的返回地址. MOVQ 0(DX), BX和JMP BX放到一起说吧，目的是跳转到对应defer函数去执行，完成defer函数的调用. ","date":"2021-01-10","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:5:2","tags":["defer"],"title":"详解defer实现机制(附上三道面试题，我不信你们都能做对)","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["Go源码"],"content":"总结 大概分析了一下defer的实现机制，但还是有点蒙圈，最后在总结一下这里： 首先编译器会把defer语句翻译成对deferproc函数的调用。 然后deferproc函数会负责调用newdefer函数分配一个_defer结构体对象并放入当前的goroutine的_defer链表的表头； 然后编译起会在defer所在函数的结尾处插入对deferreturn的调用，deferreturn负责递归的调用某函数(defer语句所在函数)通过defer语句注册的函数。 总体来说就是这三个步骤，go语言对defer的实现机制就是这样啦，你明白了吗？ ","date":"2021-01-10","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:5:3","tags":["defer"],"title":"详解defer实现机制(附上三道面试题，我不信你们都能做对)","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["Go源码"],"content":"小试牛刀 上面我们也细致学习了一下defer，下面出几道题吧，看看你们真的学会了吗？ ","date":"2021-01-10","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:6:0","tags":["defer"],"title":"详解defer实现机制(附上三道面试题，我不信你们都能做对)","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["Go源码"],"content":"问题1 // 测试1 func Test1() (r int) { i := 1 defer func() { i = i + 1 }() return i } 返回结果是什么？ ","date":"2021-01-10","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:6:1","tags":["defer"],"title":"详解defer实现机制(附上三道面试题，我不信你们都能做对)","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["Go源码"],"content":"问题2 func Test2() (r int) { defer func(r int) { r = r + 2 }(r) return 2 } 返回结果是什么？ 如果改成这样呢？ func Test3() (r int) { defer func(r *int) { *r = *r + 2 }(\u0026r) return 2 } ","date":"2021-01-10","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:6:2","tags":["defer"],"title":"详解defer实现机制(附上三道面试题，我不信你们都能做对)","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["Go源码"],"content":"问题3 func main(){ e1() e2() e3() } func e1() { var err error defer fmt.Println(err) err = errors.New(\"e1 defer err\") } func e2() { var err error defer func() { fmt.Println(err) }() err = errors.New(\"e2 defer err\") } func e3() { var err error defer func(err error) { fmt.Println(err) }(err) err = errors.New(\"e3 defer err\") } 这个返回结果又是什么呢？ ","date":"2021-01-10","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:6:3","tags":["defer"],"title":"详解defer实现机制(附上三道面试题，我不信你们都能做对)","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["Go源码"],"content":"总结 最后这三道题这里就当作思考题吧，自己运行一下，看看你们想的和运行结果是否一致呢？ 如果有问题欢迎来找我讨论，因为目前没有留言功能，大家可以加入我的交流群，我们一起交流成长。因为是微信群，会有过期时间，所以大家关注我的公众号，获取入群二维码，或者添加我的个人微信，我拉你入群。 好啦，这篇文章就到这里啦，素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！ 结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。 我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。 翻译了一份Machinery中文文档，会定期进行维护，有需要的小伙伴们后台回复[machinery]即可获取。 **我是asong，一名普普通通的程序猿，让gi我一起慢慢变强吧。欢迎各位的关注，我们下期见~~~** 推荐往期文章： machinery-go异步任务队列 Leaf—Segment分布式ID生成系统（Golang实现版本） 十张动图带你搞懂排序算法(附go实现代码) Go语言相关书籍推荐（从入门到放弃） go参数传递类型 手把手教姐姐写消息队列 常见面试题之缓存雪崩、缓存穿透、缓存击穿 详解Context包，看这一篇就够了！！！ go-ElasticSearch入门看这一篇就够了(一) 面试官：go中for-range使用过吗？这几个问题你能解释一下原因吗 学会wire依赖注入、cron定时任务其实就这么简单！ ","date":"2021-01-10","objectID":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:7:0","tags":["defer"],"title":"详解defer实现机制(附上三道面试题，我不信你们都能做对)","uri":"https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["Go源码"],"content":"前言 我想，对于各位使用面向对象编程的程序员来说，“接口\"这个名词一定不陌生，比如java中的接口以及c++中的虚基类都是接口的实现。但是golang中的接口概念确与其他语言不同，有它自己的特点，下面我们就来一起解密。 ","date":"2020-12-20","objectID":"https://asong2020.github.io/%E7%90%86%E8%A7%A3interface/:1:0","tags":["interface"],"title":"源码剖析Go语言的interface","uri":"https://asong2020.github.io/%E7%90%86%E8%A7%A3interface/"},{"categories":["Go源码"],"content":"定义 Go 语言中的接口是一组方法的签名，它是 Go 语言的重要组成部分。简单的说，interface是一组method签名的组合，我们通过interface来定义对象的一组行为。interface 是一种类型，定义如下： type Person interface { Eat(food string) } 它的定义可以看出来用了 type 关键字，更准确的说 interface 是一种具有一组方法的类型，这些方法定义了 interface 的行为。golang接口定义不能包含变量，但是允许不带任何方法，这种类型的接口叫empty interface。 如果一个类型实现了一个interface中所有方法，我们就可以说该类型实现了该interface，所以我们我们的所有类型都实现了empty interface，因为任何一种类型至少实现了0个方法。并且go中并不像java中那样需要显式关键字来实现interface，只需要实现interface包含的方法即可。 ","date":"2020-12-20","objectID":"https://asong2020.github.io/%E7%90%86%E8%A7%A3interface/:2:0","tags":["interface"],"title":"源码剖析Go语言的interface","uri":"https://asong2020.github.io/%E7%90%86%E8%A7%A3interface/"},{"categories":["Go源码"],"content":"实现接口 这里先拿java语言来举例，在java中，我们要实现一个interface需要这样声明： public class MyWriter implments io.Writer{} 这就意味着对于接口的实现都需要显示声明，在代码编写方面有依赖限制，同时需要处理包的依赖，而在Go语言中实现接口就是隐式的，举例说明： type error interface { Error() string } type RPCError struct { Code int64 Message string } func (e *RPCError) Error() string { return fmt.Sprintf(\"%s, code=%d\", e.Message, e.Code) } 上面的代码，并没有error接口的影子，我们只需要实现Error() string方法就实现了error接口。在Go中，实现接口的所有方法就隐式地实现了接口。我们使用上述 RPCError 结构体时并不关心它实现了哪些接口，Go 语言只会在传递参数、返回参数以及变量赋值时才会对某个类型是否实现接口进行检查。 Go语言的这种写法很方便，不用引入包依赖。但是interface底层实现的时候会动态检测也会引入一些问题： 性能下降。使用interface作为函数参数，runtime 的时候会动态的确定行为。使用具体类型则会在编译期就确定类型。 不能清楚的看出struct实现了哪些接口，需要借助ide或其它工具。 ","date":"2020-12-20","objectID":"https://asong2020.github.io/%E7%90%86%E8%A7%A3interface/:2:1","tags":["interface"],"title":"源码剖析Go语言的interface","uri":"https://asong2020.github.io/%E7%90%86%E8%A7%A3interface/"},{"categories":["Go源码"],"content":"两种接口 这里大多数刚入门的同学肯定会有疑问，怎么会有两种接口，因为Go语言中接口会有两种表现形式，使用runtime.iface表示第一种接口，也就是我们上面实现的这种，接口中定义方法；使用runtime.eface表示第二种不包含任何方法的接口，第二种在我们日常开发中经常使用到，所以在实现时使用了特殊的类型。从编译角度来看，golang并不支持泛型编程。但还是可以用interface{} 来替换参数，而实现泛型。 ","date":"2020-12-20","objectID":"https://asong2020.github.io/%E7%90%86%E8%A7%A3interface/:3:0","tags":["interface"],"title":"源码剖析Go语言的interface","uri":"https://asong2020.github.io/%E7%90%86%E8%A7%A3interface/"},{"categories":["Go源码"],"content":"interface内部结构 Go 语言根据接口类型是否包含一组方法将接口类型分成了两类： 使用 runtime.iface 结构体表示包含方法的接口 使用 runtime.eface 结构体表示不包含任何方法的 interface{} 类型； runtime.iface结构体在Go语言中的定义是这样的： type eface struct { // 16 字节 _type *_type data unsafe.Pointer } 这里只包含指向底层数据和类型的两个指针，从这个type我们也可以推断出Go语言的任意类型都可以转换成interface。 另一个用于表示接口的结构体是 runtime.iface，这个结构体中有指向原始数据的指针 data，不过更重要的是 runtime.itab 类型的 tab 字段。 type iface struct { // 16 字节 tab *itab data unsafe.Pointer } 下面我们一起看看interface中这两个类型： runtime_type runtime_type是 Go 语言类型的运行时表示。下面是运行时包中的结构体，其中包含了很多类型的元信息，例如：类型的大小、哈希、对齐以及种类等。 type _type struct { size uintptr ptrdata uintptr hash uint32 tflag tflag align uint8 fieldAlign uint8 kind uint8 equal func(unsafe.Pointer, unsafe.Pointer) bool gcdata *byte str nameOff ptrToThis typeOff } 这里我只对几个比较重要的字段进行讲解： size 字段存储了类型占用的内存空间，为内存空间的分配提供信息； hash 字段能够帮助我们快速确定类型是否相等； equal 字段用于判断当前类型的多个对象是否相等，该字段是为了减少 Go 语言二进制包大小从 typeAlg 结构体中迁移过来的)； runtime_itab runtime.itab结构体是接口类型的核心组成部分，每一个 runtime.itab 都占 32 字节，我们可以将其看成接口类型和具体类型的组合，它们分别用 inter 和 _type 两个字段表示： type itab struct { // 32 字节 inter *interfacetype _type *_type hash uint32 _ [4]byte fun [1]uintptr } inter和_type是用于表示类型的字段，hash是对_type.hash的拷贝，当我们想将 interface 类型转换成具体类型时，可以使用该字段快速判断目标类型和具体类型 runtime._type是否一致，fun是一个动态大小的数组，它是一个用于动态派发的虚函数表，存储了一组函数指针。虽然该变量被声明成大小固定的数组，但是在使用时会通过原始指针获取其中的数据，所以 fun 数组中保存的元素数量是不确定的； 内部结构就做一个简单介绍吧，有兴趣的同学可以自行深入学习。 ","date":"2020-12-20","objectID":"https://asong2020.github.io/%E7%90%86%E8%A7%A3interface/:3:1","tags":["interface"],"title":"源码剖析Go语言的interface","uri":"https://asong2020.github.io/%E7%90%86%E8%A7%A3interface/"},{"categories":["Go源码"],"content":"空的interface（runtime.eface） 前文已经介绍了什么是空的interface，下面我们来看一看空的interface如何使用。定义函数入参如下： func doSomething(v interface{}){ } 这个函数的入参是interface类型，要注意的是，interface类型不是任意类型，他与C语言中的void *不同，如果我们将类型转换成了 interface{} 类型，变量在运行期间的类型也会发生变化，获取变量类型时会得到 interface{}，之所以函数可以接受任何类型是在 go 执行时传递到函数的任何类型都被自动转换成 interface{}。 那么我们可以才来一个猜想，既然空的 interface 可以接受任何类型的参数，那么一个 interface{}类型的 slice 是不是就可以接受任何类型的 slice ？下面我们就来尝试一下： import ( \"fmt\" ) func printStr(str []interface{}) { for _, val := range str { fmt.Println(val) } } func main(){ names := []string{\"stanley\", \"david\", \"oscar\"} printStr(names) } 运行上面代码，会出现如下错误：./main.go:15:10: cannot use names (type []string) as type []interface {} in argument to printStr。 这里我也是很疑惑，为什么Go没有帮助我们自动把slice转换成interface类型的slice，之前做项目就想这么用，结果失败了。后来我终于找到了答案，有兴趣的可以看看原文，这里简单总结一下：interface会占用两个字长的存储空间，一个是自身的 methods 数据，一个是指向其存储值的指针，也就是 interface 变量存储的值，因而 slice []interface{} 其长度是固定的N*2，但是 []T 的长度是N*sizeof(T)，两种 slice 实际存储值的大小是有区别的。 既然这种方法行不通，那可以怎样解决呢？我们可以直接使用元素类型是interface的切片。 var dataSlice []int = foo() var interfaceSlice []interface{} = make([]interface{}, len(dataSlice)) for i, d := range dataSlice { interfaceSlice[i] = d } ","date":"2020-12-20","objectID":"https://asong2020.github.io/%E7%90%86%E8%A7%A3interface/:3:2","tags":["interface"],"title":"源码剖析Go语言的interface","uri":"https://asong2020.github.io/%E7%90%86%E8%A7%A3interface/"},{"categories":["Go源码"],"content":"非空interface Go语言实现接口时，既可以结构体类型的方法也可以是使用指针类型的方法。Go语言中并没有严格规定实现者的方法是值类型还是指针，那我们猜想一下，如果同时使用值类型和指针类型方法实现接口，会有什么问题吗？ 先看这样一个例子： package main import ( \"fmt\" ) type Person interface { GetAge () int SetAge (int) } type Man struct { Name string Age int } func(s Man) GetAge()int { return s.Age } func(s *Man) SetAge(age int) { s.Age = age } func f(p Person){ p.SetAge(10) fmt.Println(p.GetAge()) } func main() { p := Man{} f(\u0026p) } 看上面的代码，大家对f(\u0026p)这里的入参是否会有疑问呢？如果不取地址，直接传过去会怎么样？试了一下，编译错误如下：./main.go:34:3: cannot use p (type Man) as type Person in argument to f: Man does not implement Person (SetAge method has pointer receiver)。透过注释我们可以看到，因为SetAge方法的receiver是指针类型，那么传递给f的是P的一份拷贝，在进行p的拷贝到person的转换时，p的拷贝是不满足SetAge方法的receiver是个指针类型，这也正说明一个问题go中函数都是按值传递。 上面的例子是因为发生了值传递才会导致出现这个问题。实际上不管接收者类型是值类型还是指针类型，都可以通过值类型或指针类型调用，这里面实际上通过语法糖起作用的。实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法；而实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法。 举个例子： type Animal interface { Walk() Eat() } type Dog struct { Name string } func (d *Dog)Walk() { fmt.Println(\"go\") } func (d *Dog)Eat() { fmt.Println(\"eat shit\") } func main() { var d Animal = \u0026Dog{\"nene\"} d.Eat() d.Walk() } 上面定义了一个接口Animal，接口定义了两个函数： Walk() Eat() 接着定义了一个结构体Dog，他实现了两个方法，一个是值接受者，一个是指针接收者。我们通过接口类型的变量调用了定义的两个函数是没有问题的，如果我们改成这样呢： func main() { var d Animal = Dog{\"nene\"} d.Eat() d.Walk() } 这样直接就会报错，我们只改了一部分，第一次将\u0026Dog{\"nene\"}赋值给了d；第二次则将Dog{\"nene\"}赋值给了d。第二次报错是因为，d没有实现Animal。这正解释了上面的结论，所以，当实现了一个接收者是值类型的方法，就可以自动生成一个接收者是对应指针类型的方法，因为两者都不会影响接收者。但是，当实现了一个接收者是指针类型的方法，如果此时自动生成一个接收者是值类型的方法，原本期望对接收者的改变（通过指针实现），现在无法实现，因为值类型会产生一个拷贝，不会真正影响调用者。 总结一句话就是：如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法。 ","date":"2020-12-20","objectID":"https://asong2020.github.io/%E7%90%86%E8%A7%A3interface/:3:3","tags":["interface"],"title":"源码剖析Go语言的interface","uri":"https://asong2020.github.io/%E7%90%86%E8%A7%A3interface/"},{"categories":["Go源码"],"content":"类型断言 一个interface被多种类型实现时，有时候我们需要区分interface的变量究竟存储哪种类型的值，go可以使用comma,ok的形式做区分 value, ok := em.(T)：em 是 interface 类型的变量，T代表要断言的类型，value 是 interface 变量存储的值，ok 是 bool 类型表示是否为该断言的类型 T。总结出来语法如下： \u003c目标类型的值\u003e，\u003c布尔参数\u003e := \u003c表达式\u003e.( 目标类型 ) // 安全类型断言 \u003c目标类型的值\u003e := \u003c表达式\u003e.( 目标类型 )　//非安全类型断言 看个简单的例子： type Dog struct { Name string } func main() { var d interface{} = new(Dog) d1,ok := d.(Dog) if !ok{ return } fmt.Println(d1) } 这种就属于安全类型断言，更适合在线上代码使用，如果使用非安全类型断言会怎么样呢？ type Dog struct { Name string } func main() { var d interface{} = new(Dog) d1 := d.(Dog) fmt.Println(d1) } 这样就会发生错误如下： panic: interface conversion: interface {} is *main.Dog, not main.Dog 断言失败。这里直接发生了 panic，所以不建议线上代码使用。 看过fmt源码包的同学应该知道，fmt.println内部就是使用到了类型断言，有兴趣的同学可以自行学习。 ","date":"2020-12-20","objectID":"https://asong2020.github.io/%E7%90%86%E8%A7%A3interface/:4:0","tags":["interface"],"title":"源码剖析Go语言的interface","uri":"https://asong2020.github.io/%E7%90%86%E8%A7%A3interface/"},{"categories":["Go源码"],"content":"问题 上面介绍了interface的基本使用方法及可能会遇到的一些问题，下面出三个题，看看你们真的掌握了吗？ ","date":"2020-12-20","objectID":"https://asong2020.github.io/%E7%90%86%E8%A7%A3interface/:5:0","tags":["interface"],"title":"源码剖析Go语言的interface","uri":"https://asong2020.github.io/%E7%90%86%E8%A7%A3interface/"},{"categories":["Go源码"],"content":"问题一 下面代码，哪一行存在编译错误？（多选） type Student struct { } func Set(x interface{}) { } func Get(x *interface{}) { } func main() { s := Student{} p := \u0026s // A B C D Set(s) Get(s) Set(p) Get(p) } 答案：B、D；解析：我们上文提到过，interface是所有go类型的父类，所以Get方法只能接口*interface{}类型的参数，其他任何类型都不可以。 ","date":"2020-12-20","objectID":"https://asong2020.github.io/%E7%90%86%E8%A7%A3interface/:5:1","tags":["interface"],"title":"源码剖析Go语言的interface","uri":"https://asong2020.github.io/%E7%90%86%E8%A7%A3interface/"},{"categories":["Go源码"],"content":"问题二 这段代码的运行结果是什么？ func PrintInterface(val interface{}) { if val == nil { fmt.Println(\"this is empty interface\") return } fmt.Println(\"this is non-empty interface\") } func main() { var pointer *string = nil PrintInterface(pointer) } 答案：this is non-empty interface。解析：这里的interface{}是空接口类型，他的结构如下: type eface struct { // 16 字节 _type *_type data unsafe.Pointer } 所以在调用函数PrintInterface时发生了隐式的类型转换，除了向方法传入参数之外，变量的赋值也会触发隐式类型转换。在类型转换时，*string类型会转换成interface类型，发生值拷贝，所以eface struct{}是不为nil，不过data指针指向的poniter为nil。 ","date":"2020-12-20","objectID":"https://asong2020.github.io/%E7%90%86%E8%A7%A3interface/:5:2","tags":["interface"],"title":"源码剖析Go语言的interface","uri":"https://asong2020.github.io/%E7%90%86%E8%A7%A3interface/"},{"categories":["Go源码"],"content":"问题三 这段代码的运行结果是什么？ type Animal interface { Walk() } type Dog struct{} func (d *Dog) Walk() { fmt.Println(\"walk\") } func NewAnimal() Animal { var d *Dog return d } func main() { if NewAnimal() == nil { fmt.Println(\"this is empty interface\") } else { fmt.Println(\"this is non-empty interface\") } } 答案：this is non-empty interface. 解析：这里的interface是非空接口iface，他的结构如下： type iface struct { // 16 字节 tab *itab data unsafe.Pointer } d是一个指向nil的空指针，但是最后return d 会触发匿名变量 Animal = p值拷贝动作，所以最后NewAnimal()返回给上层的是一个Animal interface{}类型，也就是一个iface struct{}类型。 p为nil，只是iface中的data 为nil而已。 但是iface struct{}本身并不为nil. ","date":"2020-12-20","objectID":"https://asong2020.github.io/%E7%90%86%E8%A7%A3interface/:5:3","tags":["interface"],"title":"源码剖析Go语言的interface","uri":"https://asong2020.github.io/%E7%90%86%E8%A7%A3interface/"},{"categories":["Go源码"],"content":"总结 interface在我们日常开发中使用还是比较多，所以学好它还是很必要，希望这篇文章能让你对Go语言的接口有一个新的认识，这一篇到这里结束啦，我们下期见～～～。 素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！ 建了一个Golang交流群，欢迎大家的加入，第一时间观看优质文章，不容错过哦（公众号获取） 结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。 我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。 翻译了一份Machinery中文文档，会定期进行维护，有需要的小伙伴们后台回复[machinery]即可获取。 **我是asong，一名普普通通的程序猿，让gi我一起慢慢变强吧。我自己建了一个golang交流群，有需要的小伙伴加我vx,我拉你入群。欢迎各位的关注，我们下期见~~~** 推荐往期文章： machinery-go异步任务队列 Leaf—Segment分布式ID生成系统（Golang实现版本） 十张动图带你搞懂排序算法(附go实现代码) Go语言相关书籍推荐（从入门到放弃） go参数传递类型 手把手教姐姐写消息队列 常见面试题之缓存雪崩、缓存穿透、缓存击穿 详解Context包，看这一篇就够了！！！ go-ElasticSearch入门看这一篇就够了(一) 面试官：go中for-range使用过吗？这几个问题你能解释一下原因吗 学会wire依赖注入、cron定时任务其实就这么简单！ 听说你还不会jwt和swagger-饭我都不吃了带着实践项目我就来了 ","date":"2020-12-20","objectID":"https://asong2020.github.io/%E7%90%86%E8%A7%A3interface/:6:0","tags":["interface"],"title":"源码剖析Go语言的interface","uri":"https://asong2020.github.io/%E7%90%86%E8%A7%A3interface/"},{"categories":["Go应用"],"content":"Leaf-Segment 简介：今天直接开门见山，先来介绍一下我今天所带来的东西。没错，看标题想必大家已经想到了 —— Leaf-segment数据库获取ID方案。这个方案已经喜闻乐见了，美团早就进行了开源，不过他是由java来实现的，所以最近为了学习这一方面知识，我用go自己实现了一下，目前自己验证是没有发现什么bug，等待大家的检验，发现bug可及时反馈（提mr或加我vx都可）。 代码已收录到我的个人仓库——[go-算法系列(go-algorithm)](https://github.com/asong2020/go-algorithm。 欢迎Star，感谢各位～～～。 注：下文leaf-segment数据库方案设计直接参考美团(摘取部分)。详细请参阅：https://tech.meituan.com/2017/04/21/mt-leaf.html ","date":"2020-12-06","objectID":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/:1:0","tags":["ID生成方案"],"title":"Leaf—Segment分布式ID生成系统（Golang实现版本）","uri":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"},{"categories":["Go应用"],"content":"快速使用 ","date":"2020-12-06","objectID":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/:2:0","tags":["ID生成方案"],"title":"Leaf—Segment分布式ID生成系统（Golang实现版本）","uri":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"},{"categories":["Go应用"],"content":"创建数据库 CREATE TABLE `leaf_alloc` ( `id` int(11) NOT NULL AUTO_INCREMENT, `biz_tag` varchar(128) NOT NULL DEFAULT '', `max_id` bigint(20) NOT NULL DEFAULT '1', `step` int(11) NOT NULL, `description` varchar(256) DEFAULT NULL, `update_time` bigint(20) NOT NULL DEFAULT '0', PRIMARY KEY (`id`), UNIQUE KEY (`biz_tag`) ) ENGINE=InnoDB; 也可以直接使用我已经生成好的SQL文件(已在工程项目中)。各个字段的介绍我会在后文代码实现部分进行解析，这里就不一一解析了。 ","date":"2020-12-06","objectID":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/:2:1","tags":["ID生成方案"],"title":"Leaf—Segment分布式ID生成系统（Golang实现版本）","uri":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"},{"categories":["Go应用"],"content":"获取并运行项目 // 1 新建文件目录 $ mdkir asong.cloud $ cd asong.cloud // 2 获取项目 $ git clone git@github.com:asong2020/go-algorithm.git // 3 进入项目目录 $ cd go-go-algorithm/leaf // 4 运行 $ go run main.go //运行 ","date":"2020-12-06","objectID":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/:2:2","tags":["ID生成方案"],"title":"Leaf—Segment分布式ID生成系统（Golang实现版本）","uri":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"},{"categories":["Go应用"],"content":"测试 创建业务号段 URI: POST http://localhost:8080/api/leaf Param(json): { \"biz_tag\": \"test_create_one\", \"max_id\": 1, // 可以不传 默认为1 \"step\": 2000, // 可以不传 默认为200 \"descprition\": \"test api one\" } 示例： curl --location --request POST 'http://localhost:8080/api/leaf' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"biz_tag\": \"test_create_one\", \"descprition\": \"test api one\" }' 初始化DB中的号段到内存中 URI: PUT http://localhost:8080/api/leaf/init/cache Param(json): { \"biz_tag\": \"test_create\" } 示例 curl --location --request PUT 'http://localhost:8080/api/leaf/init/cache' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"biz_tag\": \"test_create\" }' 获取ID URI: GET http://localhost:8080/api/leaf Param: ?biz_tag=test_create 示例 curl --location --request GET 'http://localhost:8080/api/leaf?biz_tag=test_create' 更新step URI: PUT http://localhost:8080/api/leaf/step Param(json): { \"step\": 10000, \"biz_tag\": \"test_create\" } 示例 curl --location --request PUT 'http://localhost:8080/api/leaf/step' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"step\": 10000, \"biz_tag\": \"test_create\" }' ","date":"2020-12-06","objectID":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/:2:3","tags":["ID生成方案"],"title":"Leaf—Segment分布式ID生成系统（Golang实现版本）","uri":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"},{"categories":["Go应用"],"content":"Leaf-Segment方案实现 ","date":"2020-12-06","objectID":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/:3:0","tags":["ID生成方案"],"title":"Leaf—Segment分布式ID生成系统（Golang实现版本）","uri":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"},{"categories":["Go应用"],"content":"背景 在复杂分布式系统中，往往需要对大量的数据和消息进行唯一标识。一个能够生成全局唯一ID的系统是非常必要的。比如某宝，业务分布广泛，这么多业务对数据分库分表后需要有一个唯一ID来标识一条数据或消息，数据库的自增ID显然不能满足需求；所以，我们可以总结一下业务系统对ID号的要求有哪些呢？ 全局唯一性：不能出现重复的ID号，既然是唯一标识，这是最基本的要求。 趋势递增：在MySQL InnoDB引擎中使用的是聚集索引，由于多数RDBMS使用B-tree的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。 单调递增：保证下一个ID一定大于上一个ID，例如事务版本号、IM增量消息、排序等特殊需求。 信息安全：如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要ID无规则、不规则。 上述123对应三类不同的场景，3和4需求还是互斥的，无法使用同一个方案满足。 本文只讲述场景3的方案，即leaf-segment。场景4可以用雪花算法实现，这个我之前实现过了，有兴趣的童鞋可以参考一下。传送门：https://github.com/asong2020/go-algorithm/tree/master/snowFlake ","date":"2020-12-06","objectID":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/:3:1","tags":["ID生成方案"],"title":"Leaf—Segment分布式ID生成系统（Golang实现版本）","uri":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"},{"categories":["Go应用"],"content":"数据库生成 leaf-sement是在使用数据库生成方案上做的改进。这里先抛砖引玉一下，看一下数据库生成方案是怎样实现的。 以MySQL举例，利用给字段设置auto_increment_increment和auto_increment_offset来保证ID自增，每次业务使用下列SQL读写MySQL得到ID号。 begin; REPLACE INTO Tickets64 (stub) VALUES ('a'); SELECT LAST_INSERT_ID(); commit; 这种方案的优缺点如下： 优点： 非常简单，利用现有数据库系统的功能实现，成本小，有DBA专业维护。 ID号单调自增，可以实现一些对ID有特殊要求的业务。 缺点： 强依赖DB，当DB异常时整个系统不可用，属于致命问题。配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致重复发号。 ID发号性能瓶颈限制在单台MySQL的读写性能。 对于MySQL性能问题，可用如下方案解决：在分布式系统中我们可以多部署几台机器，每台机器设置不同的初始值，且步长和机器数相等。比如有两台机器。设置步长step为2，TicketServer1的初始值为1（1，3，5，7，9，11…）、TicketServer2的初始值为2（2，4，6，8，10…）。这是Flickr团队在2010年撰文介绍的一种主键生成策略（Ticket Servers: Distributed Unique Primary Keys on the Cheap ）。如下所示，为了实现上述方案分别设置两台机器对应的参数，TicketServer1从1开始发号，TicketServer2从2开始发号，两台机器每次发号之后都递增2。 TicketServer1: auto-increment-increment = 2 auto-increment-offset = 1 TicketServer2: auto-increment-increment = 2 auto-increment-offset = 2 假设我们要部署N台机器，步长需设置为N，每台的初始值依次为0,1,2…N-1那么整个架构就变成了如下图所示： image 这种架构貌似能够满足性能的需求，但有以下几个缺点： 系统水平扩展比较困难，比如定义好了步长和机器台数之后，如果要添加机器该怎么做？假设现在只有一台机器发号是1,2,3,4,5（步长是1），这个时候需要扩容机器一台。可以这样做：把第二台机器的初始值设置得比第一台超过很多，比如14（假设在扩容时间之内第一台不可能发到14），同时设置步长为2，那么这台机器下发的号码都是14以后的偶数。然后摘掉第一台，把ID值保留为奇数，比如7，然后修改第一台的步长为2。让它符合我们定义的号段标准，对于这个例子来说就是让第一台以后只能产生奇数。扩容方案看起来复杂吗？貌似还好，现在想象一下如果我们线上有100台机器，这个时候要扩容该怎么做？简直是噩梦。所以系统水平扩展方案复杂难以实现。 ID没有了单调递增的特性，只能趋势递增，这个缺点对于一般业务需求不是很重要，可以容忍。 数据库压力还是很大，每次获取ID都得读写一次数据库，只能靠堆机器来提高性能 ","date":"2020-12-06","objectID":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/:3:2","tags":["ID生成方案"],"title":"Leaf—Segment分布式ID生成系统（Golang实现版本）","uri":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"},{"categories":["Go应用"],"content":"Leaf-Segment数据库方案 Leaf-Segment数据库方案是在上面的数据库生成方案上做的改进。 做了如下改变： - 原方案每次获取ID都得读写一次数据库，造成数据库压力大。改为利用proxy server批量获取，每次获取一个segment(step决定大小)号段的值。用完之后再去数据库获取新的号段，可以大大的减轻数据库的压力。 - 各个业务不同的发号需求用biz_tag字段来区分，每个biz-tag的ID获取相互隔离，互不影响。如果以后有性能需求需要对数据库扩容，不需要上述描述的复杂的扩容操作，只需要对biz_tag分库分表就行。 数据库表设计如下： CREATE TABLE `leaf_alloc` ( `id` int(11) NOT NULL AUTO_INCREMENT, `biz_tag` varchar(128) NOT NULL DEFAULT '', `max_id` bigint(20) NOT NULL DEFAULT '1', `step` int(11) NOT NULL, `description` varchar(256) DEFAULT NULL, `update_time` bigint(20) NOT NULL DEFAULT '0', PRIMARY KEY (`id`), UNIQUE KEY (`biz_tag`) ) ENGINE=InnoDB; 这里我依旧使用了一个自增主键，不过没什么用，可以忽略。biz_tag用来区分业务(所以我把它设置成了唯一索引)，max_id表示该biz_tag目前所被分配的ID号段的最大值，step表示每次分配的号段长度。原来获取ID每次都需要写数据库，现在只需要把step设置得足够大，比如1000。那么只有当1000个号被消耗完了之后才会去重新读写一次数据库。读写数据库的频率从1减小到了1/step，大致架构如下图所示： test_tag在第一台Leaf机器上是1~1000的号段，当这个号段用完时，会去加载另一个长度为step=1000的号段，假设另外两台号段都没有更新，这个时候第一台机器新加载的号段就应该是3001~4000。同时数据库对应的biz_tag这条数据的max_id会从3000被更新成4000，更新号段的SQL语句如下： Begin UPDATE table SET max_id=max_id+step WHERE biz_tag=xxx SELECT tag, max_id, step FROM table WHERE biz_tag=xxx Commit 这种模式有以下优缺点： 优点： Leaf服务可以很方便的线性扩展，性能完全能够支撑大多数业务场景。 ID号码是趋势递增的8byte的64位数字，满足上述数据库存储的主键要求。 容灾性高：Leaf服务内部有号段缓存，即使DB宕机，短时间内Leaf仍能正常对外提供服务。 可以自定义max_id的大小，非常方便业务从原有的ID方式上迁移过来。 缺点： ID号码不够随机，能够泄露发号数量的信息，不太安全。 TP999数据波动大，当号段使用完之后还是会hang在更新数据库的I/O上，tg999数据会出现偶尔的尖刺。 DB宕机会造成整个系统不可用。 双buffer优化 对于第二个缺点，Leaf-segment做了一些优化，简单的说就是： Leaf 取号段的时机是在号段消耗完的时候进行的，也就意味着号段临界点的ID下发时间取决于下一次从DB取回号段的时间，并且在这期间进来的请求也会因为DB号段没有取回来，导致线程阻塞。如果请求DB的网络和DB的性能稳定，这种情况对系统的影响是不大的，但是假如取DB的时候网络发生抖动，或者DB发生慢查询就会导致整个系统的响应时间变慢。 为此，我们希望DB取号段的过程能够做到无阻塞，不需要在DB取号段的时候阻塞请求线程，即当号段消费到某个点时就异步的把下一个号段加载到内存中。而不需要等到号段用尽的时候才去更新号段。这样做就可以很大程度上的降低系统的TP999指标。详细实现如下图所示： 采用双buffer的方式，Leaf服务内部有两个号段缓存区segment。当前号段已下发10%时，如果下一个号段未更新，则另启一个更新线程去更新下一个号段。当前号段全部下发完后，如果下个号段准备好了则切换到下个号段为当前segment接着下发，循环往复。 每个biz-tag都有消费速度监控，通常推荐segment长度设置为服务高峰期发号QPS的600倍（10分钟），这样即使DB宕机，Leaf仍能持续发号10-20分钟不受影响。 每次请求来临时都会判断下个号段的状态，从而更新此号段，所以偶尔的网络抖动不会影响下个号段的更新。 ","date":"2020-12-06","objectID":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/:3:3","tags":["ID生成方案"],"title":"Leaf—Segment分布式ID生成系统（Golang实现版本）","uri":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"},{"categories":["Go应用"],"content":"代码实现 终于到本文的重点了，下面就给大家讲解一下我是怎么实现的。 ","date":"2020-12-06","objectID":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/:4:0","tags":["ID生成方案"],"title":"Leaf—Segment分布式ID生成系统（Golang实现版本）","uri":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"},{"categories":["Go应用"],"content":"代码架构 这里先贴一下我的代码架构，具体如下： leaf ├── common -- common包，放的是一些client初始的代码 ├── conf -- conf包，配置文件 ├── config -- config包，读取配置文件代码部分 ├── dao -- dao包，DB操作部分 ├── handler -- hanler包，路由注册即API代码实现部分 ├── images -- 本文的图片文件 ├── model -- model包，db模型或其他模型 ├── service -- service包，逻辑实现部分 ├── wire -- wire包，依赖绑定 ├── leaf_svr.go -- main运行先置条件 └── main.go -- main函数 ","date":"2020-12-06","objectID":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/:4:1","tags":["ID生成方案"],"title":"Leaf—Segment分布式ID生成系统（Golang实现版本）","uri":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"},{"categories":["Go应用"],"content":"实现分析 在我们实现之前，肯定要分析一波，我们要做什么，怎么做？我老大经常跟我说的一句话：“先把需求分析明白了，再动手，返工反而是浪费时间”。 首先我们要把一段号段存从DB中拿到存到内存中，并且可能同时存在很多业务，这里我就想到用map来存，使用biz_tag来作为key，因为它具有唯一性，并且能很快的定位。所以我们可以定义一个这样的结构体作为全局ID分发器： // 全局分配器 // key: biz_tag value: SegmentBuffer type LeafSeq struct { cache sync.Map } 这里考虑到并发操作，所以使用sync.map，因为他是并发安全的。 2. 确定了ID怎么存，接下来我们就要思考，我们存什么样的结构比较合适。这里我决定直接实现\"双buffer优化\"的方案。这里我准备自己定义struct，然后用切片来模拟双buffer。所以可以设计如下结构： // 号段 type LeafSegment struct { Cursor uint64 // 当前发放位置 Max uint64 // 最大值 Min uint64 // 开始值即最小值 InitOk bool // 是否初始化成功 } 字段说明：首先要有一个字段来记录当前数据发放到什么位置了，Cursor就是来做这个的。其次我们还要把范围固定住，也是这个号段的开始和结束，也就是min、max字段的作用。最后我们还要考虑一个问题，既然我们使用的双buffer，也就是说我们并不能确定下一段buffer是否可用，所以加了一个initOK字段来进行表明。 上面也设计好了号段怎么存，接下来我们设计怎么线程安全的把这些id有序的发放出去，所以可以设计如下结构： type LeafAlloc struct { Key string // 也就是`biz_tag`用来区分业务 Step int32 // 记录步长 CurrentPos int32 // 当前使用的 segment buffer光标; 总共两个buffer缓存区，循环使用 Buffer []*LeafSegment // 双buffer 一个作为预缓存作用 UpdateTime time.Time // 记录更新时间 方便长时间不用进行清理，防止占用内存 mutex sync.Mutex // 互斥锁 IsPreload bool // 是否正在预加载 Waiting map[string][]chan byte // 挂起等待 } 字段介绍：key也就是我们的biz_tag，可以用它快速从map中定义数据。Step记录当前号段的步长，因为步长是可以动态改变的，所以这里需要记录一下。currentPos这个完全是记录当前使用buffer，因为是双buffer，所以需要定位。buffer这个不用介绍大家也应该知道，就是缓存池。Update_time这个字段大多人可能想不到为什么会有这个，我们的号段现在都存到内存当中了，那么当我们的业务变多了以后，那么内存就会越占越多，所以我们需要记录他的更新时间，这样我们可以使用一个定时器定期去清除长时间不使用的号段，节省内存。IsPreload这个字段是给预加载使用，当前缓冲区的号段使用了90%后，我们就会去预加载下一段缓存池，为了防止多次重复加载，所以使用该字段做标识。waiting这里我使用的是map+chan的结合，这里的作用就是当我们当前缓存池的号段消耗的比较快或者预加载失败了，就会导致现在没有缓存池可用，所以我们可以去等待一会，因为现在有可能正在做预加载，这样可以保持系统的高可用，如果超时仍未等到预加载成功则返回失败，下一次调用即可。 基本思想就是这样啦，下面我们就分块看一下代码。 ","date":"2020-12-06","objectID":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/:4:2","tags":["ID生成方案"],"title":"Leaf—Segment分布式ID生成系统（Golang实现版本）","uri":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"},{"categories":["Go应用"],"content":"先从DB层走起 我这个人写代码，爱从DB层开始，也就是把我需要的CRUD操作都提前写好并测试，这里就不贴每段代码的实现了，要不代码量有点大，并且也没有必要，直接介绍一下有哪些方法就可以了。 func (l *LeafDB) Create(ctx context.Context, leaf *model.Leaf) error {} func (l *LeafDB) Get(ctx context.Context, bizTag string, tx *sql.Tx) (*model.Leaf, error) {} func (l *LeafDB) UpdateMaxID(ctx context.Context, bizTag string, tx *sql.Tx) error {} func (l *LeafDB) UpdateMaxIdByCustomStep(ctx context.Context, step int32, bizTag string, tx *sql.Tx) error {} func (l *LeafDB) GetAll(ctx context.Context) ([]*model.Leaf, error) {} func (l *LeafDB) UpdateStep(ctx context.Context, step int32, bizTag string) error { 创建leaf方法。 获取某个业务的号段 号段用完时是需要更新DB到下一个号段 根据自定义step更新DB到下一个号段 获取DB中所有的业务号段 更新DB中step ","date":"2020-12-06","objectID":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/:4:3","tags":["ID生成方案"],"title":"Leaf—Segment分布式ID生成系统（Golang实现版本）","uri":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"},{"categories":["Go应用"],"content":"实现获取新号段部分的代码 先贴出我的代码： func (l *LeafDao) NextSegment(ctx context.Context, bizTag string) (*model.Leaf, error) { // 开启事务 tx, err := l.sql.Begin() defer func() { if err != nil { l.rollback(tx) } }() if err = l.checkError(err); err != nil { return nil, err } err = l.db.UpdateMaxID(ctx, bizTag, tx) if err = l.checkError(err); err != nil { return nil, err } leaf, err := l.db.Get(ctx, bizTag, tx) if err = l.checkError(err); err != nil { return nil, err } // 提交事务 err = tx.Commit() if err = l.checkError(err); err != nil { return nil, err } return leaf, nil } func (l *LeafDao) checkError(err error) error { if err == nil { return nil } if message, ok := err.(*mysql.MySQLError); ok { fmt.Printf(\"it's sql error; str:%v\", message.Message) } return errors.New(\"db error\") } func (l *LeafDao) rollback(tx *sql.Tx) { err := tx.Rollback() if err != sql.ErrTxDone \u0026\u0026 err != nil { fmt.Println(\"rollback error\") } } 实现其实很简单，也就是先更新一下数据库中的号段，然后再取出来就可以了，这里为了保证数据的一致性和防止多次更新DB导致号段丢失，所以使用了事务，没有什么特别的点，看一下代码就能懂了。 ","date":"2020-12-06","objectID":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/:4:4","tags":["ID生成方案"],"title":"Leaf—Segment分布式ID生成系统（Golang实现版本）","uri":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"},{"categories":["Go应用"],"content":"初始化及获取ID 这里我把DB中的号段初始化到内存这一步和获取ID合到一起来说吧，因为在获取ID时会有兜底策略进行初始化。先看初始化部分代码： // 第一次使用要初始化也就是把DB中的数据存到内存中,非必须操作，直接使用的话有兜底策略 func (l *LeafService) InitCache(ctx context.Context, bizTag string) (*model.LeafAlloc, error) { leaf, err := l.dao.NextSegment(ctx, bizTag) if err != nil { fmt.Printf(\"initCache failed; err:%v\\n\", err) return nil, err } alloc := model.NewLeafAlloc(leaf) alloc.Buffer = append(alloc.Buffer, model.NewLeafSegment(leaf)) _ = l.leafSeq.Add(alloc) return alloc, nil } 这里步骤主要分两步： 从DB中获取当前业务的号段 保存到内存中，也就是存到map 之后是我们来看一下我们是如何获取id的，这里步骤比较多了，也是最核心的地方了。 先看主流程： func (l *LeafService) GetID(ctx context.Context, bizTag string) (uint64, error) { // 先去内存中看一下是否已经初始了，未初始化则开启兜底策略初始化一下。 l.mutex.Lock() var err error seqs := l.leafSeq.Get(bizTag) if seqs == nil { // 不存在初始化一下 seqs, err = l.InitCache(ctx, bizTag) if err != nil { return 0, err } } l.mutex.Unlock() var id uint64 id, err = l.NextID(seqs) if err != nil { return 0, err } l.leafSeq.Update(bizTag, seqs) return id, nil } 主要分为三步： 先去内存中查看该业务是否已经初始化了，未初始化则开启兜底策略进行初始化。 获取id 更新内存中的数据。 这里最终要的就是第二步，获取id，这里我先把代码贴出来，然后细细讲解一下： func (l *LeafService) NextID(current *model.LeafAlloc) (uint64, error) { current.Lock() defer current.Unlock() var id uint64 currentBuffer := current.Buffer[current.CurrentPos] // 判断当前buffer是否是可用的 if current.HasSeq() { id = atomic.AddUint64(\u0026current.Buffer[current.CurrentPos].Cursor, 1) current.UpdateTime = time.Now() } // 当前号段已下发10%时，如果下一个号段未更新加载，则另启一个更新线程去更新下一个号段 if currentBuffer.Max-id \u003c uint64(0.9*float32(current.Step)) \u0026\u0026 len(current.Buffer) \u003c= 1 \u0026\u0026 !current.IsPreload { current.IsPreload = true cancel, _ := context.WithTimeout(context.Background(), 3*time.Second) go l.PreloadBuffer(cancel, current.Key, current) } // 第一个buffer的segment使用完成 切换到下一个buffer 并移除现在的buffer if id == currentBuffer.Max { // 判断第二个buffer是否准备好了(因为上面开启协程去更新下一个号段会出现失败)，准备好了切换 currentPos 永远是0 不管怎么切换 if len(current.Buffer) \u003e 1 \u0026\u0026 current.Buffer[current.CurrentPos+1].InitOk { current.Buffer = append(current.Buffer[:0], current.Buffer[1:]...) } // 如果没准备好，直接返回就好了，因为现在已经分配id了, 后面会进行补偿 } // 有id直接返回就可以了 if current.HasID(id) { return id, nil } // 当前buffer已经没有id可用了，此时补偿线程一定正在运行，我们等待一会 waitChan := make(chan byte, 1) current.Waiting[current.Key] = append(current.Waiting[current.Key], waitChan) // 释放锁 等待让其他客户端进行走前面的步骤 current.Unlock() timer := time.NewTimer(500 * time.Millisecond) // 等待500ms最多 select { case \u003c-waitChan: case \u003c-timer.C: } current.Lock() // 第二个缓冲区仍未初始化好 if len(current.Buffer) \u003c= 1 { return 0, errors.New(\"get id failed\") } // 切换buffer current.Buffer = append(current.Buffer[:0], current.Buffer[1:]...) if current.HasSeq() { id = atomic.AddUint64(\u0026current.Buffer[current.CurrentPos].Cursor, 1) current.UpdateTime = time.Now() } return id, nil } 这里我觉得用文字描述不清楚，所以我画了个图，不知道你们能不能看懂，可以对照着代码来看，这样是最清晰的，有问题欢迎留言讨论： 预加载的流程也被我画上去了，预加载的步骤主要有三个： 获取某业务下一个阶段的号段 存储到缓存buffer中，留着备用. 唤醒当前正在挂起等待的客户端 代码实现如下： func (l *LeafService) PreloadBuffer(ctx context.Context, bizTag string, current *model.LeafAlloc) error { for i := 0; i \u003c MAXRETRY; i++ { leaf, err := l.dao.NextSegment(ctx, bizTag) if err != nil { fmt.Printf(\"preloadBuffer failed; bizTag:%s;err:%v\", bizTag, err) continue } segment := model.NewLeafSegment(leaf) current.Buffer = append(current.Buffer, segment) // 追加 l.leafSeq.Update(bizTag, current) current.Wakeup() break } current.IsPreload = false return nil } func (l *LeafAlloc) Wakeup() { l.mutex.Lock() defer l.mutex.Unlock() for _, waitChan := range l.Waiting[l.Key] { close(waitChan) } l.Waiting[l.Key] = l.Waiting[l.Key][:0] } ","date":"2020-12-06","objectID":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/:4:5","tags":["ID生成方案"],"title":"Leaf—Segment分布式ID生成系统（Golang实现版本）","uri":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"},{"categories":["Go应用"],"content":"缓存清理 到这里，所有核心代码都已经实现了，还差最后一步，就是清缓存，就像上面说到的，超长时间不用的号段我们就要清除它，不能让他堆积造成内存浪费。这里我实现的是清理超过15min未使用的号段。实现也很简单，就是使用timer做一个定时器，每隔15min就去遍历存储号段的`map，把超过15min未更新的号段清除掉（虽然会造成号段浪费，但也要这要做）。 // 清理超过15min没用过的内存 func (l *LeafSeq) clear() { for { now := time.Now() // 15分钟后 mm, _ := time.ParseDuration(\"15m\") next := now.Add(mm) next = time.Date(next.Year(), next.Month(), next.Day(), next.Hour(), next.Minute(), 0, 0, next.Location()) t := time.NewTimer(next.Sub(now)) \u003c-t.C fmt.Println(\"start clear goroutine\") l.cache.Range(func(key, value interface{}) bool { alloc := value.(*LeafAlloc) if next.Sub(alloc.UpdateTime) \u003e ExpiredTime { fmt.Printf(\"clear biz_tag: %s cache\", key) l.cache.Delete(key) } return true }) } } ","date":"2020-12-06","objectID":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/:4:6","tags":["ID生成方案"],"title":"Leaf—Segment分布式ID生成系统（Golang实现版本）","uri":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"},{"categories":["Go应用"],"content":"总结 好啦，到这里就是接近尾声了，上面就是我实现的整个过程，目前自己测试没有什么问题，后期还会在缝缝补补，大家也可以帮我找找问题，欢迎提出你们宝贵的建议～～～。 代码已收录到我的个人仓库——[go-算法系列(go-algorithm)](https://github.com/asong2020/go-algorithm。 欢迎Star，感谢各位～～～。 好啦，这一篇文章到这就结束了，我们下期见～～。希望对你们有用，又不对的地方欢迎指出，可添加我的golang交流群，我们一起学习交流。 结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。 我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。 翻译了一份Machinery中文文档，会定期进行维护，有需要的小伙伴们后台回复[machinery]即可获取。 **我是asong，一名普普通通的程序猿，让gi我一起慢慢变强吧。我自己建了一个golang交流群，有需要的小伙伴加我vx,我拉你入群。欢迎各位的关注，我们下期见~~~** 推荐往期文章： machinery-go异步任务队列 十张动图带你搞懂排序算法(附go实现代码) Go语言相关书籍推荐（从入门到放弃） go参数传递类型 手把手教姐姐写消息队列 常见面试题之缓存雪崩、缓存穿透、缓存击穿 详解Context包，看这一篇就够了！！！ go-ElasticSearch入门看这一篇就够了(一) 面试官：go中for-range使用过吗？这几个问题你能解释一下原因吗 学会wire依赖注入、cron定时任务其实就这么简单！ 听说你还不会jwt和swagger-饭我都不吃了带着实践项目我就来了 掌握这些Go语言特性，你的水平将提高N个档次(二) ","date":"2020-12-06","objectID":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/:5:0","tags":["ID生成方案"],"title":"Leaf—Segment分布式ID生成系统（Golang实现版本）","uri":"https://asong2020.github.io/leaf-segmentgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"},{"categories":["架构设计杂谈"],"content":"前言 哈喽，everybody，我是asong。今天asong教你们一个mysql优化设计状态标识。学会了他，我们的DB结构看起来更清晰，也避免了DB结构过大的问题，具体怎么设计，下面你就看我怎么操作就好了～～～ ","date":"2020-11-15","objectID":"https://asong2020.github.io/mysql%E4%BC%98%E5%8C%96%E8%AE%BE%E8%AE%A1%E7%8A%B6%E6%80%81%E6%A0%87%E8%AF%86flag/:1:0","tags":["mysql"],"title":"(Mysql)对数据库设计时设计标识字段引发的一些思考","uri":"https://asong2020.github.io/mysql%E4%BC%98%E5%8C%96%E8%AE%BE%E8%AE%A1%E7%8A%B6%E6%80%81%E6%A0%87%E8%AF%86flag/"},{"categories":["架构设计杂谈"],"content":"背景 我们在很多应用场景中，通常是需要给数据加上一些标识，已表明这条数据的某个特性。比如标识用户的支付渠道，标识商家的结算方式、商品的类型等等。对于这样的具有有限固定的几个值的标识，我们通过枚举的方式来标识就可以了，但是对于一些同时具有多个属性且变化比较大的就显然不合适了，举个很简单的例子，我们在某宝上想买一个平板，这个平板的商品类型可标识为电子商品、二手商品、、手机、数码等等，对于这种场景，一个商品对应多种类型，不确定性很大，这种就不是简单的通过几个值标识就能解决的了。本文就是针对这个问题，给出了自己的一些思考。 ","date":"2020-11-15","objectID":"https://asong2020.github.io/mysql%E4%BC%98%E5%8C%96%E8%AE%BE%E8%AE%A1%E7%8A%B6%E6%80%81%E6%A0%87%E8%AF%86flag/:2:0","tags":["mysql"],"title":"(Mysql)对数据库设计时设计标识字段引发的一些思考","uri":"https://asong2020.github.io/mysql%E4%BC%98%E5%8C%96%E8%AE%BE%E8%AE%A1%E7%8A%B6%E6%80%81%E6%A0%87%E8%AF%86flag/"},{"categories":["架构设计杂谈"],"content":"问题与分析 我们就拿最近刚过去的双11举个例子，在双11要开始之前，某宝就会通过各种优惠的方式发放优惠卷、积分抵扣等等福利，这样我们在双11清空购物车时享受这些优惠。这种场景其实对我们程序员来说并不是简单的实现优惠减免这么简单，这种场景更多是标识优惠以计算用户实际所需支付金额，以及为后续业绩统计、制定促销计划、提高用户活跃度等提供数据依据。下面我们根据例子进行分析： 假设当前某宝平台可以使用的优惠方式如下： 序号 优惠内容 使用条件 是否长期有效 备注 1 账户余额 直接抵扣现金 是 用户充值获得(平台奖励吸引的充值，如：充100送10元) 2 平台积分 100积分抵扣1元 是 通过参与平台活动、购物行为积累获取 3 满减卷5元 满100减5元 否 平台活动促销发放 4 免邮费 订单总金额符合条件即可 是 平台单笔订单总金额满199元免邮费 当用户进行下单时，只要满足各优惠的使用条件时，就可以使用各种优惠。这时我们思考一个问题，数据库是怎么存储这些优惠的呢？ 根据上面的举例，用户下单时可以同时使用上面4种优惠抵扣方式，也就说用户可能出现的组合有2^4 - 1=15种，如果我们的表结构设计成单独用一个普通标识字段来标识存储，实现起来是比较简单，但是其需要标识的组合种类实在有点多，不太利于编码与后续扩展，想一想，优惠政策会随着平台发展不断推出的，如果新加了一种优惠类型，其需要添加多少种组合标识啊，且呈指数式爆长，这种方式显然不太合理。那么有没有什么解决方案呢？ 方案一： 采用另外引入一张关联表的方式，专门用一张关联表来存储订单使用的优惠组合信息，每使用一种优惠就添加一条关联记录，相比单独使用普通字段标识，这在一定程度上减少了设置标识的繁琐性，增加了灵活性（每多使用一种优惠就添加一条关联记录），但是，同时也带来了另一些问题，其中主要问题是：新增一张关联表后，数据维护起来麻烦。在互联网场景下，数据量通常是非常大的，像订单数据一般都需要进行数据库sharding，以应对数据量暴涨后数据库的读写性能瓶颈，增加系统的水平扩展能力。因此，另外增加一张数据量是订单数据本身数据量几倍的关联表也显然不太合适。 方案二： 这就是本文的重点了，也就是我们使用“特殊标识位”的方式来实现，具体思路如下： 我们不再直接使用十进制数字来标识存储优惠信息，而是存储一个二进制数转化后的十进制数，这些1、2、3之类的优惠数字表示占二进制数的第几位（从右至左数）； 具体数据的存储、读取判断通过一个通用方法进行转换。 现在我们假设使用int32数据类型进行存储，共32位，除去符号位，可用于标识的位数有31位，即最多可以标识31种优惠情况。 优惠项 占第几位 二进制数 十进制数 账户余额 1 0000 0001 1 平台积分 2 0000 0010 2 满减卷5元 3 0000 0100 4 免邮费 4 0000 1000 8 说明：若用户使用了账户余额,则使用二进制数 00000001 标识，若使用了平台积分，则使用二进制数 00000010 标识，存储到DB时，转换成对应十进制数分别对应1、2；若同时使用了账户余额、平台积分，则使用二进制数 00000011 标识，最终存储到DB的对应十进制数是3。其它优惠项，所占的二进制位依次类推。 ","date":"2020-11-15","objectID":"https://asong2020.github.io/mysql%E4%BC%98%E5%8C%96%E8%AE%BE%E8%AE%A1%E7%8A%B6%E6%80%81%E6%A0%87%E8%AF%86flag/:3:0","tags":["mysql"],"title":"(Mysql)对数据库设计时设计标识字段引发的一些思考","uri":"https://asong2020.github.io/mysql%E4%BC%98%E5%8C%96%E8%AE%BE%E8%AE%A1%E7%8A%B6%E6%80%81%E6%A0%87%E8%AF%86flag/"},{"categories":["架构设计杂谈"],"content":"代码样例 先看代码 package main import ( \"fmt\" ) // golang没有enum 使用const代替 const ( TYPE_BALANCE = 1 // type = 1 TYPE_INTEGRAL = 2 // type = 2 TYPE_COUPON = 3 // type = 3 TYPE_FREEPOSTAGE = 4 // type = 4 ) // 是否使用有优惠卷 func IsUseDiscount(discountType , value uint32) bool { return (value \u0026 (1\u003c\u003c (discountType-1))) \u003e 0 } // 设置使用 func SetDiscountValue(discountType ,value uint32) uint32{ return value | (1 \u003c\u003c (discountType-1)) } func main() { // 测试1 不设置优惠类型 var flag1 uint32 = 0 fmt.Println(IsUseDiscount(TYPE_BALANCE,flag1)) fmt.Println(IsUseDiscount(TYPE_INTEGRAL,flag1)) fmt.Println(IsUseDiscount(TYPE_COUPON,flag1)) fmt.Println(IsUseDiscount(TYPE_FREEPOSTAGE,flag1)) // 测试2 只设置一个优惠类型 var flag2 uint32 = 0 flag2 = SetDiscountValue(TYPE_BALANCE,flag2) fmt.Println(IsUseDiscount(TYPE_BALANCE,flag2)) fmt.Println(IsUseDiscount(TYPE_INTEGRAL,flag2)) fmt.Println(IsUseDiscount(TYPE_COUPON,flag2)) fmt.Println(IsUseDiscount(TYPE_FREEPOSTAGE,flag2)) // 测试3 设置两个优惠类型 var flag3 uint32 = 0 flag3 = SetDiscountValue(TYPE_BALANCE,flag3) flag3 = SetDiscountValue(TYPE_INTEGRAL,flag3) fmt.Println(IsUseDiscount(TYPE_BALANCE,flag3)) fmt.Println(IsUseDiscount(TYPE_INTEGRAL,flag3)) fmt.Println(IsUseDiscount(TYPE_COUPON,flag3)) fmt.Println(IsUseDiscount(TYPE_FREEPOSTAGE,flag3)) // 测试4 设置三个优惠类型 var flag4 uint32 = 0 flag4 = SetDiscountValue(TYPE_BALANCE,flag4) flag4 = SetDiscountValue(TYPE_INTEGRAL,flag4) flag4 = SetDiscountValue(TYPE_COUPON,flag4) fmt.Println(IsUseDiscount(TYPE_BALANCE,flag4)) fmt.Println(IsUseDiscount(TYPE_INTEGRAL,flag4)) fmt.Println(IsUseDiscount(TYPE_COUPON,flag4)) fmt.Println(IsUseDiscount(TYPE_FREEPOSTAGE,flag4)) // 测试5 设置四个优惠类型 var flag5 uint32 = 0 flag5 = SetDiscountValue(TYPE_BALANCE,flag5) flag5 = SetDiscountValue(TYPE_INTEGRAL,flag5) flag5 = SetDiscountValue(TYPE_COUPON,flag5) flag5 = SetDiscountValue(TYPE_FREEPOSTAGE,flag5) fmt.Println(IsUseDiscount(TYPE_BALANCE,flag5)) fmt.Println(IsUseDiscount(TYPE_INTEGRAL,flag5)) fmt.Println(IsUseDiscount(TYPE_COUPON,flag5)) fmt.Println(IsUseDiscount(TYPE_FREEPOSTAGE,flag5)) } 运行结果： false false false false true false false false true true false false true true true false true true true true 因为go没有枚举，所以我们使用const声明常量的方式来实现，定义四个常量，代表四种优惠种类，这个并不是最最终存储到DB的值，而是表示占二进制数的第几位（从右至左数，从1开始）；当需要存储优惠种类到DB中，或者从DB中查询对应的优惠种类时，通过SetDiscountValue和IsUseDiscount这两个方法对值进行设置（项目中可以封装一个文件中作为工具类）。 SetDiscountValue方法的实现：通过位运算来实现，(1 \u003c\u003c (discountType-1))通过位移的方法来找到其在二进制中的位置，然后通过与value位或的方法设定所占二进制位数，最终返回设置占位后的十进制数。 IsUseDiscount方法的实现：(1\u003c\u003c (discountType-1))通过位移的方法来找到其在二进制中的位置，然后通过与value位与的方法来判断优惠项应占位是否有占位，返回判断结果。 上面就是一个使用特殊标识位的一个简单代码样例，这个程序还可以进行扩展与完善，等待你们的开发呦～～～。 ","date":"2020-11-15","objectID":"https://asong2020.github.io/mysql%E4%BC%98%E5%8C%96%E8%AE%BE%E8%AE%A1%E7%8A%B6%E6%80%81%E6%A0%87%E8%AF%86flag/:4:0","tags":["mysql"],"title":"(Mysql)对数据库设计时设计标识字段引发的一些思考","uri":"https://asong2020.github.io/mysql%E4%BC%98%E5%8C%96%E8%AE%BE%E8%AE%A1%E7%8A%B6%E6%80%81%E6%A0%87%E8%AF%86flag/"},{"categories":["架构设计杂谈"],"content":"总结 在这里简单总结一下使用特殊标识位的优缺点： 优点 方便扩展，易于维护；当业务场景迅速扩展时，这种方式可以方便的标识新增的业务场景，数据也易于维护。要知道，在互联网场景下，业务的变化是非常快的，新加字段并不是那么方便。 方便标识存储，一个字段就可以标识多种业务场景。 缺点 数据的存储、查询需要转换，不够直观；相对普通的标识方式，没接触过的人需要一点时间理解这种使用特殊标识位的方式。 DB数据查询时，稍显繁琐。 你们学废了嘛？反正我学废了，哈哈哈哈哈～～～～～。 好啦，这一篇文章到这就结束了，我们下期见～～。希望对你们有用，又不对的地方欢迎指出，可添加我的golang交流群，我们一起学习交流。 结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。 我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。 翻译了一份Machinery中文文档，会定期进行维护，有需要的小伙伴们后台回复[machinery]即可获取。 **我是asong，一名普普通通的程序猿，让gi我一起慢慢变强吧。我自己建了一个golang交流群，有需要的小伙伴加我vx,我拉你入群。欢迎各位的关注，我们下期见~~~** 推荐往期文章： machinery-go异步任务队列 go参数传递类型 手把手教姐姐写消息队列 常见面试题之缓存雪崩、缓存穿透、缓存击穿 详解Context包，看这一篇就够了！！！ go-ElasticSearch入门看这一篇就够了(一) 面试官：go中for-range使用过吗？这几个问题你能解释一下原因吗 ","date":"2020-11-15","objectID":"https://asong2020.github.io/mysql%E4%BC%98%E5%8C%96%E8%AE%BE%E8%AE%A1%E7%8A%B6%E6%80%81%E6%A0%87%E8%AF%86flag/:5:0","tags":["mysql"],"title":"(Mysql)对数据库设计时设计标识字段引发的一些思考","uri":"https://asong2020.github.io/mysql%E4%BC%98%E5%8C%96%E8%AE%BE%E8%AE%A1%E7%8A%B6%E6%80%81%E6%A0%87%E8%AF%86flag/"},{"categories":["Go面试"],"content":"前言 哈喽，大家好，我是asong。今天女朋友问我，小松子，你知道Go语言参数传递是传值还是传引用吗？哎呀哈，我竟然被瞧不起了，我立马一顿操作，给他讲的明明白白的，小丫头片子，还是太嫩，大家且听我细细道来～～～。​ ","date":"2020-11-08","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/:1:0","tags":["参数传递"],"title":"你知道Go语言参数传递是传值还是传引用吗？","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"},{"categories":["Go面试"],"content":"实参与形参数 我们使用go定义方法时是可以定义参数的。比如如下方法： func printNumber(args ...int) 这里的args就是参数。参数在程序语言中分为形式参数和实际参数。 形式参数：是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数。 实际参数：在调用有参函数时，主调函数和被调函数之间有数据传递关系。在主调函数中调用一个函数时，函数名后面括号中的参数称为“实际参数”。 举例如下： func main() { var args int64= 1 printNumber(args) // args就是实际参数 } func printNumber(args ...int64) { //这里定义的args就是形式参数 for _,arg := range args{ fmt.Println(arg) } } ","date":"2020-11-08","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/:2:0","tags":["参数传递"],"title":"你知道Go语言参数传递是传值还是传引用吗？","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"},{"categories":["Go面试"],"content":"什么是值传递 值传递，我们分析其字面意思：传递的就是值。传值的意思是：函数传递的总是原来这个东西的一个副本，一副拷贝。比如我们传递一个int类型的参数，传递的其实是这个参数的一个副本；传递一个指针类型的参数，其实传递的是这个该指针的一份拷贝，而不是这个指针指向的值。我们画个图来解释一下： ","date":"2020-11-08","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/:3:0","tags":["参数传递"],"title":"你知道Go语言参数传递是传值还是传引用吗？","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"},{"categories":["Go面试"],"content":"什么是引用传递 学习过其他语言的同学，对这个引用传递应该很熟悉，比如C++使用者，在C++中，函数参数的传递方式有引用传递。所谓引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。 ","date":"2020-11-08","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/:4:0","tags":["参数传递"],"title":"你知道Go语言参数传递是传值还是传引用吗？","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"},{"categories":["Go面试"],"content":"golang是值传递 我们先写一个简单的例子验证一下： func main() { var args int64= 1 modifiedNumber(args) // args就是实际参数 fmt.Printf(\"实际参数的地址 %p\\n\", \u0026args) fmt.Printf(\"改动后的值是 %d\\n\",args) } func modifiedNumber(args int64) { //这里定义的args就是形式参数 fmt.Printf(\"形参地址 %p \\n\",\u0026args) args = 10 } 运行结果： 形参地址 0xc0000b4010 实际参数的地址 0xc0000b4008 改动后的值是 1 这里正好验证了go是值传递，但是还不能完全确定go就只有值传递，我们在写一个例子验证一下： func main() { var args int64= 1 addr := \u0026args fmt.Printf(\"原始指针的内存地址是 %p\\n\", addr) fmt.Printf(\"指针变量addr存放的地址 %p\\n\", \u0026addr) modifiedNumber(addr) // args就是实际参数 fmt.Printf(\"改动后的值是 %d\\n\",args) } func modifiedNumber(addr *int64) { //这里定义的args就是形式参数 fmt.Printf(\"形参地址 %p \\n\",\u0026addr) *addr = 10 } 运行结果： 原始指针的内存地址是 0xc0000b4008 指针变量addr存放的地址 0xc0000ae018 形参地址 0xc0000ae028 改动后的值是 10 所以通过输出我们可以看到，这是一个指针的拷贝，因为存放这两个指针的内存地址是不同的，虽然指针的值相同，但是是两个不同的指针。 通过上面的图，我们可以更好的理解。我们声明了一个变量args，其值为1，并且他的内存存放地址是0xc0000b4008，通过这个地址，我们就可以找到变量args，这个地址也就是变量args的指针addr。指针addr也是一个指针类型的变量，它也需要内存存放它，它的内存地址是多少呢？是0xc0000ae018。 在我们传递指针变量addr给modifiedNumber函数的时候，是该指针变量的拷贝,所以新拷贝的指针变量addr，它的内存地址已经变了，是新的0xc0000ae028。所以，不管是0xc0000ae018还是0xc0000ae028，我们都可以称之为指针的指针，他们指向同一个指针0xc0000b4008，这个0xc0000b4008又指向变量args,这也就是为什么我们可以修改变量args的值。 通过上面的分析，我们就可以确定go就是值传递，因为我们在modifieNumber方法中打印出来的内存地址发生了改变，所以不是引用传递，实锤了奥兄弟们，证据确凿～～～。等等，好像好落下了点什么，说好的go中只有值传递呢，为什么chan、map、slice类型传递却可以改变其中的值呢？白着急，我们依次来验证一下。 ","date":"2020-11-08","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/:5:0","tags":["参数传递"],"title":"你知道Go语言参数传递是传值还是传引用吗？","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"},{"categories":["Go面试"],"content":"slice也是值传递吗？ 先看一段代码： func main() { var args = []int64{1,2,3} fmt.Printf(\"切片args的地址： %p\\n\",args) modifiedNumber(args) fmt.Println(args) } func modifiedNumber(args []int64) { fmt.Printf(\"形参切片的地址 %p \\n\",args) args[0] = 10 } 运行结果： 切片args的地址： 0xc0000b8000 形参切片的地址 0xc0000b8000 [10 2 3] 哇去，怎么回事，光速打脸呢，这怎么地址都是一样的呢？并且值还被修改了呢？怎么回事，作何解释，你个渣男，欺骗我感情。。。不好意思走错片场了。继续来看这个问题。这里我们没有使用\u0026符号取地址符转换，就把slice地址打印出来了，我们在加上一行代码测试一下： func main() { var args = []int64{1,2,3} fmt.Printf(\"切片args的地址： %p \\n\",args) fmt.Printf(\"切片args第一个元素的地址： %p \\n\",\u0026args[0]) fmt.Printf(\"直接对切片args取地址%v \\n\",\u0026args) modifiedNumber(args) fmt.Println(args) } func modifiedNumber(args []int64) { fmt.Printf(\"形参切片的地址 %p \\n\",args) fmt.Printf(\"形参切片args第一个元素的地址： %p \\n\",\u0026args[0]) fmt.Printf(\"直接对形参切片args取地址%v \\n\",\u0026args) args[0] = 10 } 运行结果： 切片args的地址： 0xc000016140 切片args第一个元素的地址： 0xc000016140 直接对切片args取地址\u0026[1 2 3] 形参切片的地址 0xc000016140 形参切片args第一个元素的地址： 0xc000016140 直接对形参切片args取地址\u0026[1 2 3] [10 2 3] 通过这个例子我们可以看到，使用\u0026操作符表示slice的地址是无效的，而且使用%p输出的内存地址与slice的第一个元素的地址是一样的，那么为什么会出现这样的情况呢？会不会是fmt.Printf函数做了什么特殊处理？我们来看一下其源码： fmt包,print.go中的printValue这个方法,截取重点部分，因为`slice`也是引用类型，所以会进入这个`case`： case reflect.Ptr: // pointer to array or slice or struct? ok at top level // but not embedded (avoid loops) if depth == 0 \u0026\u0026 f.Pointer() != 0 { switch a := f.Elem(); a.Kind() { case reflect.Array, reflect.Slice, reflect.Struct, reflect.Map: p.buf.writeByte('\u0026') p.printValue(a, verb, depth+1) return } } fallthrough case reflect.Chan, reflect.Func, reflect.UnsafePointer: p.fmtPointer(f, verb) p.buf.writeByte('\u0026')这行代码就是为什么我们使用\u0026打印地址输出结果前面带有\u0026的语音。因为我们要打印的是一个slice类型，就会调用p.printValue(a, verb, depth+1)递归获取切片中的内容，为什么打印出来的切片中还会有[]包围呢，我来看一下printValue这个方法的源代码： case reflect.Array, reflect.Slice: //省略部分代码 } else { p.buf.writeByte('[') for i := 0; i \u003c f.Len(); i++ { if i \u003e 0 { p.buf.writeByte(' ') } p.printValue(f.Index(i), verb, depth+1) } p.buf.writeByte(']') } 这就是上面 fmt.Printf(\"直接对切片args取地址%v \\n\",\u0026args)输出直接对切片args取地址\u0026[1 2 3] 的原因。这个问题解决了，我们再来看一看使用%p输出的内存地址与slice的第一个元素的地址是一样的。在上面的源码中，有这样一行代码fallthrough，代表着接下来的fmt.Poniter也会被执行，我看一下其源码： func (p *pp) fmtPointer(value reflect.Value, verb rune) { var u uintptr switch value.Kind() { case reflect.Chan, reflect.Func, reflect.Map, reflect.Ptr, reflect.Slice, reflect.UnsafePointer: u = value.Pointer() default: p.badVerb(verb) return } ...... 省略部分代码 // If v's Kind is Slice, the returned pointer is to the first // element of the slice. If the slice is nil the returned value // is 0. If the slice is empty but non-nil the return value is non-zero. func (v Value) Pointer() uintptr { // TODO: deprecate k := v.kind() switch k { case Chan, Map, Ptr, UnsafePointer: return uintptr(v.pointer()) case Func: if v.flag\u0026flagMethod != 0 { ....... 省略部分代码 这里我们可以看到上面有这样一句注释：If v’s Kind is Slice, the returned pointer is to the first。翻译成中文就是如果是slice类型，返回slice这个结构里的第一个元素的地址。这里正好解释上面为什么fmt.Printf(\"切片args的地址： %p \\n\",args)和fmt.Printf(\"形参切片的地址 %p \\n\",args)打印出来的地址是一样的，因为args是引用类型，所以他们都返回slice这个结构里的第一个元素的地址，为什么这两个slice结构里的第一个元素的地址一样呢，这就要在说一说slice的底层结构了。 我们看一下slice底层结构： //runtime/slice.go type slice struct { array unsafe.Pointer len int cap int } slice是一个结构体，他的第一个元素是一个指针类型，这个指针指向的是底层数组的第一个元素。所以当是slice类型的时候，fmt.Printf返回是slice这个结构体里第一个元素的地址。说到底，又转变成了指针处理，只不过这个指针是slice中第一个元素的内存地址。 说了这么多，最后再做一个总结吧，为什么slice也是值传递。之所以对于引用类型的传递可以修改原内容的数据，这是因为在底层默认使用该引用类型的指针进行传递，但也是使用指针的副本，依旧是值传递。所以slice传递的就是第一个元素的指针的副本，因为fmt.printf缘故造成了打印的地址一样，给人一种混淆的感觉。 ","date":"2020-11-08","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/:5:1","tags":["参数传递"],"title":"你知道Go语言参数传递是传值还是传引用吗？","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"},{"categories":["Go面试"],"content":"map也是值传递吗？ map和slice一样都具有迷惑行为，哼，渣女。map我们可以通过方法修改它的内容，并且它没有明显的指针。比如这个例子： func main() { persons:=make(map[string]int) persons[\"asong\"]=8 addr:=\u0026persons fmt.Printf(\"原始map的内存地址是：%p\\n\",addr) modifiedAge(persons) fmt.Println(\"map值被修改了，新值为:\",persons) } func modifiedAge(person map[string]int) { fmt.Printf(\"函数里接收到map的内存地址是：%p\\n\",\u0026person) person[\"asong\"]=9 } 看一眼运行结果： 原始map的内存地址是：0xc00000e028 函数里接收到map的内存地址是：0xc00000e038 map值被修改了，新值为: map[asong:9] 先喵一眼，哎呀，实参与形参地址不一样，应该是值传递无疑了，等等。。。。map值怎么被修改了？一脸疑惑。。。。。 为了解决我们的疑惑，我们从源码入手，看一看什么原理： //src/runtime/map.go // makemap implements Go map creation for make(map[k]v, hint). // If the compiler has determined that the map or the first bucket // can be created on the stack, h and/or bucket may be non-nil. // If h != nil, the map can be created directly in h. // If h.buckets != nil, bucket pointed to can be used as the first bucket. func makemap(t *maptype, hint int, h *hmap) *hmap { mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size) if overflow || mem \u003e maxAlloc { hint = 0 } // initialize Hmap if h == nil { h = new(hmap) } h.hash0 = fastrand() 从以上源码，我们可以看出，使用make函数返回的是一个hmap类型的指针*hmap。回到上面那个例子，我们的func modifiedAge(person map[string]int)函数，其实就等于func modifiedAge(person *hmap）,实际上在作为传递参数时还是使用了指针的副本进行传递，属于值传递。在这里，Go语言通过make函数，字面量的包装，为我们省去了指针的操作，让我们可以更容易的使用map。这里的map可以理解为引用类型，但是记住引用类型不是传引用。 ","date":"2020-11-08","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/:5:2","tags":["参数传递"],"title":"你知道Go语言参数传递是传值还是传引用吗？","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"},{"categories":["Go面试"],"content":"chan是值传递吗？ 老样子，先看一个例子： func main() { p:=make(chan bool) fmt.Printf(\"原始chan的内存地址是：%p\\n\",\u0026p) go func(p chan bool){ fmt.Printf(\"函数里接收到chan的内存地址是：%p\\n\",\u0026p) //模拟耗时 time.Sleep(2*time.Second) p\u003c-true }(p) select { case l := \u003c- p: fmt.Println(l) } } 再看一看运行结果： 原始chan的内存地址是：0xc00000e028 函数里接收到chan的内存地址是：0xc00000e038 true 这个怎么回事，实参与形参地址不一样，但是这个值是怎么传回来的，说好的值传递呢？白着急，铁子，我们像分析map那样，再来分析一下chan。首先看源码： // src/runtime/chan.go func makechan(t *chantype, size int) *hchan { elem := t.elem // compiler checks this but be safe. if elem.size \u003e= 1\u003c\u003c16 { throw(\"makechan: invalid channel element type\") } if hchanSize%maxAlign != 0 || elem.align \u003e maxAlign { throw(\"makechan: bad alignment\") } mem, overflow := math.MulUintptr(elem.size, uintptr(size)) if overflow || mem \u003e maxAlloc-hchanSize || size \u003c 0 { panic(plainError(\"makechan: size out of range\")) } 从以上源码，我们可以看出，使用make函数返回的是一个hchan类型的指针*hchan。这不是与map一个道理嘛，再次回到上面的例子，实际我们的fun (p chan bool)与fun (p *hchan)是一样的，实际上在作为传递参数时还是使用了指针的副本进行传递，属于值传递。 是不是到这里，基本就可以确定go就是值传递了呢？还剩最后一个没有测试，那就是struct，我们最后来验证一下struct。 ","date":"2020-11-08","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/:5:3","tags":["参数传递"],"title":"你知道Go语言参数传递是传值还是传引用吗？","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"},{"categories":["Go面试"],"content":"struct就是值传递 没错，我先说答案，struct就是值传递，不信你看这个例子： func main() { per := Person{ Name: \"asong\", Age: int64(8), } fmt.Printf(\"原始struct地址是：%p\\n\",\u0026per) modifiedAge(per) fmt.Println(per) } func modifiedAge(per Person) { fmt.Printf(\"函数里接收到struct的内存地址是：%p\\n\",\u0026per) per.Age = 10 } 我们发现，我们自己定义的Person类型，在函数传参的时候也是值传递，但是它的值(Age字段)并没有被修改，我们想改成10，发现最后的结果还是8。 ","date":"2020-11-08","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/:5:4","tags":["参数传递"],"title":"你知道Go语言参数传递是传值还是传引用吗？","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"},{"categories":["Go面试"],"content":"前文总结 兄弟们实锤了奥，go就是值传递，可以确认的是Go语言中所有的传参都是值传递（传值），都是一个副本，一个拷贝。因为拷贝的内容有时候是非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；有的是引用类型（指针、map、slice、chan等这些），这样就可以修改原内容数据。 是否可以修改原内容数据，和传值、传引用没有必然的关系。在C++中，传引用肯定是可以修改原内容数据的，在Go语言里，虽然只有传值，但是我们也可以修改原内容数据，因为参数是引用类型。 有的小伙伴会在这里还是懵逼，因为你把引用类型和传引用当成一个概念了，这是两个概念，切记！！！ ","date":"2020-11-08","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/:6:0","tags":["参数传递"],"title":"你知道Go语言参数传递是传值还是传引用吗？","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"},{"categories":["Go面试"],"content":"出个题考验你们一下 欢迎在评论区留下你的答案～～～ 既然你们都知道了golang只有值传递，那么这段代码来帮我分析一下吧，这里的值能修改成功，为什么使用append不会发生扩容？ func main() { array := []int{7,8,9} fmt.Printf(\"main ap brfore: len: %d cap:%d data:%+v\\n\", len(array), cap(array), array) ap(array) fmt.Printf(\"main ap after: len: %d cap:%d data:%+v\\n\", len(array), cap(array), array) } func ap(array []int) { fmt.Printf(\"ap brfore: len: %d cap:%d data:%+v\\n\", len(array), cap(array), array) array[0] = 1 array = append(array, 10) fmt.Printf(\"ap after: len: %d cap:%d data:%+v\\n\", len(array), cap(array), array) } ","date":"2020-11-08","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/:6:1","tags":["参数传递"],"title":"你知道Go语言参数传递是传值还是传引用吗？","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"},{"categories":["Go面试"],"content":"后记 好啦，这一篇文章到这就结束了，我们下期见～～。希望对你们有用，又不对的地方欢迎指出，可添加我的golang交流群，我们一起学习交流。 结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。 最近被吐槽说我写的代码太丑陋了，所以最近也在看clean code这本书，有需要的小伙伴公众号自取哈。获取方式：关注公众号：[Golang梦工厂]，后台回复：[code]，即可获取 我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。 翻译了一份Machinery中文文档，会定期进行维护，有需要的小伙伴们后台回复[machinery]即可获取。 **我是asong，一名普普通通的程序猿，让gi我一起慢慢变强吧。我自己建了一个golang交流群，有需要的小伙伴加我vx,我拉你入群。欢迎各位的关注，我们下期见~~~** 推荐往期文章： machinery-go异步任务队列 十张动图带你搞懂排序算法(附go实现代码) Go语言相关书籍推荐（从入门到放弃） go参数传递类型 手把手教姐姐写消息队列 常见面试题之缓存雪崩、缓存穿透、缓存击穿 详解Context包，看这一篇就够了！！！ go-ElasticSearch入门看这一篇就够了(一) 面试官：go中for-range使用过吗？这几个问题你能解释一下原因吗 学会wire依赖注入、cron定时任务其实就这么简单！ 听说你还不会jwt和swagger-饭我都不吃了带着实践项目我就来了 掌握这些Go语言特性，你的水平将提高N个档次(二) ","date":"2020-11-08","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/:7:0","tags":["参数传递"],"title":"你知道Go语言参数传递是传值还是传引用吗？","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"},{"categories":["Go面试"],"content":"前言 昨天发了一篇文章是关于machinery的入门教程，有一位读者在留言中问我 这个和kafka有什么区别？一时我也有点懵，这两个的概念很近，到底有什么不同呢？根据我自己的理解，简单分析了一下，有不足之处欢迎指出。 ","date":"2020-11-03","objectID":"https://asong2020.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/:1:0","tags":["队列"],"title":"消息队列和任务队列有什么区别？","uri":"https://asong2020.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"},{"categories":["Go面试"],"content":"消息队列 消息队列这个概念其实在我之前的文章：手把手教姐姐写消息队列，自己动手用go写一个简易版的消息队列，有兴趣的小伙伴们可以看一下这篇文章。回归正题，我们再来介绍一下什么是消息队列。 消息队列，一般我们会简称它为MQ(Message Queue)。他是由两个单词组成，我们应该对队列(Queue)很熟悉吧。队列是一种先进先出的数据结构。再配合上消息，消息队列可以简单理解为：把要传输的数据放在队列中。使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ。这里我们就不具体讲解消息队列实现细节，这不是本文的主题，只知道概念就可以了。了解了什么是消息队列，我们一起来看看他在什么场景使用。 ","date":"2020-11-03","objectID":"https://asong2020.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/:2:0","tags":["队列"],"title":"消息队列和任务队列有什么区别？","uri":"https://asong2020.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"},{"categories":["Go面试"],"content":"场景 消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题。这里举一个消息队列的使用场景：日志处理。 日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题。架构简化如下： 日志采集客户端，负责日志数据采集，定时写入Kfaka队列。 Kfaka消息队列，负责日志数据的接收，存储和转发。 日志处理应用，订阅并消费kafka队列中日志数据。 ","date":"2020-11-03","objectID":"https://asong2020.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/:2:1","tags":["队列"],"title":"消息队列和任务队列有什么区别？","uri":"https://asong2020.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"},{"categories":["Go面试"],"content":"任务队列 既然消息队列称为MQ，那么任务队列我们就可以叫其TQ(Task Message)。任务队列可以简单理解为：把要执行的任务放在队列中。使用较多的任务队列有machiney、Celery、goWorker、YTask。每一个任务队列都有自己的特点，这里就不细讲了。我写了一篇machinery入门教程，并且翻译了一篇machinery中文文档，有需要的公众号自取。具体任务队列的细节就不讲了。这不是本文的主题，下面我们看一看任务队列的使用场景。 ","date":"2020-11-03","objectID":"https://asong2020.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/:3:0","tags":["队列"],"title":"消息队列和任务队列有什么区别？","uri":"https://asong2020.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"},{"categories":["Go面试"],"content":"场景 任务队列是用来执行一个耗时任务。大家可能都使用过马爸爸的花呗，每当我们还款时，就会增加自己的芝麻信用分。这就可以用到任务队列来计算用户的积分和等级了。架构简化如下： 用户还款，当用户还款成功时，发送一个计算用户积分计算的任务到任务队列。 任务队列，可以是mq，也可是redis，用来存储任务。 任务执行者，任务的执行者，监听任务队列，当任务队列中有任务时，便会执行。 ","date":"2020-11-03","objectID":"https://asong2020.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/:3:1","tags":["队列"],"title":"消息队列和任务队列有什么区别？","uri":"https://asong2020.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"},{"categories":["Go面试"],"content":"区别 消息队列和任务队列，我觉得最大的不同就是理念的不同：任务队列传递的是\"任务\"，消息队列传递的是\"消息\"。任务队列可以说是消息队列的二次开发。 通过上面两个场景例子，我们可以总结一下两者区别： 消息队列更侧重于消息的吞吐、处理，具有有处理海量信息的能力。另外利用消息队列的生产者和消费者的概念，也可以实现任务队列的功能，但是还需要进行额外的开发处理。 任务队列则提供了执行任务所需的功能，比如任务的重试，结果的返回，任务状态记录等。虽然也有并发的处理能力，但一般不适用于高吞吐量快速消费的场景。其实任务队列和远程函数调用很像，不过和rpc调用不同，他的调用不是网络请求的方式，而是通过利用消息队列传递任务信息。 综上所述，个人认为任务队列就是消息队列在异步场景下的深度二次开发，根据实际项目开发根据实际场景做相应选择即可。 ","date":"2020-11-03","objectID":"https://asong2020.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/:4:0","tags":["队列"],"title":"消息队列和任务队列有什么区别？","uri":"https://asong2020.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"},{"categories":["Go面试"],"content":"后言 以上全是个人理解，有什么不对的，欢迎指出。 好啦，这一篇文章到这就结束了，我们下期见～～。希望对你们有用。可添加我的golang交流群，我们一起学习交流。 结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。 我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。 自己翻译了一份machinery官方中文文档，会定期维护，有需要的小伙伴后台回复[machinery]即可下载。 **我是asong，一名普普通通的程序猿，让gi我一起慢慢变强吧。我自己建了一个golang交流群，有需要的小伙伴加我vx,我拉你入群。欢迎各位的关注，我们下期见~~~** 推荐往期文章： machinery入门看这一篇（异步任务队列） 这个缓存更新的套路你都知道吗？ 手把手教姐姐写消息队列 常见面试题之缓存雪崩、缓存穿透、缓存击穿 详解Context包，看这一篇就够了！！！ go-ElasticSearch入门看这一篇就够了(一) 面试官：go中for-range使用过吗？这几个问题你能解释一下原因吗 学会wire依赖注入、cron定时任务其实就这么简单！ 听说你还不会jwt和swagger-饭我都不吃了带着实践项目我就来了 ","date":"2020-11-03","objectID":"https://asong2020.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/:5:0","tags":["队列"],"title":"消息队列和任务队列有什么区别？","uri":"https://asong2020.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"},{"categories":["Go应用"],"content":"前言 哈喽，大家好，我是asong，这次给大家介绍一个go的异步任务框架machinery。使用过python的同学们都知道Celery框架，machinery框架就类似于Celery框架。下面我们就来学习一下machinery的基本使用。 自己翻译一个粗略版的machinery中文文档，有需要的伙伴们公众号自取无水印版：后台回复：machinery即可领取。 或者github下载：https://github.com/asong2020/Golang_Dream/tree/master/machinery ","date":"2020-10-31","objectID":"https://asong2020.github.io/machonery-go%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/:1:0","tags":["machinery"],"title":"machinery入门看这一篇（异步任务队列）","uri":"https://asong2020.github.io/machonery-go%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"},{"categories":["Go应用"],"content":"抛砖引玉 我们在使用某些APP时，登陆系统后一般会收到一封邮件或者一个短信提示我们在某个时间某某地点登陆了。而邮件或短信都是在我们已经登陆后才收到，这里就是采用的异步机制。大家有没有想过这里为什么没有使用同步机制实现呢？我们来分析一下。假设我们现在采用同步的方式实现，用户在登录时，首先会去检验一下账号密码是否正确，验证通过后去给用户发送登陆提示信息，假如在这一步出错了，那么就会导致用户登陆失败，这样是大大影响用户的体验感的，一个登陆提示的优先级别并不是很高，所以我们完全可以采用异步的机制实现，即使失败了也不会影响用户的体验。前面说了这么多，那么异步机制该怎么实现呢？对，没错，就是machinery框架，听说你们还不会使用它，今天我就写一个小例子，我们一起来学习一下他吧。 ","date":"2020-10-31","objectID":"https://asong2020.github.io/machonery-go%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/:2:0","tags":["machinery"],"title":"machinery入门看这一篇（异步任务队列）","uri":"https://asong2020.github.io/machonery-go%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"},{"categories":["Go应用"],"content":"特性 上面只是简单举了个例子，任务队列有着广泛的应用场景，比如大批量的计算任务，当有大量数据插入，通过拆分并分批插入任务队列，从而实现串行链式任务处理或者实现分组并行任务处理，提高系统鲁棒性，提高系统并发度；或者对数据进行预处理，定期的从后端存储将数据同步到到缓存系统，从而在查询请求发生时，直接去缓存系统中查询，提高查询请求的响应速度。适用任务队列的场景有很多，这里就不一一列举了。回归本文主题，既然我们要学习machinery，就要先了解一下他都有哪些特性呢？ 任务重试机制 延迟任务支持 任务回调机制 任务结果记录 支持Workflow模式：Chain，Group，Chord 多Brokers支持：Redis, AMQP, AWS SQS 多Backends支持：Redis, Memcache, AMQP, MongoDB ","date":"2020-10-31","objectID":"https://asong2020.github.io/machonery-go%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/:3:0","tags":["machinery"],"title":"machinery入门看这一篇（异步任务队列）","uri":"https://asong2020.github.io/machonery-go%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"},{"categories":["Go应用"],"content":"架构 任务队列，简而言之就是一个放大的生产者消费者模型，用户请求会生成任务，任务生产者不断的向队列中插入任务，同时，队列的处理器程序充当消费者不断的消费任务。基于这种框架设计思想，我们来看下machinery的简单设计结构图例： Sender：业务推送模块，生成具体任务，可根据业务逻辑中，按交互进行拆分； Broker：存储具体序列化后的任务，machinery中目前支持到Redis, AMQP,和SQS； Worker：工作进程，负责消费者功能，处理具体的任务； Backend：后端存储，用于存储任务执行状态的数据； ","date":"2020-10-31","objectID":"https://asong2020.github.io/machonery-go%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/:4:0","tags":["machinery"],"title":"machinery入门看这一篇（异步任务队列）","uri":"https://asong2020.github.io/machonery-go%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"},{"categories":["Go应用"],"content":"e.g 学习一门新东西，我都习惯先写一个demo，先学会了走，再学会跑。所以先来看一个例子，功能很简单，异步计算1到10的和。 先看一下配置文件代码： broker: redis://localhost:6379 default_queue: \"asong\" result_backend: redis://localhost:6379 redis: max_idle: 3 max_active: 3 max_idle_timeout: 240 wait: true read_timeout: 15 write_timeout: 15 connect_timeout: 15 normal_tasks_poll_period: 1000 delayed_tasks_poll_period: 500 delayed_tasks_key: \"asong\" 这里broker与result_backend来实现。 主代码，完整版github获取： func main() { cnf,err := config.NewFromYaml(\"./config.yml\",false) if err != nil{ log.Println(\"config failed\",err) return } server,err := machinery.NewServer(cnf) if err != nil{ log.Println(\"start server failed\",err) return } // 注册任务 err = server.RegisterTask(\"sum\",Sum) if err != nil{ log.Println(\"reg task failed\",err) return } worker := server.NewWorker(\"asong\", 1) go func() { err = worker.Launch() if err != nil { log.Println(\"start worker error\",err) return } }() //task signature signature := \u0026tasks.Signature{ Name: \"sum\", Args: []tasks.Arg{ { Type: \"[]int64\", Value: []int64{1,2,3,4,5,6,7,8,9,10}, }, }, } asyncResult, err := server.SendTask(signature) if err != nil { log.Fatal(err) } res, err := asyncResult.Get(1) if err != nil { log.Fatal(err) } log.Printf(\"get res is %v\\n\", tasks.HumanReadableResults(res)) } 运行结果： INFO: 2020/10/31 11:32:15 file.go:19 Successfully loaded config from file ./config.yml INFO: 2020/10/31 11:32:15 worker.go:58 Launching a worker with the following settings: INFO: 2020/10/31 11:32:15 worker.go:59 - Broker: redis://localhost:6379 INFO: 2020/10/31 11:32:15 worker.go:61 - DefaultQueue: asong INFO: 2020/10/31 11:32:15 worker.go:65 - ResultBackend: redis://localhost:6379 INFO: 2020/10/31 11:32:15 redis.go:100 [*] Waiting for messages. To exit press CTRL+C DEBUG: 2020/10/31 11:32:16 redis.go:342 Received new message: {\"UUID\":\"task_9f01be1f-3237-49f1-8464-eecca2e50597\",\"Name\":\"sum\",\"RoutingKey\":\"asong\",\"ETA\":null,\"GroupUUID\":\"\",\"GroupTaskCount\":0,\"Args\":[{\"Name\":\"\",\"Type\":\"[]int64\",\"Value\":[1,2,3,4,5,6,7,8,9,10]}],\"Headers\":{},\"Priority\":0,\"Immutable\":false,\"RetryCount\":0,\"RetryTimeout\":0,\"OnSuccess\":null,\"OnError\":null,\"ChordCallback\":null,\"BrokerMessageGroupId\":\"\",\"SQSReceiptHandle\":\"\",\"StopTaskDeletionOnError\":false,\"IgnoreWhenTaskNotRegistered\":false} DEBUG: 2020/10/31 11:32:16 worker.go:261 Processed task task_9f01be1f-3237-49f1-8464-eecca2e50597. Results = 55 2020/10/31 11:32:16 get res is 55 好啦，现在我们开始讲一讲上面的代码流程， 读取配置文件，这一步是为了配置broker和result_backend，这里我都选择的是redis，因为电脑正好有这个环境，就直接用了。 Machinery 库必须在使用前实例化。实现方法是创建一个Server实例。Server是Machinery配置和注册任务的基本对象。 在你的workders能消费一个任务前，你需要将它注册到服务器。这是通过给任务分配一个唯一的名称来实现的。 为了消费任务，你需有有一个或多个worker正在运行。运行worker所需要的只是一个具有已注册任务的Server实例。每个worker将只使用已注册的任务。对于队列中的每个任务，Worker.Process()方法将在一个goroutine中运行。可以使用server.NewWorker的第二参数来限制并发运行的worker.Process()调用的数量(每个worker)。 可以通过将Signature实例传递给Server实例来调用任务。 调用HumanReadableResults这个方法可以处理反射值，获取到最终的结果。 ","date":"2020-10-31","objectID":"https://asong2020.github.io/machonery-go%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/:5:0","tags":["machinery"],"title":"machinery入门看这一篇（异步任务队列）","uri":"https://asong2020.github.io/machonery-go%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"},{"categories":["Go应用"],"content":"多功能 ","date":"2020-10-31","objectID":"https://asong2020.github.io/machonery-go%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/:6:0","tags":["machinery"],"title":"machinery入门看这一篇（异步任务队列）","uri":"https://asong2020.github.io/machonery-go%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"},{"categories":["Go应用"],"content":"1. 延时任务 上面的代码只是一个简单machinery使用示例，其实machiney也支持延时任务的，可以通过在任务signature上设置ETA时间戳字段来延迟任务。 eta := time.Now().UTC().Add(time.Second * 20) signature.ETA = \u0026eta ","date":"2020-10-31","objectID":"https://asong2020.github.io/machonery-go%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/:6:1","tags":["machinery"],"title":"machinery入门看这一篇（异步任务队列）","uri":"https://asong2020.github.io/machonery-go%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"},{"categories":["Go应用"],"content":"2. 重试任务 在将任务声明为失败之前，可以设置多次重试尝试。斐波那契序列将用于在一段时间内分隔重试请求。这里可以使用两种方法，第一种直接对 tsak signature中的retryTimeout和RetryCount字段进行设置，就可以，重试时间将按照斐波那契数列进行叠加。 //task signature signature := \u0026tasks.Signature{ Name: \"sum\", Args: []tasks.Arg{ { Type: \"[]int64\", Value: []int64{1,2,3,4,5,6,7,8,9,10}, }, }, RetryTimeout: 100, RetryCount: 3, } 或者，你可以使用return.tasks.ErrRetryTaskLater 返回任务并指定重试的持续时间。 func Sum(args []int64) (int64, error) { sum := int64(0) for _, arg := range args { sum += arg } return sum, tasks.NewErrRetryTaskLater(\"我说他错了\", 4 * time.Second) } ","date":"2020-10-31","objectID":"https://asong2020.github.io/machonery-go%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/:6:2","tags":["machinery"],"title":"machinery入门看这一篇（异步任务队列）","uri":"https://asong2020.github.io/machonery-go%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"},{"categories":["Go应用"],"content":"3. 工作流 上面我们讲的都是运行一个异步任务，但是我们往往做项目时，一个需求是需要多个异步任务以编排好的方式执行的，所以我们就可以使用machinery的工作流来完成。 3.1 Groups Group 是一组任务，它们将相互独立地并行执行。还是画个图吧，这样看起来更明了： 一起来看一个简单的例子： // group group,err :=tasks.NewGroup(signature1,signature2,signature3) if err != nil{ log.Println(\"add group failed\",err) } asyncResults, err :=server.SendGroupWithContext(context.Background(),group,10) if err != nil { log.Println(err) } for _, asyncResult := range asyncResults{ results,err := asyncResult.Get(1) if err != nil{ log.Println(err) continue } log.Printf( \"%v %v %v\\n\", asyncResult.Signature.Args[0].Value, tasks.HumanReadableResults(results), ) } group中的任务是并行执行的。 3.2 chrods 我们在做项目时，往往会有一些回调场景，machiney也为我们考虑到了这一点，Chord允许你定一个回调任务在groups中的所有任务执行结束后被执行。 来看一段代码： callback := \u0026tasks.Signature{ Name: \"call\", } group, err := tasks.NewGroup(signature1, signature2, signature3) if err != nil { log.Printf(\"Error creating group: %s\", err.Error()) return } chord, err := tasks.NewChord(group, callback) if err != nil { log.Printf(\"Error creating chord: %s\", err) return } chordAsyncResult, err := server.SendChordWithContext(context.Background(), chord, 0) if err != nil { log.Printf(\"Could not send chord: %s\", err.Error()) return } results, err := chordAsyncResult.Get(time.Duration(time.Millisecond * 5)) if err != nil { log.Printf(\"Getting chord result failed with error: %s\", err.Error()) return } log.Printf(\"%v\\n\", tasks.HumanReadableResults(results)) 上面的例子并行执行task1、task2、task3，聚合它们的结果并将它们传递给callback任务。 3.3 chains chain就是一个接一个执行的任务集，每个成功的任务都会触发chain中的下一个任务。 看这样一段代码： //chain chain,err := tasks.NewChain(signature1,signature2,signature3,callback) if err != nil { log.Printf(\"Error creating group: %s\", err.Error()) return } chainAsyncResult, err := server.SendChainWithContext(context.Background(), chain) if err != nil { log.Printf(\"Could not send chain: %s\", err.Error()) return } results, err := chainAsyncResult.Get(time.Duration(time.Millisecond * 5)) if err != nil { log.Printf(\"Getting chain result failed with error: %s\", err.Error()) } log.Printf(\" %v\\n\", tasks.HumanReadableResults(results)) 上面的例子执行task1，然后是task2，然后是task3。当一个任务成功完成时，结果被附加到chain中下一个任务的参数列表的末尾，最终执行callback任务。 文中代码地址：https://github.com/asong2020/Golang_Dream/tree/master/machinery/example ","date":"2020-10-31","objectID":"https://asong2020.github.io/machonery-go%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/:6:3","tags":["machinery"],"title":"machinery入门看这一篇（异步任务队列）","uri":"https://asong2020.github.io/machonery-go%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"},{"categories":["Go应用"],"content":"总结 这一篇文章到这里就结束了，machinery还有很多用法，比如定时任务、定时任务组等等，就不在这一篇文章介绍了。更多使用方法解锁可以观看machinery文档。因为machiney没有中文文档，所以我在学习的过程自己翻译了一篇中文文档，需要的小伙伴们自取。 获取步骤：关注公众号【Golang梦工厂】，后台回复：machiney即可获取无水印版～～～ 好啦，这一篇文章到这就结束了，我们下期见～～。希望对你们有用，又不对的地方欢迎指出，可添加我的golang交流群，我们一起学习交流。 结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。 我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。 **我是asong，一名普普通通的程序猿，让gi我一起慢慢变强吧。我自己建了一个golang交流群，有需要的小伙伴加我vx,我拉你入群。欢迎各位的关注，我们下期见~~~** 推荐往期文章： 手把手教姐姐写消息队列 常见面试题之缓存雪崩、缓存穿透、缓存击穿 详解Context包，看这一篇就够了！！！ go-ElasticSearch入门看这一篇就够了(一) 面试官：go中for-range使用过吗？这几个问题你能解释一下原因吗 学会wire依赖注入、cron定时任务其实就这么简单！ 听说你还不会jwt和swagger-饭我都不吃了带着实践项目我就来了 掌握这些Go语言特性，你的水平将提高N个档次(二) go实现多人聊天室，在这里你想聊什么都可以的啦！！！ grpc实践-学会grpc就是这么简单 go标准库rpc实践 2020最新Gin框架中文文档 asong又捡起来了英语，用心翻译 基于gin的几种热加载方式 ","date":"2020-10-31","objectID":"https://asong2020.github.io/machonery-go%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/:7:0","tags":["machinery"],"title":"machinery入门看这一篇（异步任务队列）","uri":"https://asong2020.github.io/machonery-go%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"},{"categories":["Go面试"],"content":"前言 Hello，everybody，我是asong，上一篇文章我们一起聊一聊了面试中几个常见的缓存问题，今天我依然聊一聊缓存，不过今天我们聊的不是面试了，我们一起来看一看我们在系统中缓存更新的设计，因自己经验有限，所以这些缓存设计来源于网上，我只是在这里总结一下，有什么不对的欢迎指出～～～😊。 ","date":"2020-10-17","objectID":"https://asong2020.github.io/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A5%97%E8%B7%AF/:1:0","tags":["缓存"],"title":"缓存更新的套路你知道几个？","uri":"https://asong2020.github.io/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A5%97%E8%B7%AF/"},{"categories":["Go面试"],"content":"缓存预热 To solve 缓存冷启动 在上一篇文章中[常见面试题之缓存雪崩、缓存穿透、缓存击穿]，忘记讲了一个概念——缓存预热，所以在这篇文章补充一下，开一个好头，预热嘛～～～。 什么是缓存预热呢？我们都知道平常在跑步前都要热身，可以预防肌肉拉伤等一系例的好处。所以缓存预热具有同样的道理，我们的新系统上线后，我们可以将相关的缓存数据直接加载到缓存系统。这样可以避免在用户请求的时候，先去查询数据库，然后再将数据缓存的问题。用户可以直接查询事先已被预热的缓存数据。其实缓存预热是为了解决缓存冷启动问题，我们新系统上线后，redis集群启动后，没有任何的缓存数据，这就是redis的冷启动。 如上图所示，如果不进行预热，那么Redis初识状态数据为空，系统上线初期，对于高并发的流量，都会访问到数据库中，对数据库造成流量的压力。 ","date":"2020-10-17","objectID":"https://asong2020.github.io/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A5%97%E8%B7%AF/:2:0","tags":["缓存"],"title":"缓存更新的套路你知道几个？","uri":"https://asong2020.github.io/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A5%97%E8%B7%AF/"},{"categories":["Go面试"],"content":"如何解决 现在我们已经知道会有缓存预热这个问题，那么就要想一下对策咯。可以分析出以下两点： 需要统计访问频度较高的热点数据 使用LRU数据删除策略，构建数据留存队列 所以我们可以设计一个如下方案： 首先，通过 nginx + lua 的方式，把访问流量数据上报到 Kafka，也可以是其它的 mq 队列。 然后使用实时计算框架(如 storm 、spark streaming、flume)从 kafka 中消费访问流量数据，实时计算出访问频率高的数据，这里统计出来的可能只会有编号信息，如商品编号或博客编号等。 最后，根据编号从 mysql 数据库中查询出具体的信息，写入 redis，开始提供服务。 ","date":"2020-10-17","objectID":"https://asong2020.github.io/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A5%97%E8%B7%AF/:2:1","tags":["缓存"],"title":"缓存更新的套路你知道几个？","uri":"https://asong2020.github.io/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A5%97%E8%B7%AF/"},{"categories":["Go面试"],"content":"缓存更新的几种设计 ","date":"2020-10-17","objectID":"https://asong2020.github.io/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A5%97%E8%B7%AF/:3:0","tags":["缓存"],"title":"缓存更新的套路你知道几个？","uri":"https://asong2020.github.io/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A5%97%E8%B7%AF/"},{"categories":["Go面试"],"content":"1. 先删除缓存，在更新数据库 虽然这是一种错误方法，但是这种设计也是属于缓存更新的一种方法，所以大家还是要知道为什么不可以这么做。还是那句话：知其所以然嘛。 这种方法就是在更新数据库时，先删除缓存，然后在更新数据库，而后续的操作会把数据在装载到缓存中，这种逻辑在并发时就会先脏数据，看如下图： 我们解释一下上图的操作，两个并发操作，一个是更新操作，另一个是查询操作，更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，而且还一直这样脏下去了。所以这个设计是错误的，不建议使用。 ","date":"2020-10-17","objectID":"https://asong2020.github.io/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A5%97%E8%B7%AF/:3:1","tags":["缓存"],"title":"缓存更新的套路你知道几个？","uri":"https://asong2020.github.io/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A5%97%E8%B7%AF/"},{"categories":["Go面试"],"content":"2. Cache aside 这是我们最常用的一种设计模式，其逻辑如下： 查询：程序先从cache中获取数据，有数据直接返回，没有得到，则去数据库中取数据，成功后更新到缓存中。 更新：先把数据存到数据库中，成功后，再让缓存失效。 这种设计正好能解决上文出现脏数据的问题。我们来理一下，一个是查询操作，一个是更新操作的并发，没有了删除cache数据的操作了，而是先更新了数据库中的数据，此时，缓存依旧有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。而不会像文章开头的那个逻辑产生的问题，后续的查询操作一直都在取老的数据。 那么是不是这种设计就不会存在并发问题了呢？不是的，比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。但，这个case理论上会出现，不过，实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。 我们可以为缓存设置上过期时间，这样可以有效解决这个问题。 ","date":"2020-10-17","objectID":"https://asong2020.github.io/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A5%97%E8%B7%AF/:3:2","tags":["缓存"],"title":"缓存更新的套路你知道几个？","uri":"https://asong2020.github.io/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A5%97%E8%B7%AF/"},{"categories":["Go面试"],"content":"3. Read/Write Through 这个模式其实就是将 缓存服务 作为主要的存储，应用的所有读写请求都是直接与缓存服务打交道，而不管最后端的数据库了，数据库的数据由缓存服务来维护和更新。不过缓存中数据变更的时候是同步去更新数据库的，在应用的眼中只有缓存服务。 流程如下： Read Through Read Through 套路就是在查询操作中更新缓存，也就是说，当缓存失效的时候（过期或LRU换出），Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。 Write Through Write Through 套路和Read Through相仿，不过是在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作） 这个模式的特点就是出现脏数据的概率就比较低，但是就强依赖缓存了，对缓存服务的稳定性有较大要求，另外，增加新缓存节点时还会有初始状态空数据问题。 ","date":"2020-10-17","objectID":"https://asong2020.github.io/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A5%97%E8%B7%AF/:3:3","tags":["缓存"],"title":"缓存更新的套路你知道几个？","uri":"https://asong2020.github.io/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A5%97%E8%B7%AF/"},{"categories":["Go面试"],"content":"4. Write Behind Caching Write Behind Caching又叫做Write Back，就是在更新数据的时候，只更新缓存，不更新数据库，而缓存会异步地批量更新数据库。这个设计的好处是让数据的I/O操作可以很快，异步的操作还可以合并对同一个数据的多次操作，性能上是非常可观的。 但是，其带来的问题是，数据不是强一致性的，而且可能会丢失。在软件设计上，我们基本上不可能做出一个没有缺陷的设计，就像算法设计中的时间换空间，空间换时间一个道理，有时候，强一致性和高性能，高可用和高性性是有冲突的。软件设计从来都是取舍Trade-Off。另外，Write Back实现逻辑比较复杂，因为他需要track有哪数据是被更新了的，需要刷到持久层上。操作系统的write back会在仅当这个cache需要失效的时候，才会被真正持久起来，比如，内存不够了，或是进程退出了等情况，这又叫lazy write。 这个模式的特点就是速度很快，效率会非常高，但是数据的一致性比较差，还可能会有数据的丢失情况，实现逻辑也较为复杂。 ","date":"2020-10-17","objectID":"https://asong2020.github.io/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A5%97%E8%B7%AF/:3:4","tags":["缓存"],"title":"缓存更新的套路你知道几个？","uri":"https://asong2020.github.io/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A5%97%E8%B7%AF/"},{"categories":["Go面试"],"content":"总结 上面讲的这几种缓存更新设计，都是一些前人使用的总结，这些设计也不是完美的，这个世界上没有完美的设计，所以我们的设计多多少少会有问题，比如我们没有考虑缓存（Cache）和持久层（Repository）的整体事务的问题。比如，更新Cache成功，更新数据库失败了怎么吗？或是反过来。关于这个事，如果你需要强一致性，就要好好考虑怎么解决这个问题。在软件开发或设计中，我非常建议在之前先去参考一下已有的设计和思路，看看相应的guideline，best practice或design pattern，吃透了已有的这些东西，再决定是否要重新发明轮子。千万不要似是而非地，想当然的做软件设计。 好啦，这一篇文章到这里就结束了，希望对你们有用，又不对的地方欢迎指出，可添加我的golang交流群，我们一起学习交流。 结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。 我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。 **我是asong，一名普普通通的程序猿，让我一起慢慢变强吧。我自己建了一个golang交流群，有需要的小伙伴加我vx,我拉你入群。欢迎各位的关注，我们下期见~~~** 推荐往期文章： 手把手教姐姐写消息队列 常见面试题之缓存雪崩、缓存穿透、缓存击穿 详解Context包，看这一篇就够了！！！ go-ElasticSearch入门看这一篇就够了(一) 面试官：go中for-range使用过吗？这几个问题你能解释一下原因吗 学会wire依赖注入、cron定时任务其实就这么简单！ 听说你还不会jwt和swagger-饭我都不吃了带着实践项目我就来了 掌握这些Go语言特性，你的水平将提高N个档次(二) go实现多人聊天室，在这里你想聊什么都可以的啦！！！ grpc实践-学会grpc就是这么简单 go标准库rpc实践 2020最新Gin框架中文文档 asong又捡起来了英语，用心翻译 基于gin的几种热加载方式 ","date":"2020-10-17","objectID":"https://asong2020.github.io/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A5%97%E8%B7%AF/:4:0","tags":["缓存"],"title":"缓存更新的套路你知道几个？","uri":"https://asong2020.github.io/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A5%97%E8%B7%AF/"},{"categories":["Go应用"],"content":"前言 哈喽，大家好，我是asong，这是我的第16篇原创文章，感谢各位的关注。今天给大家分享设计模式之单例模式，并使用go语言实现。熟悉java的同学对单例模式一定不陌生，单例模式，是一种很常见的软件设计模式，在他的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。下面我们就一起来看一看怎么使用go实现单例模式，这里有一个小坑，一定要注意一下，结尾告诉你哦～～～ ","date":"2020-09-20","objectID":"https://asong2020.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"设计模式之Go语言实现单例模式","uri":"https://asong2020.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["Go应用"],"content":"什么是单例模式 单例模式确保某一个类只有一个实例。为什么要确保一个类只有一个实例？有什么时候才需要用到单例模式呢？听起来一个类只有一个实例好像没什么用呢！ 那我们来举个例子。比如我们的APP中有一个类用来保存运行时全局的一些状态信息，如果这个类实现不是单例的，那么App里面的组件能够随意的生成多个类用来保存自己的状态，等于大家各玩各的，那这个全局的状态信息就成了笑话了。而如果把这个类实现成单例的，那么不管App的哪个组件获取到的都是同一个对象（比如Application类，除了多进程的情况下）。 ","date":"2020-09-20","objectID":"https://asong2020.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"设计模式之Go语言实现单例模式","uri":"https://asong2020.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["Go应用"],"content":"饿汉模式 这里我们使用三种方式实现饿汉模式。先说一下什么是懒汉模式吧，从懒汉这两个字，我们就能知道，这个人很懒，所以他不可能在未使用实例时就创建了对象，他肯定会在使用时才会创建实例，这个好处的就在于，只有在使用的时候才会创建该实例。下面我们一起来看看他的实现： 不加锁 package one type singleton struct { } var instance *singleton func GetInstance() *singleton { if instance == nil{ instance = new(singleton) } return instance } 这种方法是会存在线程安全问题的，在高并发的时候会有多个线程同时掉这个方法，那么都会检测instance为nil，这样就会导致创建多个对象，所以这种方法是不推荐的，我再来看第二种写法。 整个方法加锁 type singleton struct { } var instance *singleton var lock sync.Mutex func GetInstance() *singleton { lock.Lock() defer lock.Unlock() if instance == nil{ instance = new(singleton) } return instance } 这里对整个方法进行了加锁，这种可以解决并发安全的问题，但是效率就会降下来，每一个对象创建时都是进行加锁解锁，这样就拖慢了速度，所以不推荐这种写法。 创建方法时进行锁定 type singleton struct { } var instance *singleton var lock sync.Mutex func GetInstance() *singleton { if instance == nil{ lock.Lock() instance = new(singleton) lock.Unlock() } return instance } 这种方法也是线程不安全的，虽然我们加了锁，多个线程同样会导致创建多个实例，所以这种方式也不是推荐的。所以就有了下面的双重检索机制 双重检锁 type singleton struct { } var instance *singleton var lock sync.Mutex func GetInstance() *singleton { if instance == nil{ lock.Lock() if instance == nil{ instance = new(singleton) } lock.Unlock() } return instance } 这里在上面的代码做了改进，只有当对象未初始化的时候，才会有加锁和减锁的操作。但是又出现了另一个问题：每一次访问都要检查两次，为了解决这个问题，我们可以使用golang标准包中的方法进行原子性操作。 原子操作实现 type singleton struct { } var instance *singleton var once sync.Once func GetInstance() *singleton { once.Do(func() { instance = new(singleton) }) return instance } 这里使用了sync.Once的Do方法可以实现在程序运行过程中只运行一次其中的回调，这样就可以只创建了一个对象，这种方法是推荐的～～～。 ","date":"2020-09-20","objectID":"https://asong2020.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"设计模式之Go语言实现单例模式","uri":"https://asong2020.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["Go应用"],"content":"饿汉模式 有懒汉模式，当然还要有饿汉模式啦，看了懒汉的模式，饿汉模式我们很好解释了，因为他饿呀，所以很着急的就创建了实例，不用等到使用时才创建，这样我们每次调用获取接口将不会重新创建新的对象，而是直接返回之前创建的对象。比较适用于：如果某个单例使用的次数少，并且创建单例消息的资源比较多，那么就需要实现单例的按需创建，这个时候懒汉模式就是一个不错的选择。不过也有缺点，饿汉模式将在包加载的时候就会创建单例对象，当程序中用不到该对象时，浪费了一部分空间，但是相对于懒汉模式，不需要进行了加锁操作，会更安全，但是会减慢启动速度。 下面我们一起来看看go实现饿汉模式： type singleton struct { } var instance = new(singleton) func GetInstance() *singleton{ return instance } 或者 type singleton struct { } var instance *singleton func init() { instance = new(singleton) } func GetInstance() *singleton{ return instance } 这两种方法都可以，第一种我们采用创建一个全局变量的方式来实现，第二种我们使用init包加载的时候创建实例，这里两个都可以，不过根据golang的执行顺序，全局变量的初始化函数会比包的init函数先执行，没有特别的差距。 ","date":"2020-09-20","objectID":"https://asong2020.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"设计模式之Go语言实现单例模式","uri":"https://asong2020.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["Go应用"],"content":"小坑 还记得我开头说的一句话，go语言中使用单例模式有一个小坑，如果不注意，就会导致我们的单例模式没有用，可以观察一下我写的代码，除了GetInstance方法外其他都使用的小写字母开头，知道这是为什么吗？ golang中根据首字母的大小写来确定可以访问的权限。无论是方法名、常量、变量名还是结构体的名称，如果首字母大写，则可以被其他的包访问；如果首字母小写，则只能在本包中使用。可以简单的理解成，首字母大写是公有的，首字母小写是私有的。这里type singleton struct {我们如果使用大写，那么我们写的这些方法就没有意义了，其他包可以通过s := \u0026singleton{}创建多个实例，单例模式就显得很没有意义了，所以这里一定要注意一下哦～～～ ","date":"2020-09-20","objectID":"https://asong2020.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:5:0","tags":["设计模式"],"title":"设计模式之Go语言实现单例模式","uri":"https://asong2020.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["Go应用"],"content":"总结 这一篇就到此结束了，这里讲解了23种模式中最简单的单例模式，虽然他很简单，但是越简单的越容易犯错的呦，所以一定要细心对待每一件事情的呦～～ 好啦，这一篇就到此结束了，我的代码已上传github：https://github.com/asong2020/Golang_Dream/tree/master/code_demo/singleton 欢迎star 结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。 我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。 **我是asong，一名普普通通的程序猿，让我一起慢慢变强吧。我自己建了一个golang交流群，有需要的小伙伴加我vx,我拉你入群。欢迎各位的关注，我们下期见~~~** 推荐往期文章： 手把手教姐姐写消息队列 详解Context包，看这一篇就够了！！！ go-ElasticSearch入门看这一篇就够了(一) 面试官：go中for-range使用过吗？这几个问题你能解释一下原因吗 学会wire依赖注入、cron定时任务其实就这么简单！ 听说你还不会jwt和swagger-饭我都不吃了带着实践项目我就来了 掌握这些Go语言特性，你的水平将提高N个档次(二) go实现多人聊天室，在这里你想聊什么都可以的啦！！！ grpc实践-学会grpc就是这么简单 go标准库rpc实践 2020最新Gin框架中文文档 asong又捡起来了英语，用心翻译 基于gin的几种热加载方式 boss: 这小子还不会使用validator库进行数据校验，开了～～～ ","date":"2020-09-20","objectID":"https://asong2020.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:6:0","tags":["设计模式"],"title":"设计模式之Go语言实现单例模式","uri":"https://asong2020.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["Go应用"],"content":"前言 嗨，everybody，我是asong，这是我的第十二篇文章，今天给大家介绍一下雪花算法。介绍雪花算法是次要的，因为大家都太熟悉了，主要目的是推荐一下我的新系列。今天，我突发奇想，想创建一个新系列。这个系列主要是存储我们日常工作开发中使用的算法，比如雪花算法、哈希算法等等。网络上关于这些算法的知识还是很多的，但是很杂，想找一个算法很不容易，还要看各种各样的博客，五花八门的。所以我们现在的想法就是想将这些算法整理到一起，全部采用go实现，并附带基础知识学习，代码说明这样的详细文档，这样我们想要学习一门新算法时，都可以在这里找到，如果没有也可以提交issues一块完善。目前也是刚刚起步，现在只有雪花算法的代码文档，以后会慢慢完善起来的，有兴趣的小伙伴欢迎加入进来，我们一起完善。详情请看github说明：https://github.com/asong2020/go-algorithm。 ","date":"2020-09-16","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/:1:0","tags":["雪花算法"],"title":"全网最详细的雪花算法教程","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/"},{"categories":["Go应用"],"content":"雪花算法背景 雪花算法产生的背景当然是twitter高并发环境下对唯一ID生成的需求，得益于twitter内部牛逼的技术，雪花算法能够流传于至今并且被广泛使用，是因为它有几个特点 能满足高并发分布式系统环境下ID不重复 生成效率高 基于时间戳，可以保证基本有序递增 不依赖于第三方的库或者中间件 生成的id具有时序性和唯一性 ","date":"2020-09-16","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/:2:0","tags":["雪花算法"],"title":"全网最详细的雪花算法教程","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/"},{"categories":["Go应用"],"content":"雪花算法原理 先来看一个图片吧，来源于网络： 由图我们可以看出来，snowFlake ID结构是一个64bit的int型数据。 第1位bit 在二进制中最高位为1，表示的是负数，因为我们使用的id应该都是整数，所以这里最高位应该是0。 41bit时间戳 41位可以表示2^41-1个数字，如果只用来表示正整数，可以表示的数值范围是：0 - (2^41 -1)，这里减去1的原因就是因为数值范围是从0开始计算的，而不是从1开始的。 这里的单位是毫秒，所以41位就可以表示2^41-1个毫秒值，这样转化成单位年则是 (2^41-1)/(1000 * 60 * 60 * 24 * 365) = 69 10bit-工作机器id 这里是用来记录工作机器的id。2^10=1024表示当前规则允许分布式最大节点数为1024个节点。这里包括5位的workerID和5位的dataCenterID，这里其实可以不区分，但我下面的代码进行了区分。 12bit-序列号 用来记录同毫秒内产生的不同id。12bit可以表示的最大正整数是2^12-1=4095，即可以用0,1,2,3,......4094这4095个数字，表示同一机器同一时间戳(毫秒)内产生的4095个ID序号。 原理就是上面这些，没有什么难度吧，下面我们看代码如何实现： ","date":"2020-09-16","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/:3:0","tags":["雪花算法"],"title":"全网最详细的雪花算法教程","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/"},{"categories":["Go应用"],"content":"go实现雪花算法 1. 定义基本常量 先看代码，我们依次介绍： const ( workerIDBits = uint64(5) // 10bit 工作机器ID中的 5bit workerID dataCenterIDBits = uint64(5) // 10 bit 工作机器ID中的 5bit dataCenterID sequenceBits = uint64(12) maxWorkerID = int64(-1) ^ (int64(-1) \u003c\u003c workerIDBits) //节点ID的最大值 用于防止溢出 maxDataCenterID = int64(-1) ^ (int64(-1) \u003c\u003c dataCenterIDBits) maxSequence = int64(-1) ^ (int64(-1) \u003c\u003c sequenceBits) timeLeft = uint8(22) // timeLeft = workerIDBits + sequenceBits // 时间戳向左偏移量 dataLeft = uint8(17) // dataLeft = dataCenterIDBits + sequenceBits workLeft = uint8(12) // workLeft = sequenceBits // 节点IDx向左偏移量 // 2020-05-20 08:00:00 +0800 CST twepoch = int64(1589923200000) // 常量时间戳(毫秒) ) 下面对这段代码的每一个常量进行解释： worerIDBits：这里就是对应上图中的10bit-工作机器id，我这里进行拆分了。这是其中5bit``worerIDBits` dataCenterIDBits：这里就是对应上图中的10bit-工作机器id，我这里进行拆分了。这是其中5bitdataCenterIDBits sequenceBits：对应上图中的12bit的序列号 maxWorkerID：这里就是求最大，只不过我们采用了异或的方式，因为-1的二进制表示为1的补码，说通俗一点，这里其实就是2^5-1，还不懂的同学，可以自己验证一下 maxDataCenterID：原理同上 maxSequence：原理同上 timeLeft：时间戳向左偏移量，这么你们可能不懂，看上面的图片，由有向左的偏移量是不是22，这么说你们懂了吗？ dataLeft：原理同上，也是求偏移量的 workLeft：原理同上； twepoch：41bit的时间戳，单位是毫秒，这里我选择的时间是2020-05-20 08:00:00 +0800 CST，这个ID一但生成就不要改了，要不会生成相同的ID。 2. 定义worker工作节点 因为这个是在分布式下使用的ID生成算法，所以我们要生成多个worker，所以要把节点参数抽象出来。 type Worker struct { mu sync.Mutex LastStamp int64 // 记录上一次ID的时间戳 WorkerID int64 // 该节点的ID DataCenterID int64 // 该节点的 数据中心ID Sequence int64 // 当前毫秒已经生成的ID序列号(从0 开始累加) 1毫秒内最多生成4096个ID } 代码解释： mu sync.Mutex：添加互斥锁，确保并发安全性 LastStamp int64：记录上一次生成ID的时间戳 WorkerID int64：该工作节点的ID 对上图中的5bit workerID 一个意思 DataCenterID int64： 原理同上 Sequence int64：当前毫秒已经生成的id序列号(从0开始累加) 1毫秒内最多生成4096个ID 3. 创建一个worker对象 //分布式情况下,我们应通过外部配置文件或其他方式为每台机器分配独立的id func NewWorker(workerID,dataCenterID int64) *Worker { return \u0026Worker{ WorkerID: workerID, LastStamp: 0, Sequence: 0, DataCenterID: dataCenterID, } } 这里没有什么好解释的～～～。 4. 生成id 先看代码： func (w *Worker) getMilliSeconds() int64 { return time.Now().UnixNano() / 1e6 } func (w *Worker)NextID() (uint64,error) { w.mu.Lock() defer w.mu.Unlock() return w.nextID() } func (w *Worker)nextID() (uint64,error) { timeStamp := w.getMilliSeconds() if timeStamp \u003c w.LastStamp{ return 0,errors.New(\"time is moving backwards,waiting until\") } if w.LastStamp == timeStamp{ w.Sequence = (w.Sequence + 1) \u0026 maxSequence if w.Sequence == 0 { for timeStamp \u003c= w.LastStamp { timeStamp = w.getMilliSeconds() } } }else { w.Sequence = 0 } w.LastStamp = timeStamp id := ((timeStamp - twepoch) \u003c\u003c timeLeft) | (w.DataCenterID \u003c\u003c dataLeft) | (w.WorkerID \u003c\u003c workLeft) | w.Sequence return uint64(id),nil } 代码有点长，我先来依次解释一下： getMilliSeconds()：封装的一个方法，用来获取当前的毫秒值 func (w *Worker)NextID() (uint64,error) 这个代码的内容没有什么，具体生成ID算法封装在func (w *Worker)nextID() (uint64,error)这里了，这里不过是为了解藕作用；对了还有一个特别重要的地方，加锁、释放锁，这个步骤很重要。 func (w *Worker)nextID() (uint64,error) 这里是真正的生成id代码了。分为几个步骤： 获取当前时间戳，进行判断，要确保当前时间戳值大于上一次生成ID的时间戳，否则会出现重复。 如果想等了，首先获取当前的当前毫秒已经生成的id序列号。这里你们可能没看懂，其实他等效于if w.sequence++ \u003e maxSequence , 如果当前毫秒已经生成的id序列号溢出了，则需要等待下一毫秒，如果不等待，就会导致很多重复。 我们在else里将w.sequence置零了，这里解释一下，如果当前时间与工作节点上一次生成ID的时间不一致 则需要重置工作节点生成ID的序号。 最后一步，比较重要，采用了或运算，这里的目的就是各部分的bit进行归位并通过按位或运算(就是这个‘|’)将其整合。\u003c\u003c这个就是向左偏移的作用进行归位，而|运算就是为了整合。可能大家还没懂，看下面这一张图片吧： 怎么样，是不是知道什么意思了。 5. 测试 写好了代码，我们就来测试一下吧，这里我并发10000个goroutine进行生成ID，存入到map，查看是否出现重复，来看代码： var wg sync.WaitGroup func main() { w := idgen.NewWorker(5,5) ch := make(chan uint64,10000) count := 10000 wg.Add(count) defer close(ch) //并发 count个goroutine 进行 snowFlake ID 生成 for i:=0 ; i \u003c count ; i++ { go func() { defer wg.Done() id,_ := w.NextID() ch \u003c- id }() } wg.Wait() m := make(map[uint64]int) for i := 0; i \u003c count; i++ { id := \u003c- ch // 如果 map 中存在为 id 的 key, 说明生成的 snowflake ID 有重复 _, ok := m[id] if ok { fmt.Printf(\"repeat id %d\\n\",id) return } // 将 id 作为 key 存入 map m[id] = i } // 成功生成 snowflake ID fmt.Println(\"All\", len(m), \"snowflake ID Get successed!\") } 验证结果： All 10000 snowflake ID Get successed! ","date":"2020-09-16","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/:4:0","tags":["雪花算法"],"title":"全网最详细的雪花算法教程","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/"},{"categories":["Go应用"],"content":"总结 好啦，这一篇文章到这里结束啦，雪花算法并没有我们想象的那么难，还是很好实现的，你学会了吗？ 没学会不要紧，下载源代码，再看一看，对你不是问题的～～～。 GitHub：https://github.com/asong2020/go-algorithm 欢迎star 感谢各位～～～ 朋友们，还记得我开头说的那些吗？有兴趣的欢迎加入进来呦，我们一起进步～～～。 结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。 我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。 **我是asong，一名普普通通的程序猿，让我一起慢慢变强吧。我自己建了一个golang交流群，有需要的小伙伴加我vx,我拉你入群。欢迎各位的关注，我们下期见~~~** 推荐往期文章： 详解Context包，看这一篇就够了！！！ go-ElasticSearch入门看这一篇就够了(一) 面试官：go中for-range使用过吗？这几个问题你能解释一下原因吗 学会wire依赖注入、cron定时任务其实就这么简单！ 听说你还不会jwt和swagger-饭我都不吃了带着实践项目我就来了 掌握这些Go语言特性，你的水平将提高N个档次(二) go实现多人聊天室，在这里你想聊什么都可以的啦！！！ grpc实践-学会grpc就是这么简单 go标准库rpc实践 2020最新Gin框架中文文档 asong又捡起来了英语，用心翻译 基于gin的几种热加载方式 boss: 这小子还不会使用validator库进行数据校验，开了～～～ ","date":"2020-09-16","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/:5:0","tags":["雪花算法"],"title":"全网最详细的雪花算法教程","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/"},{"categories":["Go应用"],"content":"前言 哈喽，everybody，这是go-elastic学习系列教程第二篇文章。上一篇我们学习了ElasticSearch基础，如果还不懂基础的，可以先看一看上一篇文章，传送门。这一篇我们开始实战，写了一个小demo，带你们轻松入门ElasticSearch实战开发，再也不用担心es部分的需求开发了。代码已上传github,可自行下载学习。如果能给一个小星星就好啦。好啦，废话不多说，直接开始吧。 github地址：https://github.com/asong2020/Golang_Dream/tree/master/code_demo/go-elastic-asong ","date":"2020-09-12","objectID":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%BA%8C/:1:0","tags":["elasticSearch"],"title":"go-ElasticSearch实战篇(二)","uri":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%BA%8C/"},{"categories":["Go应用"],"content":"背景 在开始之前，我先来介绍一下我这个样例的功能： 添加用户信息 更新用户信息 删除用户信息 根据电话查询指定用户 根据昵称、身份、籍贯查询相关用户（查找相似昵称的用户列表、身份相同的用户列表、同城的用户列表） ","date":"2020-09-12","objectID":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%BA%8C/:2:0","tags":["elasticSearch"],"title":"go-ElasticSearch实战篇(二)","uri":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%BA%8C/"},{"categories":["Go应用"],"content":"1. 创建客户端 在进行开发之前，我们需要下载一个Es依赖库。 $ go get -u github.com/olivere/elastic/v7 下载好了依赖库，下面我们开始编写代码，首先我们需要创建一个client，用于操作ES，先看代码，然后在进行讲解： func NewEsClient(conf *config.ServerConfig) *elastic.Client { url := fmt.Sprintf(\"http://%s:%d\", conf.Elastic.Host, conf.Elastic.Port) client, err := elastic.NewClient( //elastic 服务地址 elastic.SetURL(url), // 设置错误日志输出 elastic.SetErrorLog(log.New(os.Stderr, \"ELASTIC \", log.LstdFlags)), // 设置info日志输出 elastic.SetInfoLog(log.New(os.Stdout, \"\", log.LstdFlags))) if err != nil { log.Fatalln(\"Failed to create elastic client\") } return client } 这里创建client是使用的NewClient这个方法进行实现的，在创建时，可以提供ES连接参数。上面列举的不全，下面给大家介绍一下。 elastic.SetURL(url)用来设置ES服务地址，如果是本地，就是127.0.0.1:9200。支持多个地址，用逗号分隔即可。 elastic.SetBasicAuth(\"user\", \"secret\")这个是基于http base auth 验证机制的账号密码。 elastic.SetGzip(true)启动gzip压缩 elastic.SetHealthcheckInterval(10*time.Second)用来设置监控检查时间间隔 elastic.SetMaxRetries(5)设置请求失败最大重试次数，v7版本以后已被弃用 elastic.SetSniff(false)允许指定弹性是否应该定期检查集群（默认为true） elastic.SetErrorLog(log.New(os.Stderr, \"ELASTIC \", log.LstdFlags)) 设置错误日志输出 elastic.SetInfoLog(log.New(os.Stdout, \"\", log.LstdFlags)) 设置info日志输出 这面这些参数根据自己的使用进行选择。 ","date":"2020-09-12","objectID":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%BA%8C/:3:0","tags":["elasticSearch"],"title":"go-ElasticSearch实战篇(二)","uri":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%BA%8C/"},{"categories":["Go应用"],"content":"2. 创建index及mapping 上一步，我们创建了client，接下来我们就要创建对应的索引以及mapping。根据开始介绍的功能，我们来设计我们的mapping结构： mappingTpl = `{ \"mappings\":{ \"properties\":{ \"id\": { \"type\": \"long\" }, \"username\": { \"type\": \"keyword\" }, \"nickname\": { \"type\": \"text\" }, \"phone\": { \"type\": \"keyword\" }, \"age\": { \"type\": \"long\" }, \"ancestral\": { \"type\": \"text\" }, \"identity\": { \"type\": \"text\" }, \"update_time\": { \"type\": \"long\" }, \"create_time\": { \"type\": \"long\" } } } }` 索引设计为：index =asong_golang_dream 。 设计好了index及mapping后，我们开始编写代码进行创建： func NewUserES(client *elastic.Client) *UserES { index := fmt.Sprintf(\"%s_%s\", author, project) userEs := \u0026UserES{ client: client, index: index, mapping: mappingTpl, } userEs.init() return userEs } func (es *UserES) init() { ctx := context.Background() exists, err := es.client.IndexExists(es.index).Do(ctx) if err != nil { fmt.Printf(\"userEs init exist failed err is %s\\n\", err) return } if !exists { _, err := es.client.CreateIndex(es.index).Body(es.mapping).Do(ctx) if err != nil { fmt.Printf(\"userEs init failed err is %s\\n\", err) return } } } 这里我们首先判断es中是否已经存在要创建的索引，不存在，调用CreateIndex进行创建。 ","date":"2020-09-12","objectID":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%BA%8C/:4:0","tags":["elasticSearch"],"title":"go-ElasticSearch实战篇(二)","uri":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%BA%8C/"},{"categories":["Go应用"],"content":"3. 批量添加 完成一切准备工作，我们接下来就该进行数据的增删改查了。目前该索引下是没有数据，我们先来学习批量添加，添加一些数据，方便后面的使用。 这里批量添加使用的是bulkAPI，bulkAPI允许在单个步骤中进行多次create、index，update、delete请求。如果你需要索引一个数据流比如日志事件，它可以排队和索引数百或数千批次。bulk 与其他的请求体格式稍有不同，如下所示： { action: { metadata }}\\n { request body }\\n { action: { metadata }}\\n { request body }\\n ... 这种格式类似一个有效的单行 JSON 文档 流 ，它通过换行符(\\n)连接到一起。注意两个要点： 每行一定要以换行符(\\n)结尾， 包括最后一行 。这些换行符被用作一个标记，可以有效分隔行。 这些行不能包含未转义的换行符，因为他们将会对解析造成干扰。这意味着这个 JSON 不 能使用 pretty 参数打印。 action/metadata 行指定 哪一个文档 做 什么操作 。 action 必须是以下选项之一: create：如果文档不存在，那么就创建它。 index：创建一个新文档或者替换一个现有的文档。 update：部分更新一个文档 delete：删除一个文档 这里我使用的是index，代码实现如下： func (es *UserES) BatchAdd(ctx context.Context, user []*model.UserEs) error { var err error for i := 0; i \u003c esRetryLimit; i++ { if err = es.batchAdd(ctx, user); err != nil { fmt.Println(\"batch add failed \", err) continue } return err } return err } func (es *UserES) batchAdd(ctx context.Context, user []*model.UserEs) error { req := es.client.Bulk().Index(es.index) for _, u := range user { u.UpdateTime = uint64(time.Now().UnixNano()) / uint64(time.Millisecond) u.CreateTime = uint64(time.Now().UnixNano()) / uint64(time.Millisecond) doc := elastic.NewBulkIndexRequest().Id(strconv.FormatUint(u.ID, 10)).Doc(u) req.Add(doc) } if req.NumberOfActions() \u003c 0 { return nil } if _, err := req.Do(ctx); err != nil { return err } return nil } 写好了代码，接下来我们就来测试一下，这个程序使用的gin框架，API：http://localhost:8080/api/user/create，运行代码，发送一个请求，测试一下： $ curl --location --request POST 'http://localhost:8080/api/user/create' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"id\": 6, \"username\": \"asong6\", \"nickname\": \"Golang梦工厂\", \"phone\": \"17897875432\", \"age\": 20, \"ancestral\": \"吉林省深圳市\", \"identity\": \"工人\" }' 返回结果： { \"code\": 0, \"msg\": \"success\" } 注意：这里有一个点需要说一下，这里我加了一个for循环是为了做重试机制的，重试机会为3次，超过则返回。 为了确保我们插入成功，可以验证一下，发送如下请求： $ curl --location --request GET 'http://localhost:9200/asong_golang_dream/_search' ","date":"2020-09-12","objectID":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%BA%8C/:5:0","tags":["elasticSearch"],"title":"go-ElasticSearch实战篇(二)","uri":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%BA%8C/"},{"categories":["Go应用"],"content":"4. 批量更新 上面介绍了bulkAPI，批量更新依然也是采用的这个方法，action选项为update。实现代码如下： func (es *UserES) BatchUpdate(ctx context.Context, user []*model.UserEs) error { var err error for i := 0; i \u003c esRetryLimit; i++ { if err = es.batchUpdate(ctx, user); err != nil { continue } return err } return err } func (es *UserES) batchUpdate(ctx context.Context, user []*model.UserEs) error { req := es.client.Bulk().Index(es.index) for _, u := range user { u.UpdateTime = uint64(time.Now().UnixNano()) / uint64(time.Millisecond) doc := elastic.NewBulkUpdateRequest().Id(strconv.FormatUint(u.ID, 10)).Doc(u) req.Add(doc) } if req.NumberOfActions() \u003c 0 { return nil } if _, err := req.Do(ctx); err != nil { return err } return nil } 验证一下： $ curl --location --request PUT 'http://localhost:8080/api/user/update' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"id\": 1, \"username\": \"asong\", \"nickname\": \"Golang梦工厂\", \"phone\": \"17888889999\", \"age\": 21, \"ancestral\": \"吉林省\", \"identity\": \"工人\" }' 结果： { \"code\": 0, \"msg\": \"success\" } ","date":"2020-09-12","objectID":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%BA%8C/:6:0","tags":["elasticSearch"],"title":"go-ElasticSearch实战篇(二)","uri":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%BA%8C/"},{"categories":["Go应用"],"content":"5. 批量删除 批量删除也是采用的bulkAPI，即action选项为delete。代码实现如下： func (es *UserES) BatchDel(ctx context.Context, user []*model.UserEs) error { var err error for i := 0; i \u003c esRetryLimit; i++ { if err = es.batchDel(ctx, user); err != nil { continue } return err } return err } func (es *UserES) batchDel(ctx context.Context, user []*model.UserEs) error { req := es.client.Bulk().Index(es.index) for _, u := range user { doc := elastic.NewBulkDeleteRequest().Id(strconv.FormatUint(u.ID, 10)) req.Add(doc) } if req.NumberOfActions() \u003c 0 { return nil } if _, err := req.Do(ctx); err != nil { return err } return nil } 测试一下： curl --location --request DELETE 'http://localhost:8080/api/user/delete' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"id\": 1, \"username\": \"asong\", \"nickname\": \"Golang梦工厂\", \"phone\": \"17888889999\", \"age\": 21, \"ancestral\": \"吉林省\", \"identity\": \"工人\" }' ","date":"2020-09-12","objectID":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%BA%8C/:7:0","tags":["elasticSearch"],"title":"go-ElasticSearch实战篇(二)","uri":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%BA%8C/"},{"categories":["Go应用"],"content":"6. 查询 有了数据，我们根据条件查询我们想要的数据了。这里我使用的是bool组合查询，这个查询语法，我在之前的文章也讲解过，不懂得可以先看一下这一篇文章： https://mp.weixin.qq.com/s/mV2hnfctQuRLRKpPPT9XRw。 我们先看代码吧： func (r *SearchRequest) ToFilter() *EsSearch { var search EsSearch if len(r.Nickname) != 0 { search.ShouldQuery = append(search.ShouldQuery, elastic.NewMatchQuery(\"nickname\", r.Nickname)) } if len(r.Phone) != 0 { search.ShouldQuery = append(search.ShouldQuery, elastic.NewTermsQuery(\"phone\", r.Phone)) } if len(r.Ancestral) != 0 { search.ShouldQuery = append(search.ShouldQuery, elastic.NewMatchQuery(\"ancestral\", r.Ancestral)) } if len(r.Identity) != 0 { search.ShouldQuery = append(search.ShouldQuery, elastic.NewMatchQuery(\"identity\", r.Identity)) } if search.Sorters == nil { search.Sorters = append(search.Sorters, elastic.NewFieldSort(\"create_time\").Desc()) } search.From = (r.Num - 1) * r.Size search.Size = r.Size return \u0026search } func (es *UserES) Search(ctx context.Context, filter *model.EsSearch) ([]*model.UserEs, error) { boolQuery := elastic.NewBoolQuery() boolQuery.Must(filter.MustQuery...) boolQuery.MustNot(filter.MustNotQuery...) boolQuery.Should(filter.ShouldQuery...) boolQuery.Filter(filter.Filters...) // 当should不为空时，保证至少匹配should中的一项 if len(filter.MustQuery) == 0 \u0026\u0026 len(filter.MustNotQuery) == 0 \u0026\u0026 len(filter.ShouldQuery) \u003e 0 { boolQuery.MinimumShouldMatch(\"1\") } service := es.client.Search().Index(es.index).Query(boolQuery).SortBy(filter.Sorters...).From(filter.From).Size(filter.Size) resp, err := service.Do(ctx) if err != nil { return nil, err } if resp.TotalHits() == 0 { return nil, nil } userES := make([]*model.UserEs, 0) for _, e := range resp.Each(reflect.TypeOf(\u0026model.UserEs{})) { us := e.(*model.UserEs) userES = append(userES, us) } return userES, nil } 我们查询之前进行了条件绑定，这个条件通过API进行设定的，根据条件绑定不同query。phone是具有唯一性的，所以我们可以采用精确查询，也就是使用NewTermsQuery进行绑定。Nickname、Identity、Ancestral这些都属于模糊查询，所以我们可以使用匹配查询，用NewMatchQuery进行绑定·。查询的数据我们在根据创建时间进行排序。时间由近到远进行排序。 代码量不是很多，看一篇就能懂了，我接下来测试一下： $ curl --location --request POST 'http://localhost:8080/api/user/search' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"nickname\": \"\", \"phone\": \"\", \"identity\": \"\", \"ancestral\": \"吉林省\", \"num\": 1, \"size\":10 }' 这里进行说明一下，使用json来选择不同的条件，需要那个条件就填写json就好了。这个测试的查询条件就是查找出籍贯是吉林省的用户列表，通过num、size限制查询数据量，即第一页，数据量为10。 验证结果： { \"code\": 0, \"data\": [ { \"id\": 6, \"username\": \"asong6\", \"nickname\": \"Golang梦工厂\", \"phone\": \"17897875432\", \"age\": 20, \"ancestral\": \"吉林省吉林市\", \"identity\": \"工人\", \"update_time\": 1599905564941, \"create_time\": 1599905564941 }, { \"id\": 2, \"username\": \"asong2\", \"nickname\": \"Golang梦工厂\", \"phone\": \"17897873456\", \"age\": 20, \"ancestral\": \"吉林省吉林市\", \"identity\": \"学生\", \"update_time\": 1599905468869, \"create_time\": 1599905468869 }, { \"id\": 1, \"username\": \"asong1\", \"nickname\": \"Golang梦工厂\", \"phone\": \"17897870987\", \"age\": 20, \"ancestral\": \"吉林省吉林市\", \"identity\": \"工人\", \"update_time\": 1599900090160, \"create_time\": 1599900090160 } ], \"msg\": \"success\" } 目前我的数据量没有那么大，所以只有三条数据，你们可以自己测试一下，添加更多的数据进行测试。 ","date":"2020-09-12","objectID":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%BA%8C/:8:0","tags":["elasticSearch"],"title":"go-ElasticSearch实战篇(二)","uri":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%BA%8C/"},{"categories":["Go应用"],"content":"6. 批量查询 在一些场景中，我们需要通过多个ID批量查询文档。es中提供了一个multiGet进行批量查询，不过我这里实现的不是用这个方法。因为用更好的方法可以使用。multiGet批量查询的实现是跟redis的pipeline是一个道理的，缓存所有请求，然后统一进行请求，所以这里只是减少了IO的使用。所以我们可以使用更好的方法，使用search查询，它提供了根据id查询的方法，这个方法是一次请求，完成所有的查询，更高效，所以推荐大家使用这个方法进行批量查询。 代码实现如下： // 根据id 批量获取 func (es *UserES) MGet(ctx context.Context, IDS []uint64) ([]*model.UserEs, error) { userES := make([]*model.UserEs, 0, len(IDS)) idStr := make([]string, 0, len(IDS)) for _, id := range IDS { idStr = append(idStr, strconv.FormatUint(id, 10)) } resp, err := es.client.Search(es.index).Query( elastic.NewIdsQuery().Ids(idStr...)).Size(len(IDS)).Do(ctx) if err != nil { return nil, err } if resp.TotalHits() == 0 { return nil, nil } for _, e := range resp.Each(reflect.TypeOf(\u0026model.UserEs{})) { us := e.(*model.UserEs) userES = append(userES, us) } return userES, nil } 好啦，写好了代码我们进行验证一下吧。 $ curl --location --request GET 'http://localhost:8080/api/user/info?id=1,2,3' 验证结果: { \"code\": 0, \"data\": [ { \"id\": 1, \"username\": \"asong\", \"nickname\": \"Golang梦工厂\", \"phone\": \"88889999\", \"age\": 18, \"ancestral\": \"广东省深圳市\", \"identity\": \"工人\" }, { \"id\": 2, \"username\": \"asong1\", \"nickname\": \"Golang梦工厂\", \"phone\": \"888809090\", \"age\": 20, \"ancestral\": \"吉林省吉林市\", \"identity\": \"学生\" }, { \"id\": 3, \"username\": \"asong2\", \"nickname\": \"Golang梦工厂\", \"phone\": \"88343409090\", \"age\": 21, \"ancestral\": \"吉林省吉林市\", \"identity\": \"学生\" } ], \"msg\": \"success\" } ","date":"2020-09-12","objectID":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%BA%8C/:9:0","tags":["elasticSearch"],"title":"go-ElasticSearch实战篇(二)","uri":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%BA%8C/"},{"categories":["Go应用"],"content":"总结 这一篇到这里就结束了。本文通过一个代码样例，学习使用go进行eslatic开发，本文没有将所有方法都讲全，只是将我们日常使用的一些方法整理出来，供大家入门使用，也可以修改一下使用到项目中呦，以为我在项目中也是这么使用的。如果上面的代码段没有看懂，可以到我的github上下载源代码进行学习，运行整个项目，通过api进行测试。如果觉得有用，给个小星星呗！！！ github地址：https://github.com/asong2020/Golang_Dream/tree/master/code_demo/go-elastic-asong 结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。 我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。 **我是asong，一名普普通通的程序猿，让我一起慢慢变强吧。我自己建了一个golang交流群，有需要的小伙伴加我vx,我拉你入群。欢迎各位的关注，我们下期见~~~** 推荐往期文章： go-ElasticSearch入门看这一篇就够了(一) 面试官：go中for-range使用过吗？这几个问题你能解释一下原因吗 学会wire依赖注入、cron定时任务其实就这么简单！ 听说你还不会jwt和swagger-饭我都不吃了带着实践项目我就来了 掌握这些Go语言特性，你的水平将提高N个档次(二) go实现多人聊天室，在这里你想聊什么都可以的啦！！！ grpc实践-学会grpc就是这么简单 go标准库rpc实践 2020最新Gin框架中文文档 asong又捡起来了英语，用心翻译 基于gin的几种热加载方式 boss: 这小子还不会使用validator库进行数据校验，开了～～～ ","date":"2020-09-12","objectID":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%BA%8C/:10:0","tags":["elasticSearch"],"title":"go-ElasticSearch实战篇(二)","uri":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%BA%8C/"},{"categories":["Go应用"],"content":"前言 嗨，every body，我又来了。这回你们没有看错，今天带来的就是go-elastic的入门教程，打了好久的预告，今天终于上线了。因为笔主本人也是一个新手，所以也不敢讲太深入的东西，这一篇完全是一个入门级别的教程，适合初学者，所以本文主打通俗易懂教程，帮助那些和我一样刚入门的朋友，快速应用到开发中。所以我打算分两篇文章来讲解，第一篇主要讲一下什么是ElasticSearch，第二篇我们来学习一下olivere/elastic/v7库，应用到实际项目开发中，我会把我自己常用的轮子分享出来，还没写完，详情会发在我的第二篇博文上。 ","date":"2020-09-07","objectID":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%B8%80/:1:0","tags":["elasticSearch"],"title":"go-ElasticSearch入门看这一篇就够了(一)","uri":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%B8%80/"},{"categories":["Go应用"],"content":"初识ElasticSearch ElasticSearch是一个分布式、RESTful风格的搜索和数据分析引擎，在国内简称为ES；使用Java开发的，底层基于Lucene是一种全文检索的搜索库，直接使用使用Lucene还是比较麻烦的，Elasticsearch在Lucene的基础上开发了一个强大的搜索引擎。前面说这么多，对于新手的你，其实还是不知道他是干什么的。简单来说，他就是一个搜索引擎，可以快速存储、搜索和分析海量数据。我们常用的github、Stack Overflow都采用的Es来做的。为了让你们知道他是干什么的，我们先来分析一下他的功能与适用场景。 ","date":"2020-09-07","objectID":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%B8%80/:2:0","tags":["elasticSearch"],"title":"go-ElasticSearch入门看这一篇就够了(一)","uri":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%B8%80/"},{"categories":["Go应用"],"content":"适用场景 从上面的介绍，我们可以分析出ElasticSearch的功能： 分布式的搜索引擎和数据分析引擎 全文检索、结构化检索、数据分析 对海量数据进行近实时的处理 我们都知道Elastic的底层是开源库Lucene。但是，你却没法直接用Lucene，必须直接写代码去调用它的接口。Elastic 是 Lucene 的封装，提供了 REST API 的操作接口，开箱即用。我们现在来分析一下这俩的区别： Lucene：是单机应用，只能在单台服务器上使用，最多只能处理单台服务器可以处理的数据量。 Elasric：ES自动可以将海量数据分散到多台服务器上去存储和检索海联数据的处理：分布式以后，就可以采用大量的服务器去存储和检索数据，自然而然就可以实现海量数据的处理了，近实时；在秒级别对数据进行搜索和分析。 国内外公司使用场景如下： 国外 维基百科，类似百度百科，全文检索，高亮，搜索推荐 Stack Overflow（国外的程序异常讨论论坛） GitHub（开源代码管理） 电商网站，检索商品 日志数据分析，logstash采集日志，ES进行复杂的数据分析（ELK技术，elasticsearch+logstash+kibana） BI系统，商业智能，Business Intelligence。 国内 站内搜索（电商，招聘，门户） IT系统搜索（OA，CRM，ERP） 数据分析（ES热门的一个使用场景） ","date":"2020-09-07","objectID":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%B8%80/:3:0","tags":["elasticSearch"],"title":"go-ElasticSearch入门看这一篇就够了(一)","uri":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%B8%80/"},{"categories":["Go应用"],"content":"特点 Es为什么这么受欢迎，他有什么特点吗？当然是有的，我们一起来看看它的优点。 Elasticsearch不是什么新技术，主要是将全文检索、数据分析以及分布式技术，合并在了一起，才形成了独一无二的ES；lucene（全文检索），商用的数据分析软件（也是有的），分布式数据库（mycat） 数据库的功能面对很多领域是不够用的（事务，还有各种联机事务型的操作）；特殊的功能，比如全文检索，同义词处理，相关度排名，复杂数据分析，海量数据的近实时处理；Elasticsearch作为传统数据库的一个补充，提供了数据库所不不能提供的很多功能 可以作为一个大型分布式集群（数百台服务器）技术，处理PB级数据，服务大公司；也可以运行在单机上，服务小公司 对用户而言，是开箱即用的，非常简单，作为中小型的应用，直接3分钟部署一下ES，就可以作为生产环境的系统来使用了，数据量不大，操作不是太复杂 现在我们应该知道ES是什么了吧，下面我就来安装他，学习怎么使用。 ","date":"2020-09-07","objectID":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%B8%80/:4:0","tags":["elasticSearch"],"title":"go-ElasticSearch入门看这一篇就够了(一)","uri":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%B8%80/"},{"categories":["Go应用"],"content":"安装 ES的安装，还是比较简单的。我们只需要下载压缩包，解压缩即可。根据自己的系统选择下载即可。下载地址：https://www.elastic.co/cn/downloads/elasticsearch。 因为我的是macos系统，所以以下操作都是基于mac的。 我下载的版本是： elasticsearch-7.9.0。下载好后，需要进行解压。 $ tar -zxvf elasticsearch-7.9.0-darwin-x86_64.tar.gz /usr/local/Cellar 解压好了，我们就可以进入到相应目录，启动es了。 $ cd /usr/local/elasticsearch-7.9.0/bin $ ./elasticsearch 启动后，访问http://localhost:9200/ ，如果可以正常访问，就说明安装成功了。 安装成功后，我们来尝试使用一下。elasticsearch是以http Restful api的形式提供接口，我们要操作ES，只要调用http接口就行，ES的默认端口是9200, 因此上面例子可以直接通过浏览器访问ES的接口。大家都知道Http Restful api风格的请求动作，主要包括：GET、POST、PUT、DELETE四种，直接通过浏览器访问，发送的是GET请求动作，后面的三种动作，不方便用浏览器模拟，除非你自己写程序调用，但是我们平时测试，又不想写代码，所以建议使用curl命令、或者postman可视化工具发送http请求。 url 例子 $ curl -X GET \"localhost:9200/_search\" #结果 {\"took\":35,\"timed_out\":false,\"_shards\":{\"total\":2,\"successful\":2,\"skipped\":0,\"failed\":0},\"hits\":{\"total\":{\"value\":0,\"relation\":\"eq\"},\"max_score\":null,\"hits\":[]}}% ","date":"2020-09-07","objectID":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%B8%80/:5:0","tags":["elasticSearch"],"title":"go-ElasticSearch入门看这一篇就够了(一)","uri":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%B8%80/"},{"categories":["Go应用"],"content":"Kibana 虽然平常直接使用Restful api操作ES还是挺方便的，但是对我这样用惯可视化工具的人来说，还是挺难受的。这不Kibana出现了，解决了我的痛苦。我们可以使用Kibana工具操作ES，Kibana以Web后台的形式提供了一个可视化操作ES的系统，支持根据ES数据绘制图表，支持ES查询语法自动补全等高级特性。是不是很强大，我们现在就来学习怎么使用。 Kibana也是java开发的，安装启动非常简单，只要下载安装包，解压缩后启动即可。下载地址：https://www.elastic.co/cn/downloads/kibana 我下载的版本是kibana-7.9.1-darwin-x86_64.tar.gz。 $ tar -zxvf kibana-7.9.1-darwin-x86_64.tar.gz $ cd /usr/local/Cellar/kibana-7.9.1-darwin-x86_64/bin $ ./kibana 启动后，访问 http://localhost:5601，就可以进入kibana, 首次访问，因为没有数据，会显示如下窗口。 我们平时开发的时候，编写ES查询语句，可以使用Kibana提供的开发工具Console（控制台），调试ES查询有没有问题，Console支持语法补全和语法提示非常方便。 只要进入Kibana后台，点击左侧菜单的Dev Tools就可以进入Console后台。这里我就不截图了，使用还是比较简单的。 ","date":"2020-09-07","objectID":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%B8%80/:6:0","tags":["elasticSearch"],"title":"go-ElasticSearch入门看这一篇就够了(一)","uri":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%B8%80/"},{"categories":["Go应用"],"content":"快速入门 好啦，前面的铺垫，就是为了接下来的使用，我们在学习一门技术时，我的个人习惯是先使用上，然后再去学习其原理，要不会是一头雾水的。就好比我在公司看其他同事的代码，我不是上来就看代码，而是先把项目运行起来，看一看实现了什么功能，哪个功能在代码中怎么实现的，有目的性的学习，才能更好的得到吸收。好啦，不废话啦，开始接下来的学习。 ","date":"2020-09-07","objectID":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%B8%80/:7:0","tags":["elasticSearch"],"title":"go-ElasticSearch入门看这一篇就够了(一)","uri":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%B8%80/"},{"categories":["Go应用"],"content":"1. 存储结构 大家对mysq的存储结构应该是很清楚的，所以咱们在学习ES存储结构时，同时类比mysql，这样理解起来会更透彻。mysql的数据模型由数据库、表、字段、字段类型组成，自然ES也有自己的一套存储结构。 先看一个表格，然后我们在展开学习每一部分。 ES存储结构 Mysql存储结构 Index（索引） 表 文档 行，一行数据 Field（字段） 表字段 mapping(映射) 表结构定义 1.1 index ES中索引(index)就像mysql中的表一样，代表着文档数据的集合，文档就相当于ES中存储的一条数据，下面会详细介绍。 1.2 type type也就是文档类型，不过在Elasticsearch7.0以后的版本,已经废弃文档类型了。不过我们还是要知道这个概念的。在Elasticsearch老的版本中文档类型，代表一类文档的集合，index(索引)类似mysql的数据库、文档类型类似Mysql的表。既然新的版本文档类型没什么作用了，那么index（索引）就类似mysql的表的概念，ES没有数据库的概念了。 1.3 document ES是面向文档的数据库，文档是ES存储的最基本的存储单元，文档蕾丝mysql表中的一行数据。其实在ES中，文档指的就是一条JSON数据。ES中文档使用JSON格式存储，因此存储上要比mysql灵活的很多，因为ES支持任意格式的json数据。 举个例子吧： { \"_index\" : \"order\", \"_type\" : \"_doc\", \"_id\" : \"1\", \"_version\" : 2, \"_seq_no\" : 1, \"_primary_term\" : 1, \"found\" : true, \"_source\" : { \"id\" : 10000, \"status\" : 0, \"total_price\" : 10000, \"create_time\" : \"2020-09-06 17:30:22\", \"user\" : { \"id\" : 10000, \"username\" : \"asong2020\", \"phone\" : \"888888888\", \"address\" : \"深圳人才区\" } } } 这个是kibana的一条数据。文档中的任何json字段都可以作为查询条件。并且文档的json格式没有严格限制，可以随意增加，减少字段，甚至每个文档的格式都不一样也可以。 **注意：**这里我特意加粗了，虽然文档格式是没有限制的，可以随便存储数据，但是，我们在实际开发中是不可以这么做的，下一篇具体实战当中，我会进行讲解。我们在实际项目开发中，一个索引只会存储格式相同的数据。 上面我们已经看到了一个文档数据，下面我们来了解一下什么是文档元数据，指的是插入JSON文档的时候，ES为这条数据，自动生成的系统字段。 我们常用的元数据如下： _index：代表当前json文档所属的文档名字 _type：代表当前json文档所属的类型。不过在es7.0以后废弃了type用法，但是元数据还是可以看到的 _id：文档唯一ID，如果我们没有为文档指定id，系统自动生成。 _source：代表我们插入进入json数据 _version：文档的版本号，每修改一次文档数据，字段就会加1，这个字段新版es也给取消了 _seq_no：文档的编号，替代老的 version字段 _primary_term：文档所在主分区，这个可以跟seq_no字段搭配实现乐观锁 1.4 Field 文档由多个json字段，这个字段跟mysql中的表的字段是类似的。ES中的字段也是有类型的，常用字段类型有： 数值类型(long、integer、short、byte、double、float) Date 日期类型 boolean布尔类型 Text 支持全文搜索 Keyword 不支持全文搜索，例如：phone这种数据，用一个整体进行匹配就ok了，也不要进行分词处理 Geo 这里主要用于地理信息检索、多边形区域的表达。 1.5 mapping Elasticsearch的mapping类似于mysql中的表结构体定义，每个索引都有一个映射的规则，我们可以通过定义索引的映射规则，提前定义好文档的json结构和字段类型，如果没有定义索引的映射规则，ElasticSearch会在写入数据的时候，根据我们写入的数据字段推测出对应的字段类型，相当于自动定义索引的映射规则。 注意：ES的自动映射是很方便的，但是实际业务中，对于关键字段类型，我们都是通常预先定义好，这样可以避免ES自动生成的字段类型不是你想要的类型。 ","date":"2020-09-07","objectID":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%B8%80/:7:1","tags":["elasticSearch"],"title":"go-ElasticSearch入门看这一篇就够了(一)","uri":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%B8%80/"},{"categories":["Go应用"],"content":"2. ES查询 在使用ES时，查询是我们经常使用的。所以我们来主要讲解一下查询。 来看一下查询的基本语法结构： GET /{索引名}/_search { \"from\" : 0, // 搜索结果的开始位置 \"size\" : 10, // 分页大小，也就是一次返回多少数据 \"_source\" :[ ...需要返回的字段数组... ], \"query\" : { ...query子句... }, \"aggs\" : { ..aggs子句.. }, \"sort\" : { ..sort子句.. } } 让我们来依次解释一下每部分： 先看一下URI部分，{索引名}是我们要搜索的索引，可以放置多个索引，使用逗号进行分隔，比如： GET /_order_demo1,_order_demo2/_search GET /_order*/_search # 按前缀匹配索引名 查询结果： { \"took\" : 0, \"timed_out\" : false, \"_shards\" : { \"total\" : 1, \"successful\" : 1, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : { \"value\" : 1, \"relation\" : \"eq\" }, \"max_score\" : 1.0, \"hits\" : [ { \"_index\" : \"order\", \"_type\" : \"_doc\", \"_id\" : \"1\", \"_score\" : 1.0, \"_source\" : { \"id\" : 10000, \"status\" : 0, \"total_price\" : 10000, \"create_time\" : \"2020-09-06 17:30:22\", \"user\" : { \"id\" : 10000, \"username\" : \"asong2020\", \"phone\" : \"888888888\", \"address\" : \"深圳人才区\" } } } ] } } 接下来我们一起看一看body中的查询条件： ES查询分页：通过from和size参数设置，相当于MYSQL的limit和offset结构 query：主要编写类似SQL的Where语句，支持布尔查询（and/or）、IN、全文搜索、模糊匹配、范围查询（大于小于） aggs：主要用来编写统计分析语句，类似SQL的group by语句 sort：用来设置排序条件，类似SQL的order by语句 source：用于设置查询结果返回什么字段，相当于select语句后面指定字段 2.1 几种查询语法 匹配单个字段 通过match实现全文索引，全文搜索是ES的关键特性之一，我们平时使用搜索一些文本、字符串是否包含指定的关键词，但是如果两篇文章，都包含我们的关键词，具体那篇文章内容的相关度更高？ 这个SQL的like语句是做不到的，更别说like语句的性能问题了。 ES通过分词处理、相关度计算可以解决这个问题，ES内置了一些相关度算法，例如：TF/IDF算法，大体上思想就是，如果一个关键词在一篇文章出现的频率高，并且在其他文章中出现的少，那说明这个关键词与这篇文章的相关度很高。分词就是为了提取搜索关键词，理解搜索的意图。就好像我们平常使用谷歌搜索的时候，输入的内容可能很长，但不是每个字都对搜索有帮助，所以可以通过粉刺算法，我们输入的搜索关键词，会进一步分解成多个关键词。这里具体的分词算法我就不详细讲解了，有需要的去官方文档看一看更详细的介绍吧。 我们先来看一看匹配单个字段的使用方法： GET /{索引名}/_search { \"query\": { \"match\": { \"{FIELD}\": \"{TEXT}\" } } } 说明： {FIELD} 就是我们需要匹配的字段名 {TEXT} 就是我们需要匹配的内容 精确匹配单个字段 当我们需要根据手机号、用户名来搜索一个用户信息时，这就需要使用精确匹配了。可以使用term实现精确匹配语法： GET /{索引名}/_search { \"query\": { \"term\": { \"{FIELD}\": \"{VALUE}\" } } } 说明： {FIELD} - 就是我们需要匹配的字段名 {VALUE} - 就是我们需要匹配的内容，除了TEXT类型字段以外的任意类型。 多值匹配 多值匹配，也就是想mysql中的in语句一样，一个字段包含给定数组中的任意一个值匹配。上文使用term实现单值精确匹配，同理terms就可以实现多值匹配。 GET /{索引名}/_search { \"query\": { \"terms\": { \"{FIELD}\": [ \"{VALUE1}\", \"{VALUE2}\" ] } } } 说明： {FIELD} - 就是我们需要匹配的字段名 {VALUE1}, {VALUE2} …. {VALUE N} - 就是我们需要匹配的内容，除了TEXT类型字段以外的任意类型。 范围查询 我们想通过范围来确实查询数据，这时应该怎么做呢？不要慌，当然有办法了，使用range就可以实现范围查询，相当于SQL语句的\u003e，\u003e=，\u003c，\u003c=表达式 GET /{索引名}/_search { \"query\": { \"range\": { \"{FIELD}\": { \"gte\": 100, \"lte\": 200 } } } } 说明： {FIELD} - 字段名 gte范围参数 - 等价于\u003e= lte范围参数 - 等价于 \u003c= 范围参数可以只写一个，例如：仅保留 “gte”: 100， 则代表 FIELD字段 \u003e= 100 范围参数有如下： gt - 大于 （ \u003e ） gte - 大于且等于 （ \u003e= ） lt - 小于 （ \u003c ） lte - 小于且等于 （ \u003c= ） bool组合查询 前面的查询都是设置单个字段的查询条件，实际项目中这么应用是很少的，基本都是多个字段的查询条件，所以接下来我们就来一起学习一下组合多个字段的查询条件。 我们先来看一下bool查询的基本语法结构： GET /{索引名}/_search { \"query\": { \"bool\": { // bool查询 \"must\": [], // must条件，类似SQL中的and, 代表必须匹配条件 \"must_not\": [], // must_not条件，跟must相反，必须不匹配条件 \"should\": [] // should条件，类似SQL中or, 代表匹配其中一个条件 } } } 接下来分析一下每个条件： must条件：类似SQL的and，代表必须匹配的条件。 must_not条件：跟must作用刚好相反，相当于sql语句中的 != should条件：类似SQL中的 or， 只要匹配其中一个条件即可 2.2 排序 假设我们现在要查询订单列表，那么返回符合条件的列表肯定不会是无序的，一般都是按照时间进行排序的，所以我们就要使用到了排序语句。ES的默认排序是根据相关性分数排序，如果我们想根据查询结果中的指定字段排序，需要使用sort Processors处理。 GET /{索引名}/_search { \"query\": { ...查询条件.... }, \"sort\": [ { \"{Field1}\": { // 排序字段1 \"order\": \"desc\" // 排序方向，asc或者desc, 升序和降序 } }, { \"{Field2}\": { // 排序字段2 \"order\": \"desc\" // 排序方向，asc或者desc, 升序和降序 } } ....多个排序字段..... ] } sort子句支持多个字段排序，类似SQL的order by。 2.3 聚合查询 ES中的聚合查询，类似SQL的SUM/AVG/COUNT/GROUP BY分组查询，主要用于统计分析场景。 我们先来看一看什么是聚合查询： ES聚合查询类似SQL的GROUP by，一般统计分析主要分为两个步骤： 分组 组内聚合 对查询的数据首先进行一轮分组，可以设置分组条件，例如：新生入学，把所有的学生按专业分班，这个分班的过程就是对学生进行了分组。 组内聚合，就是对组内的数据进行统计，例如：计算总数、求平均值等等，接上面的例子，学生都按专业分班了，那么就可以统计每个班的学生总数， 这个统计每个班学生总数的计算，就是组内聚合计算。 知道了什么是聚合，下面我们就来看其中几个重要关键字： 桶：桶的就是一组数据的集合，对数据分组后，得到一组组的数据，就是一个个的桶。ES中桶聚合，指的就是先对数据进行分组。 指标：指标指的是对文档进行统计计算方式，又叫指标聚合。桶内聚合，说的就是先对数据进行分组（分桶），然后对每一个桶内的数据进行指标聚合。说白了就是，前面将数据经过一轮桶聚合，把数据分成一个个的桶之后，我们根据上面计算指标对桶内的数据进行统计。常用的指标有：SUM、COUNT、MAX等统计函数。 了解了真正的概念，我们就可以学习聚合查询的语法了： { \"aggregations\" : { \"\u003caggregation_name\u003e\" : { \"\u003caggregation_type\u003e\" : { \u003caggregation_body\u003e } [,\"aggregations\" : { [\u003csub_aggregation\u003e]+ } ]? // 嵌套聚合查询，支持多层嵌套 } [,\"\u003caggregation_name_2\u003e\" : { ... } ]* // 多个聚合查询，每个聚合查询取不同的名字 } } 说明： aggregations - 代表","date":"2020-09-07","objectID":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%B8%80/:7:2","tags":["elasticSearch"],"title":"go-ElasticSearch入门看这一篇就够了(一)","uri":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%B8%80/"},{"categories":["Go应用"],"content":"总结 好啦，这一篇到这里就结束了，一些基本概念以及基础的使用方法都介绍了一遍，因为ES知识点就是比较多的，这里只是介绍了一下入门级别的使用方法，适合新手，所以就没有讲更深入的东西，下一篇我将从代码入手，来讲解ES在代码中的使用，会比这一篇有意思很多，因为讲概念嘛，很枯燥的，下篇，我们敬请期待呦！！！ 结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。 我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。 **我是asong，一名普普通通的程序猿，让我一起慢慢变强吧。我自己建了一个golang交流群，有需要的小伙伴加我vx,我拉你入群。欢迎各位的关注，我们下期见~~~** 推荐往期文章： 面试官：go中for-range使用过吗？这几个问题你能解释一下原因吗 学会wire依赖注入、cron定时任务其实就这么简单！ 听说你还不会jwt和swagger-饭我都不吃了带着实践项目我就来了 掌握这些Go语言特性，你的水平将提高N个档次(二) go实现多人聊天室，在这里你想聊什么都可以的啦！！！ grpc实践-学会grpc就是这么简单 go标准库rpc实践 2020最新Gin框架中文文档 asong又捡起来了英语，用心翻译 基于gin的几种热加载方式 boss: 这小子还不会使用validator库进行数据校验，开了～～～ ","date":"2020-09-07","objectID":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%B8%80/:8:0","tags":["elasticSearch"],"title":"go-ElasticSearch入门看这一篇就够了(一)","uri":"https://asong2020.github.io/go-elastic%E5%85%A5%E9%97%A8%E4%B8%80/"},{"categories":["Go面试"],"content":"前言 读者A：不会吧，阿Sir，这周这么高产～～～ asong：当然啦，为了你们，一切都值得～～～ 读者B：净放臭屁屁，就你戏多～～～ asong：你凶人家，坏坏～～～ 哈哈哈，戏太足了奥。自导自演可还行。今日分享之前，先放松放松嘛，毕竟接下来的知识，还是需要我们思考的。今天给大家分享的是go中的range，这个我们在实际开发中，是经常使用，但是他有一个坑，使用不好，是要被开除的。但是，今天你恰好看了我这一篇文章，就避免了这个坑，开心嘛～～～。直接笑，别克制，我知道你嘴角已经上扬了。 废话结束，我们直接开始。 ","date":"2020-09-06","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80range%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/:1:0","tags":["range"],"title":"Go语言中for-range使用踩坑指南","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80range%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"},{"categories":["Go面试"],"content":"正文 1. 指针数据坑 range到底有什么坑呢，我们先来运行一个例子吧。 package main import ( \"fmt\" ) type user struct { name string age uint64 } func main() { u := []user{ {\"asong\",23}, {\"song\",19}, {\"asong2020\",18}, } n := make([]*user,0,len(u)) for _,v := range u{ n = append(n, \u0026v) } fmt.Println(n) for _,v := range n{ fmt.Println(v) } } 这个例子的目的是，通过u这个slice构造成新的slice。我们预期应该是显示uslice的内容，但是运行结果如下： [0xc0000a6040 0xc0000a6040 0xc0000a6040] \u0026{asong2020 18} \u0026{asong2020 18} \u0026{asong2020 18} 这里我们看到n这个slice打印出来的三个同样的数据，并且他们的内存地址相同。这是什么原因呢？先别着急，再来看这一段代码，我给他改正确他，对比之后我们再来分析，你们才会恍然大悟。 package main import ( \"fmt\" ) type user struct { name string age uint64 } func main() { u := []user{ {\"asong\",23}, {\"song\",19}, {\"asong2020\",18}, } n := make([]*user,0,len(u)) for _,v := range u{ o := v n = append(n, \u0026o) } fmt.Println(n) for _,v := range n{ fmt.Println(v) } } 细心的你们看到，我改动了哪一部分代码了嘛？对，没错，我就加了一句话，他就成功了，我在for range里面引入了一个中间变量，每次迭代都重新声明一个变量o，赋值后再将v的地址添加n切片中，这样成功解决了刚才的问题。 现在来解释一下原因：在for range中，变量v是用来保存迭代切片所得的值，因为v只被声明了一次，每次迭代的值都是赋值给v，该变量的内存地址始终未变，这样讲他的地址追加到新的切片中，该切片保存的都是同一个地址，这肯定无法达到预期效果的。这里还需要注意一点，变量v的地址也并不是指向原来切片u[2]的，因我在使用range迭代的时候，变量v的数据是切片的拷贝数据，所以直接copy了结构体数据。 上面的问题还有一种解决方法，直接引用数据的内存，这个方法比较好，不需要开辟新的内存空间，看代码： ......略 for k,_ := range u{ n = append(n, \u0026u[k]) } ......略 2. 迭代修改变量问题 还是刚才的例子，我们做一点改动，现在我们要对切片中保存的每个用户的年龄进行修改，因为我们都是永远18岁，嘎嘎嘎～～～。 package main import ( \"fmt\" ) type user struct { name string age uint64 } func main() { u := []user{ {\"asong\",23}, {\"song\",19}, {\"asong2020\",18}, } for _,v := range u{ if v.age != 18{ v.age = 20 } } fmt.Println(u) } 来看一下运行结果： [{asong 23} {song 19} {asong2020 18}] 哎呀，怎么回事。怎么没有更改呢。其实道理都是一样，还记得，我在上文说的一个知识点嘛。对，就是这个，想起来了吧。v变量是拷贝切片中的数据，修改拷贝数据怎么会对原切片有影响呢，还是这个问题，copy这个知识点很重要，一不注意，就会出现问题。知道问题了，我们现在来把这个问题解决吧。 package main import ( \"fmt\" ) type user struct { name string age uint64 } func main() { u := []user{ {\"asong\",23}, {\"song\",19}, {\"asong2020\",18}, } for k,v := range u{ if v.age != 18{ u[k].age = 18 } } fmt.Println(u) } 可以看到，我们直接对切片的值进行修改，这样就修改成功了。所以这里还是要注意一下的，防止以后出现bug。 3. 是否会造成死循环 来看一段代码： func main() { v := []int{1, 2, 3} for i := range v { v = append(v, i) } } 这一段代码会造成死循环吗？答案：当然不会，前面都说了range会对切片做拷贝，新增的数据并不在拷贝内容中，并不会发生死循环。这种题一般会在面试中问，可以留意下的。 ","date":"2020-09-06","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80range%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/:1:1","tags":["range"],"title":"Go语言中for-range使用踩坑指南","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80range%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"},{"categories":["Go面试"],"content":"你不知道的range用法 delete 没看错，删除，在range迭代时，可以删除map中的数据，第一次见到这么使用的，我刚听到确实不太相信，所以我就去查了一下官方文档，确实有这个写法： for key := range m { if key.expired() { delete(m, key) } } 看看官方的解释： The iteration order over maps is not specified and is not guaranteed to be the same from one iteration to the next. If map entries that have not yet been reached are removed during iteration, the corresponding iteration values will not be produced. If map entries are created during iteration, that entry may be produced during the iteration or may be skipped. The choice may vary for each entry created and from one iteration to the next. If the map is nil, the number of iterations is 0. 翻译： 未指定`map`的迭代顺序，并且不能保证每次迭代之间都相同。 如果在迭代过程中删除了尚未到达的映射条目，则不会生成相应的迭代值。 如果映射条目是在迭代过程中创建的，则该条目可能在迭代过程中产生或可以被跳过。 对于创建的每个条目以及从一个迭代到下一个迭代，选择可能有所不同。 如果映射为nil，则迭代次数为0。 看这个代码： func main() { d := map[string]string{ \"asong\": \"帅\", \"song\": \"太帅了\", } for k := range d{ if k == \"asong\"{ delete(d,k) } } fmt.Println(d) } # 运行结果 map[song:太帅了] 从运行结果我们可以看出，key为asong的这位帅哥被从帅哥map中删掉了，哇哦，可气呀。这个方法，相信很多小伙伴都不知道，今天教给你们了，以后可以用起来了。 add 上面是删除，那肯定会有新增呀，直接看代码吧。 func main() { d := map[string]string{ \"asong\": \"帅\", \"song\": \"太帅了\", } for k,v := range d{ d[v] = k fmt.Println(d) } } 这里我把打印放到了range里，你们思考一下，新增的元素，在遍历时能够遍历到呢。我们来验证一下。 func main() { var addTomap = func() { var t = map[string]string{ \"asong\": \"太帅\", \"song\": \"好帅\", \"asong1\": \"非常帅\", } for k := range t { t[\"song2020\"] = \"真帅\" fmt.Printf(\"%s%s \", k, t[k]) } } for i := 0; i \u003c 10; i++ { addTomap() fmt.Println() } } 运行结果： asong太帅 song好帅 asong1非常帅 song2020真帅 asong太帅 song好帅 asong1非常帅 asong太帅 song好帅 asong1非常帅 song2020真帅 asong1非常帅 song2020真帅 asong太帅 song好帅 asong太帅 song好帅 asong1非常帅 song2020真帅 asong太帅 song好帅 asong1非常帅 song2020真帅 asong太帅 song好帅 asong1非常帅 asong1非常帅 song2020真帅 asong太帅 song好帅 asong太帅 song好帅 asong1非常帅 song2020真帅 asong太帅 song好帅 asong1非常帅 song2020真帅 从运行结果，我们可以看出来，每一次的结果并不是确定的。这是为什么呢？这就来揭秘，map内部实现是一个链式hash表，为了保证无顺序，初始化时会随机一个遍历开始的位置，所以新增的元素被遍历到就变的不确定了，同样删除也是一个道理，但是删除元素后边就不会出现，所以一定不会被遍历到。 ","date":"2020-09-06","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80range%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/:1:2","tags":["range"],"title":"Go语言中for-range使用踩坑指南","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80range%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"},{"categories":["Go面试"],"content":"总结 怎么样，伙伴们，收获不小吧。一个小小的range就会引发这么多的问题，所以说写代码一定要实践，光靠想是没有用的，有些问题只有在实践中才会有所提高。希望今天的分享对你们有用，好啦，这一期就结束啦。我们下期见。打个预告：下期将介绍go-elastic的使用，有需要的小伙伴留意一下。 结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。 我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。 **我是asong，一名普普通通的程序猿，让我一起慢慢变强吧。欢迎各位的关注，我们下期见~~~** 推荐往期文章： 学会wire依赖注入、cron定时任务其实就这么简单！ 听说你还不会jwt和swagger-饭我都不吃了带着实践项目我就来了 掌握这些Go语言特性，你的水平将提高N个档次(二) go实现多人聊天室，在这里你想聊什么都可以的啦！！！ grpc实践-学会grpc就是这么简单 go标准库rpc实践 2020最新Gin框架中文文档 asong又捡起来了英语，用心翻译 基于gin的几种热加载方式 boss: 这小子还不会使用validator库进行数据校验，开了～～～ ","date":"2020-09-06","objectID":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80range%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/:2:0","tags":["range"],"title":"Go语言中for-range使用踩坑指南","uri":"https://asong2020.github.io/go%E8%AF%AD%E8%A8%80range%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"},{"categories":["Go应用"],"content":"前言 嗨，我小asong又回来了。托了两周没有更新，最近比较忙，再加上自己懒，所以嘛，嗯嗯，你们懂的。不过我今天的带来的分享，绝对干货，在实际项目中开发也是需要用到的，所以为了能够讲明白，我特意写了一个样例，仅供参考。本文会围绕样例进行展开学习，已上传github，可自行下载。好了，不说废话了，知道你们迫不及待了，我们直接开始吧！！！ ","date":"2020-09-05","objectID":"https://asong2020.github.io/wire_cron%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/:1:0","tags":["wire","cron"],"title":"wire依赖注入+cron定时任务 项目实战","uri":"https://asong2020.github.io/wire_cron%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"categories":["Go应用"],"content":"wire 依赖注入 在介绍wire之前，我们先来了解一下什么是依赖注入。使用过Spring的同学对这个应该不会陌生。其中控制反转（IOC）最常见的方式就叫做依赖注入。将依赖的类作为行参放入依赖中的类就成为依赖注入。这么说可能你们不太懂。用一句大白话来说，一个实例化的对象，本来我接受各种参数来构造一个对象，现在只接受一个参数，对对象的依赖是注入进来的，和它的构造方式解耦了。构造他这个控制操作也交给了第三方，即控制反转。举个例子：go中是没有类的概念的，以结构体的形式体现。假设我们现在船类，有个浆类，我们现在想要设置该船有12个浆，那我们可以写出如下代码： package main import ( \"fmt\" ) type ship struct { pulp *pulp } func NewShip(pulp *pulp) *ship{ return \u0026ship{ pulp: pulp, } } type pulp struct { count int } func Newpulp(count int) *pulp{ return \u0026pulp{ count: count, } } func main(){ p:= Newpulp(12) s := NewShip(p) fmt.Println(s.pulp.count) } 相信你们一眼就看出问题了，每当需求变动时，我们都要重新创建一个对象来指定船桨，这样的代码不易维护，我们变通一下。 package main import ( \"fmt\" ) type ship struct { pulp *pulp } func NewShip(pulp *pulp) *ship{ return \u0026ship{ pulp: pulp, } } type pulp struct { count int } func Newpulp() *pulp{ return \u0026pulp{ } } func (c *pulp)set(count int) { c.count = count } func (c *pulp)get() int { return c.count } func main(){ p:= Newpulp() s := NewShip(p) s.pulp.set(12) fmt.Println(s.pulp.get()) } 这个代码的好处就在于代码松耦合，易维护，还易测试。如果我们现在更换需求了，需要20个船桨，直接s.pulp.set(20)就可以了。 wire的使用 wire有两个基础概念，Provider（构造器）和Injector（注入器）。Provider实际上就是创建函数，大家意会一下。我们上面InitializeCron就是Injector。每个注入器实际上就是一个对象的创建和初始化函数。在这个函数中，我们只需要告诉wire要创建什么类型的对象，这个类型的依赖，wire工具会为我们生成一个函数完成对象的创建和初始化工作。 拉了这么长，就是为了引出wire，上面的代码虽然是实现了依赖注入，这是在代码量少，结构不复杂的情况下，我们自己来实现依赖是没有问题的，当结构之间的关系变得非常复杂的时候，这时候手动创建依赖，然后将他们组装起来就会变的异常繁琐，并且很容出错。所以wire的作用就来了。在使用之前我们先来安装一下wire。 $ go get github.com/google/wire/cmd/wire 执行该命令会在$GOPATH/bin中生成一个可执行程序wire，这个就是代码生成器。别忘了吧$GOPATH/bin加入系统环境变量$PATH中。 先根据上面的简单例子，我们先来看看wire怎么用。我们先创建一个wire文件，文件内容如下： //+build wireinject package main import ( \"github.com/google/wire\" ) type Ship struct { Pulp *Pulp } func NewShip(pulp *Pulp) *Ship { return \u0026Ship{ pulp: pulp, } } type Pulp struct { Count int } func NewPulp() *Pulp { return \u0026Pulp{ } } func (c *Pulp)set(count int) { c.count = count } func (c *Pulp)get() int { return c.count } func InitShip() *Ship { wire.Build( NewPulp, NewShip, ) return \u0026Ship{} } func main(){ } 其中InitShip这个函数的返回值就是我们需要创建的对象类型，wire只需要知道类型，返回什么不重要。在函数中我们调用了wire.Build()将创建ship所依赖的的类型构造器传进去。这样我们就编写好了，现在我们需要到控制台执行wire。 $ wire wire: asong.cloud/Golang_Dream/wire_cron_example/ship: wrote /Users/asong/go/src/asong.cloud/Golang_Dream/wire_cron_example/ship/wire_gen.go 我们看到生成了wire_gen.go这个文件： // Code generated by Wire. DO NOT EDIT. //go:generate wire //+build !wireinject package main // Injectors from mian.go: func InitShip() *Ship { pulp := NewPulp() ship := NewShip(pulp) return ship } // mian.go: type Ship struct { pulp *Pulp } func NewShip(pulp *Pulp) *Ship { return \u0026Ship{ pulp: pulp, } } type Pulp struct { count int } func NewPulp() *Pulp { return \u0026Pulp{} } func (c *Pulp) set(count int) { c.count = count } func (c *Pulp) get() int { return c.count } func main() { } 可以看出来，生成的这个文件根据刚才定义的生成了InitShip（）这个函数，依赖绑定关系也都实现了，我们直接调用这个函数，就可以了，省去了大量代码自己去实现依赖绑定关系。 **注意：**如果你是第一次使用wire，那么你一定会遇到一个问题，生成的代码和原来的代码会出现冲突，因为都定义相同的函数func InitShip() *Ship，所以这里需要在原文件中首行添加//+build wireinject，并且还要与包名有空行，这样就解决了冲突。 上面的例子还算是简单，下面我们来看一个比较多一点的例子，我们在日常web后台开发时，代码都是有分层的，比较熟悉的有dao、service、controller、model等等。其实dao、service、controller，是有调用先后顺序的。controller调用service层，service层调用dao层，这就形成了依赖关系，我们在实际开发中，通过分层依赖注入的方式，更加层次分明，且代码是易于维护的。所以，我写了一个样例，让我们来学习一下怎么使用。这个采用cron定时任务代替controller来代替controller，cron定时任务我会在后文进行讲解。 //+build wireinject package wire import ( \"github.com/google/wire\" \"asong.cloud/Golang_Dream/wire_cron_example/config\" \"asong.cloud/Golang_Dream/wire_cron_example/cron\" \"asong.cloud/Golang_Dream/wire_cron_example/cron/task\" \"asong.cloud/Golang_Dream/wire_cron_example/dao\" \"asong.cloud/Golang_Dream/wire_cron_example/service\" ) func InitializeCron(mysql *config.Mysql) *cron.Cron{ wire.Build( dao.NewClientDB, dao.NewUserDB, service.NewUserService, task.NewScanner, cron.NewCron, ) return \u0026cron.Cron{} } 我们来看看这段代码，dao.NewClientDB即创建一个*sql.DB对象，依赖于mysql的配置文件，dao.NewUserDB即创建一个*UserDB对象，他依赖于*sql.DB，service.NewUserService即创建一个UserService对象，依赖于*UserDB对象，task.NewScanner创建一个*Scanner对象，他依赖于*UserService对象，cron。NewCron创建","date":"2020-09-05","objectID":"https://asong2020.github.io/wire_cron%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/:1:1","tags":["wire","cron"],"title":"wire依赖注入+cron定时任务 项目实战","uri":"https://asong2020.github.io/wire_cron%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"categories":["Go应用"],"content":"cron 基础学习 我们在日常开发或运维中，经常遇到一些周期性执行的任务或需求，例如：每一段时间执行一个脚本，每个月执行一个操作。linux给我们提供了一个便捷的方式—— crontab定时任务；crontab就是一个自定义定时器，我们可以利用 crontab 命令在固定的间隔时间执行指定的系统指令或 shell script 脚本。而这个时间间隔的写法与我们平常用到的cron 表达式相似。作用都是通过利用字符或命令去设置定时周期性地执行一些操作. 知道了基本概念，我们就来介绍一下cron表达式。常用的cron规范格式有两种：一种是“标准”cron格式，由cron linux系统程序使用，还有一种是Quartz Scheduler使用cron格式。这两种的差别就在一个是支持seconds字段的，一个是不支持的，不过差距不是很大，我们接下来的讲解都带上seconds这个字段，没有影响的。 cron 表达式是一个字符串，该字符串由 6 个空格分为 7 个域，每一个域代表一个时间含义。 格式如下： [秒] [分] [时] [日] [月] [周] [年] [年]的部分通常是可以省略的，实际上由前六部分组成。 关于各部分的定义，我们以一个表格的形式呈现： 域 是否必填 值以及范围 通配符 秒 是 0-59 , - * / 分 是 0-59 , - * / 时 是 0-23 , - * / 日 是 1-31 , - * ? / L W 月 是 1-12 或 JAN-DEC , - * / 周 是 1-7 或 SUN-SAT , - * ? / L # 年 否 1970-2099 , - * / 看这个值的范围，还是很好理解的，最难理解的是通配符，我们着重来讲一下通配符。 , 这里指的是在两个以上的时间点中都执行，如果我们在 “分” 这个域中定义为 5,10,15 ，则表示分别在第5分，第10分 第15分执行该定时任务。 - 这个比较好理解就是指定在某个域的连续范围，如果我们在 “时” 这个域中定义 6-12，则表示在6到12点之间每小时都触发一次，用 , 表示 6,7,8,9,10,11,12 * 表示所有值，可解读为 “每”。 如果在“日”这个域中设置 *,表示每一天都会触发。 ? 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如:要在每月的8号触发一个操作，但不关心是周几，我们可以这么设置 0 0 0 8 * ? / 在某个域上周期性触发，该符号将其所在域中的表达式分为两个部分，其中第一部分是起始值，除了秒以外都会降低一个单位，比如 在 “秒” 上定义 5/10 表示从 第 5 秒开始 每 10 秒执行一次，而在 “分” 上则表示从 第 5 秒开始 每 10 分钟执行一次。 L 表示英文中的LAST 的意思，只能在 “日”和“周”中使用。在“日”中设置，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年), 在“周”上表示周六，相当于”7”或”SAT”。如果在”L”前加上数字，则表示该数据的最后一个。例如在“周”上设置”7L”这样的格式,则表示“本月最后一个周六” W 表示离指定日期的最近那个工作日(周一至周五)触发，只能在 “日” 中使用且只能用在具体的数字之后。若在“日”上置”15W”，表示离每月15号最近的那个工作日触发。假如15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。如果是 “1W” 就只能往本月的下一个最近的工作日推不能跨月往上一个月推。 # 表示每月的第几个周几，只能作用于 “周” 上。例如 ”2#3” 表示在每月的第三个周二。 学习了通配符，下面我们来看几个例子： 每天10点执行一次：0 0 10 * * * 每隔10分钟执行一次：0 */10 * * * 每月1号凌晨3点执行一次：0 0 3 1 * ? 每月最后一天23点30分执行一次：0 30 23 L * ? 每周周六凌晨3点实行一次：0 0 3 ? * L 在30分、50分执行一次：0 30，50 * * * ? go中使用cron 前面我们学习了基础，现在我们想要在go项目中使用定时任务，我们该怎么做呢？github上有一个星星比较高的一个cron库，我们可以使用robfig/cron这个库开发我们的定时任务。 学习之前，我们先来安装一下cron $ go get -u github.com/robfig/cron/v3 这是目前比较稳定的版本，现在这个版本是采用标准规范的，默认是不带seconds，如果想要带上字段，我们需要创建cron对象是去指定。一会展示。我们先来看一个简单的使用： package main import ( \"fmt\" \"time\" \"github.com/robfig/cron/v3\" ) func main() { c := cron.New() c.AddFunc(\"@every 1s\", func() { fmt.Println(\"task start in 1 seconds\") }) c.Start() select{} } 这里我们使用cron.New创建一个cron对象，用于管理定时任务。调用cron对象的AddFunc()方法向管理器中添加定时任务。AddFunc()接受两个参数，参数 1 以字符串形式指定触发时间规则，参数 2 是一个无参的函数，每次触发时调用。@every 1s表示每秒触发一次，@every后加一个时间间隔，表示每隔多长时间触发一次。例如@every 1h表示每小时触发一次，@every 1m2s表示每隔 1 分 2 秒触发一次。time.ParseDuration()支持的格式都可以用在这里。调用c.Start()启动定时循环。 注意一点，因为c.Start()启动一个新的 goroutine 做循环检测，我们在代码最后加了一行select{}防止主 goroutine 退出。 上面我们定义时间时，使用的是cron预定义的时间规则，那我们就学习一下他都有哪些预定义的一些时间规则： @yearly：也可以写作@annually，表示每年第一天的 0 点。等价于0 0 1 1 *； @monthly：表示每月第一天的 0 点。等价于0 0 1 * *； @weekly：表示每周第一天的 0 点，注意第一天为周日，即周六结束，周日开始的那个 0 点。等价于0 0 * * 0； @daily：也可以写作@midnight，表示每天 0 点。等价于0 0 * * *； @hourly：表示每小时的开始。等价于0 * * * *。 cron也是支持固定时间间隔的，格式如下： @every \u003cduration\u003e 含义为每隔duration触发一次。\u003cduration\u003e会调用time.ParseDuration()函数解析，所以ParseDuration支持的格式都可以。 项目使用 因为我自己写的项目是通过实现job接口来加入定时任务，所以下面我们再来介绍一下Job接口的使用，除了直接将无参函数作为回调外，cron还支持job接口： type Job interface{ Run() } 我们需要实现这个接口，这里我就以我写的例子来做演示吧，我现在这个定时任务是周期扫DB表中的数据，实现任务如下： package task import ( \"fmt\" \"asong.cloud/Golang_Dream/wire_cron_example/service\" ) type Scanner struct { lastID uint64 user *service.UserService } const ( ScannerSize = 10 ) func NewScanner(user *service.UserService) *Scanner{ return \u0026Scanner{ user: user, } } func (s *Scanner)Run() { err := s.scannerDB() if err != nil{ fmt.Errorf(err.Error()) } } func (s *Scanner)scannerDB() error{ s.reset() flag := false for { users,err:=s.user.MGet(s.lastID,ScannerSize) if err != nil{ return err } if len(users) \u003c ScannerSize{ flag = true } s.lastID = users[len(users) - 1].ID for k,v := range users{ fmt.Println(k,v) } if flag{ return nil } } } func (s *Scanner)reset() { s.lastID = 0 } 上面是实现Run方法的部分，之后我们还需要调用cron对象的AddJob方法将Scanner对象添加到定时管理器中。 package cron import ( \"github.com/robfig/cron/v3\" \"asong.cloud/Golang_Dream/wire_cron_example/cron/task\" ) type Cron struct { Scanner *task.Scanner Schedule *cron.Cron } func NewCron","date":"2020-09-05","objectID":"https://asong2020.github.io/wire_cron%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/:1:2","tags":["wire","cron"],"title":"wire依赖注入+cron定时任务 项目实战","uri":"https://asong2020.github.io/wire_cron%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"categories":["Go应用"],"content":"总结 今天的文章就到这里了，这一篇总结的并不全，只是达到入门的一个效果，想要继续深入，还需要各位小伙伴自行看文档学习呦。学会看官方文档，才能进步更多的呦。就比如时间规范这里，如果不看文档，我就不会知道现在使用的时间规范是什么的，所以还是要养成看文档的好习惯。打个预告，下一期是go-elastic的教程，有需要的小伙伴可以关注一下。 结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。 我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。 **我是asong，一名普普通通的程序猿，让我一起慢慢变强吧。欢迎各位的关注，我们下期见~~~** 推荐往期文章： 听说你还不会jwt和swagger-饭我都不吃了带着实践项目我就来了 掌握这些Go语言特性，你的水平将提高N个档次(二) go实现多人聊天室，在这里你想聊什么都可以的啦！！！ grpc实践-学会grpc就是这么简单 go标准库rpc实践 2020最新Gin框架中文文档 asong又捡起来了英语，用心翻译 基于gin的几种热加载方式 boss: 这小子还不会使用validator库进行数据校验，开了～～～ ","date":"2020-09-05","objectID":"https://asong2020.github.io/wire_cron%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/:2:0","tags":["wire","cron"],"title":"wire依赖注入+cron定时任务 项目实战","uri":"https://asong2020.github.io/wire_cron%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"categories":null,"content":"博主介绍 asong是一名后端程序员，目前就职于一家电商公司，专注于Golang技术，定期分享Go语言、MySQL、Redis、Elasticsearch、计算机基础、微服务架构设计、面试等知识。这里不仅有技术，还有故事！ 公众号 ","date":"0001-01-01","objectID":"https://asong2020.github.io/about/:0:0","tags":null,"title":"关于","uri":"https://asong2020.github.io/about/"}]