<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>详解defer实现机制(附上三道面试题，我不信你们都能做对) - Golang梦工厂</title><meta name="Description" content="asong的成长记录小屋"><meta property="og:title" content="详解defer实现机制(附上三道面试题，我不信你们都能做对)" />
<meta property="og:description" content="前言 嗨，大家好，我是asong，鸽了好久，其实元旦就想写一下这篇文章，但是因为喝酒喝断片了，养了三天才缓过来，就推迟到这个周末了，不过多追溯" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" />
<meta property="og:image" content="https://asong2020.github.io/logo.png"/>
<meta property="article:published_time" content="2021-01-10T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-01-10T00:00:00+00:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://asong2020.github.io/logo.png"/>

<meta name="twitter:title" content="详解defer实现机制(附上三道面试题，我不信你们都能做对)"/>
<meta name="twitter:description" content="前言 嗨，大家好，我是asong，鸽了好久，其实元旦就想写一下这篇文章，但是因为喝酒喝断片了，养了三天才缓过来，就推迟到这个周末了，不过多追溯"/>
<meta name="application-name" content="LoveIt">
<meta name="apple-mobile-web-app-title" content="LoveIt"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" /><link rel="prev" href="https://asong2020.github.io/%E7%90%86%E8%A7%A3interface/" /><link rel="next" href="https://asong2020.github.io/panic%E5%92%8Crecover/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "详解defer实现机制(附上三道面试题，我不信你们都能做对)",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/asong2020.github.io\/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\/"
        },"image": ["https:\/\/asong2020.github.io\/images\/Apple-Devices-Preview.png"],"genre": "posts","keywords": "defer","wordcount":  6907 ,
        "url": "https:\/\/asong2020.github.io\/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\/","datePublished": "2021-01-10T00:00:00+00:00","dateModified": "2021-01-10T00:00:00+00:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "xxxx","logo": "https:\/\/asong2020.github.io\/images\/avatar.png"},"author": {
                "@type": "Person",
                "name": "asong"
            },"description": ""
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Golang梦工厂"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="https://song-oss.oss-cn-beijing.aliyuncs.com/wx/blog_head.jpeg"
        data-srcset="https://song-oss.oss-cn-beijing.aliyuncs.com/wx/blog_head.jpeg, https://song-oss.oss-cn-beijing.aliyuncs.com/wx/blog_head.jpeg 1.5x, https://song-oss.oss-cn-beijing.aliyuncs.com/wx/blog_head.jpeg 2x"
        data-sizes="auto"
        alt="https://song-oss.oss-cn-beijing.aliyuncs.com/wx/blog_head.jpeg"
        title="https://song-oss.oss-cn-beijing.aliyuncs.com/wx/blog_head.jpeg" /><span id="id-1" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/about/"> 关于 </a><a class="menu-item" href="https://github.com/asong2020" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><a class="menu-item" href="/friend/" title="友链"> 友链 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Golang梦工厂"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="https://song-oss.oss-cn-beijing.aliyuncs.com/wx/blog_head.jpeg"
        data-srcset="https://song-oss.oss-cn-beijing.aliyuncs.com/wx/blog_head.jpeg, https://song-oss.oss-cn-beijing.aliyuncs.com/wx/blog_head.jpeg 1.5x, https://song-oss.oss-cn-beijing.aliyuncs.com/wx/blog_head.jpeg 2x"
        data-sizes="auto"
        alt="https://song-oss.oss-cn-beijing.aliyuncs.com/wx/blog_head.jpeg"
        title="https://song-oss.oss-cn-beijing.aliyuncs.com/wx/blog_head.jpeg" /><span id="id-2" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/about/" title="">关于</a><a class="menu-item" href="https://github.com/asong2020" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a class="menu-item" href="/friend/" title="友链">友链</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">详解defer实现机制(附上三道面试题，我不信你们都能做对)</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://github.com/asong2020" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw"></i>asong</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/go%E6%BA%90%E7%A0%81/"><i class="far fa-folder fa-fw"></i>Go源码</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-01-10">2021-01-10</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 6907 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 14 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#前言">前言</a></li>
    <li><a href="#基本使用">基本使用</a></li>
    <li><a href="#defer的注意事项和细节"><code>defer</code>的注意事项和细节</a>
      <ul>
        <li><a href="#defer调用顺序"><code>defer</code>调用顺序</a></li>
        <li><a href="#defer拷贝"><code>defer</code>拷贝</a></li>
      </ul>
    </li>
    <li><a href="#defer与return的返回时机"><code>defer</code>与<code>return</code>的返回时机</a></li>
    <li><a href="#解密defer源码">解密<code>defer</code>源码</a>
      <ul>
        <li><a href="#deferproc函数"><code>deferproc</code>函数</a></li>
        <li><a href="#deferreturn函数"><code>deferreturn</code>函数</a></li>
        <li><a href="#总结">总结</a></li>
      </ul>
    </li>
    <li><a href="#小试牛刀">小试牛刀</a>
      <ul>
        <li><a href="#问题1">问题1</a></li>
        <li><a href="#问题2">问题2</a></li>
        <li><a href="#问题3">问题3</a></li>
      </ul>
    </li>
    <li><a href="#总结-1">总结</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="前言">前言</h2>
<blockquote>
<p>嗨，大家好，我是asong，鸽了好久，其实元旦就想写一下这篇文章，但是因为喝酒喝断片了，养了三天才缓过来，就推迟到这个周末了，不过多追溯了，有点丢人。今天与大家来聊一聊<code>go</code>中的关键字<code>defer</code>，目前很多编程语言中都有<code>defer</code>关键字，而<code>go</code>语言的<code>defer</code>用于资源的释放，会在函数返回之前进行调用，它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源。下面我们就深入<code>Go</code>语言源码介绍<code>defer</code>关键字的实现原理。
文末尾给你们留了三道题，检测一下学习成果吧～</p>
</blockquote>
<h2 id="基本使用">基本使用</h2>
<p>我们首先来看一看<code>defer</code>关键字是怎么使用的，一个经典的场景就是我们在使用事务时，发生错误需要回滚，这时我们就可以用使用defer来保证程序退出时保证事务回滚，示例代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 代码摘自之前写的 Leaf-segment数据库获取ID方案：https://github.com/asong2020/go-algorithm/blob/master/leaf/dao/leaf_dao.go
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">LeafDao</span><span class="p">)</span> <span class="nf">NextSegment</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">bizTag</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">model</span><span class="p">.</span><span class="nx">Leaf</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 开启事务
</span><span class="c1"></span>	<span class="nx">tx</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">sql</span><span class="p">.</span><span class="nf">Begin</span><span class="p">()</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">l</span><span class="p">.</span><span class="nf">rollback</span><span class="p">(</span><span class="nx">tx</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">checkError</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">err</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nf">UpdateMaxID</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">bizTag</span><span class="p">,</span> <span class="nx">tx</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">checkError</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">leaf</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">bizTag</span><span class="p">,</span> <span class="nx">tx</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">checkError</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="c1">// 提交事务
</span><span class="c1"></span>	<span class="nx">err</span> <span class="p">=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Commit</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">checkError</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">leaf</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面只是一个简单的应用，<code>defer</code>还有一些特性，如果你不知道，使用起来可能会踩到一些坑，尤其是跟带命名的返回参数一起使用时。下面我们我先来带大家踩踩坑。</p>
<h2 id="defer的注意事项和细节"><code>defer</code>的注意事项和细节</h2>
<h3 id="defer调用顺序"><code>defer</code>调用顺序</h3>
<p>我们先来看一道题，你能说他的答案吗？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;reciprocal&#34;</span><span class="p">)</span>

    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>答案：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">reciprocal</span>
<span class="mi">9</span>
<span class="mi">8</span>
<span class="mi">7</span>
<span class="mi">6</span>
<span class="mi">5</span>
<span class="mi">4</span>
<span class="mi">3</span>
<span class="mi">2</span>
<span class="mi">1</span>
<span class="mi">0</span>
</code></pre></td></tr></table>
</div>
</div><p>看到答案，你是不是产生了疑问？这就对了，我最开始学<code>golang</code>时也有这个疑问，这个跟栈一样，即&quot;先进后出&quot;特性，越后面的defer表达式越先被调用。所以这里大家关闭依赖资源时一定要注意<code>defer</code>调用顺序。</p>
<h3 id="defer拷贝"><code>defer</code>拷贝</h3>
<p>我们先来看这样一段代码，你能说出<code>defer</code>中<code>num1</code>和<code>num2</code>的值是多少吗？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">Sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Sum</span><span class="p">(</span><span class="nx">num1</span><span class="p">,</span> <span class="nx">num2</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;num1:&#34;</span><span class="p">,</span> <span class="nx">num1</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;num2:&#34;</span><span class="p">,</span> <span class="nx">num2</span><span class="p">)</span>
	<span class="nx">num1</span><span class="o">++</span>
	<span class="nx">num2</span><span class="o">++</span>
	<span class="k">return</span> <span class="nx">num1</span> <span class="o">+</span> <span class="nx">num2</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>聪明的你一定会说：&ldquo;这也太简单了，答案就是num1等于2，num2等于3&rdquo;。很遗憾的告诉你，错了，正确的答案是<code>num1</code>为<code>1</code>,<code>num2</code>为2，这两个变量并不受<code>num1++、num2++</code>的影响，<strong>因为<code>defer</code>将语句放入到栈中时，也会将相关的值拷贝同时入栈。</strong></p>
<h2 id="defer与return的返回时机"><code>defer</code>与<code>return</code>的返回时机</h2>
<p>这里我先说结论，总结一下就是，函数的整个返回过程应该是：</p>
<ol>
<li><code>return</code> 对返回变量赋值，如果是匿名返回值就先声明再赋值；</li>
<li>执行 <code>defer</code> 函数；</li>
<li><code>return</code> 携带返回值返回。</li>
</ol>
<p>下面我们来看两道题，你知道他们的返回值是多少吗？</p>
<ul>
<li>匿名返回值函数</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 匿名函数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Anonymous</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">i</span> <span class="kt">int</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">i</span><span class="o">++</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;defer2 value is &#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
	<span class="p">}()</span>

	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">i</span><span class="o">++</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;defer1 in value is &#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
	<span class="p">}()</span>

	<span class="k">return</span> <span class="nx">i</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>命名返回值的函数</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">HasName</span><span class="p">()</span> <span class="p">(</span><span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">j</span><span class="o">++</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;defer2 in value&#34;</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span>
	<span class="p">}()</span>

	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">j</span><span class="o">++</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;defer1 in value&#34;</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span>
	<span class="p">}()</span>

	<span class="k">return</span> <span class="nx">j</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>先来公布一下答案吧：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="mf">1.</span> <span class="nf">Anonymous</span><span class="p">()</span><span class="nx">的返回值为0</span>
<span class="mf">2.</span> <span class="nf">HasName</span><span class="p">()</span><span class="nx">的返回值为2</span>
</code></pre></td></tr></table>
</div>
</div><p>从这我们可以看出命名返回值的函数的返回值被 <code>defer</code> 修改了。这里想必大家跟我一样，都很疑惑，带着疑惑我查阅了一下<code>go</code>官方文档，文档指出，<code>defer</code>的执行顺序有以下三个规则：</p>
<ol>
<li>
<p>A deferred function’s arguments are evaluated when the defer statement is evaluated.</p>
</li>
<li>
<p>Deferred function calls are executed in Last In First Out order after the surrounding function returns.</p>
</li>
<li>
<p>Deferred functions may read and assign to the returning function’s named return values.</p>
</li>
</ol>
<p>规则3就可以印证为什么命名返回值的函数的返回值被更改了，其实在函数最终返回前，<code>defer</code> 函数就已经执行了，在命名返回值的函数 中，由于返回值已经被提前声明，所以 <code>defer</code> 函数能够在 <code>return</code> 语句对返回值赋值之后，继续对返回值进行操作，操作的是同一个变量，而匿名返回值函数中return先返回，已经进行了一次值拷贝r=i，<code>defer</code>函数中再次对变量<code>i</code>的操作并不会影响返回值。</p>
<p>这里可能有些小伙伴还不是很懂，我在讲一下<code>return</code>返回步骤，相信你们会豁然开朗。</p>
<ul>
<li>函数在返回时，首先函数返回时会自动创建一个返回变量假设为ret(如果是命名返回值的函数则不会创建)，函数返回时要将变量<code>i</code>赋值给ret，即有ret = i。</li>
<li>然后检查函数中是否有defer存在，若有则执行defer中部分。</li>
<li>最后返回ret</li>
</ul>
<p>现在你们应该知道上面是什么原因了吧～。</p>
<h2 id="解密defer源码">解密<code>defer</code>源码</h2>
<p>写在开头：go版本1.15.3</p>
<p>我们先来写一段代码，查看一下汇编代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;asong 真帅&#34;</span><span class="p">)</span>
	<span class="p">}()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>执行如下指令：<code>go tool compile -N -l -S main.go</code>，截取部分汇编指令如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://song-oss.oss-cn-beijing.aliyuncs.com/golang_dream/article/static/defer.png"
        data-srcset="https://song-oss.oss-cn-beijing.aliyuncs.com/golang_dream/article/static/defer.png, https://song-oss.oss-cn-beijing.aliyuncs.com/golang_dream/article/static/defer.png 1.5x, https://song-oss.oss-cn-beijing.aliyuncs.com/golang_dream/article/static/defer.png 2x"
        data-sizes="auto"
        alt="https://song-oss.oss-cn-beijing.aliyuncs.com/golang_dream/article/static/defer.png"
        title="https://song-oss.oss-cn-beijing.aliyuncs.com/golang_dream/article/static/defer.png" /></p>
<p>我们可以看出来，从执行流程来看首先会调用<code>deferproc</code>来创建<code>defer</code>，然后在函数返回时插入了指令<code>CALL runtime.deferreturn</code>。知道了<code>defer</code>在流程中是通过这两个方法是调用的，接下来我们来看一看<code>defer</code>的结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// go/src/runtime/runtime2.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">_defer</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">siz</span>     <span class="kt">int32</span> <span class="c1">// includes both arguments and results
</span><span class="c1"></span>	<span class="nx">started</span> <span class="kt">bool</span>
	<span class="nx">heap</span>    <span class="kt">bool</span>
	<span class="c1">// openDefer indicates that this _defer is for a frame with open-coded
</span><span class="c1"></span>	<span class="c1">// defers. We have only one defer record for the entire frame (which may
</span><span class="c1"></span>	<span class="c1">// currently have 0, 1, or more defers active).
</span><span class="c1"></span>	<span class="nx">openDefer</span> <span class="kt">bool</span>
	<span class="nx">sp</span>        <span class="kt">uintptr</span>  <span class="c1">// sp at time of defer
</span><span class="c1"></span>	<span class="nx">pc</span>        <span class="kt">uintptr</span>  <span class="c1">// pc at time of defer
</span><span class="c1"></span>	<span class="nx">fn</span>        <span class="o">*</span><span class="nx">funcval</span> <span class="c1">// can be nil for open-coded defers
</span><span class="c1"></span>	<span class="nx">_panic</span>    <span class="o">*</span><span class="nx">_panic</span>  <span class="c1">// panic that is running defer
</span><span class="c1"></span>	<span class="nx">link</span>      <span class="o">*</span><span class="nx">_defer</span>

	<span class="c1">// If openDefer is true, the fields below record values about the stack
</span><span class="c1"></span>	<span class="c1">// frame and associated function that has the open-coded defer(s). sp
</span><span class="c1"></span>	<span class="c1">// above will be the sp for the frame, and pc will be address of the
</span><span class="c1"></span>	<span class="c1">// deferreturn call in the function.
</span><span class="c1"></span>	<span class="nx">fd</span>   <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// funcdata for the function associated with the frame
</span><span class="c1"></span>	<span class="nx">varp</span> <span class="kt">uintptr</span>        <span class="c1">// value of varp for the stack frame
</span><span class="c1"></span>	<span class="c1">// framepc is the current pc associated with the stack frame. Together,
</span><span class="c1"></span>	<span class="c1">// with sp above (which is the sp associated with the stack frame),
</span><span class="c1"></span>	<span class="c1">// framepc/sp can be used as pc/sp pair to continue a stack trace via
</span><span class="c1"></span>	<span class="c1">// gentraceback().
</span><span class="c1"></span>	<span class="nx">framepc</span> <span class="kt">uintptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里简单介绍一下<code>runtime._defer</code>结构体中的几个字段：</p>
<ul>
<li><code>siz</code>代表的是参数和结果的内存大小</li>
<li><code>sp</code>和<code>pc</code>分别代表栈指针和调用方的程序计数器</li>
<li><code>fn</code>代表的是<code>defer</code>关键字中传入的函数</li>
<li><code>_panic</code>是触发延迟调用的结构体，可能为空</li>
<li><code>openDefer</code>表示的是当前<code>defer</code>是否已经开放编码优化(1.14版本新增)</li>
<li><code>link</code>所有<code>runtime._defer</code>结构体都通过该字段串联成链表</li>
</ul>
<p>先来我们也知道了<code>defer</code>关键字的数据结构了，下面我们就来重点分析一下<code>deferproc</code>和<code>deferreturn</code>函数是如何调用。</p>
<h3 id="deferproc函数"><code>deferproc</code>函数</h3>
<p><code>deferproc</code>函数也不长，我先贴出来代码；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// proc/panic.go
</span><span class="c1">// Create a new deferred function fn with siz bytes of arguments.
</span><span class="c1">// The compiler turns a defer statement into a call to this.
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">deferproc</span><span class="p">(</span><span class="nx">siz</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">fn</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// arguments of fn follow fn
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span> <span class="o">!=</span> <span class="nx">gp</span> <span class="p">{</span>
		<span class="c1">// go code on the system stack can&#39;t defer
</span><span class="c1"></span>		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;defer on system stack&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// the arguments of fn are in a perilous state. The stack map
</span><span class="c1"></span>	<span class="c1">// for deferproc does not describe them. So we can&#39;t let garbage
</span><span class="c1"></span>	<span class="c1">// collection or stack copying trigger until we&#39;ve copied them out
</span><span class="c1"></span>	<span class="c1">// to somewhere safe. The memmove below does that.
</span><span class="c1"></span>	<span class="c1">// Until the copy completes, we can only call nosplit routines.
</span><span class="c1"></span>	<span class="nx">sp</span> <span class="o">:=</span> <span class="nf">getcallersp</span><span class="p">()</span>
	<span class="nx">argp</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fn</span><span class="p">))</span> <span class="o">+</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span>
	<span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>

	<span class="nx">d</span> <span class="o">:=</span> <span class="nf">newdefer</span><span class="p">(</span><span class="nx">siz</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">_panic</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;deferproc: d.panic != nil after newdefer&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">link</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="p">=</span> <span class="nx">d</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">fn</span> <span class="p">=</span> <span class="nx">fn</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nx">callerpc</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="nx">sp</span>
	<span class="k">switch</span> <span class="nx">siz</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
		<span class="c1">// Do nothing.
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">:</span>
		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nf">deferArgs</span><span class="p">(</span><span class="nx">d</span><span class="p">))</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">argp</span><span class="p">))</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nf">memmove</span><span class="p">(</span><span class="nf">deferArgs</span><span class="p">(</span><span class="nx">d</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">argp</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">siz</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="c1">// deferproc returns 0 normally.
</span><span class="c1"></span>	<span class="c1">// a deferred func that stops a panic
</span><span class="c1"></span>	<span class="c1">// makes the deferproc return 1.
</span><span class="c1"></span>	<span class="c1">// the code the compiler generates always
</span><span class="c1"></span>	<span class="c1">// checks the return value and jumps to the
</span><span class="c1"></span>	<span class="c1">// end of the function if deferproc returns != 0.
</span><span class="c1"></span>	<span class="nf">return0</span><span class="p">()</span>
	<span class="c1">// No code can go here - the C return register has
</span><span class="c1"></span>	<span class="c1">// been set and must not be clobbered.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面介绍了<code>rumtiem._defer</code>结构想必这里的入参是什么意思就不用我介绍了吧。</p>
<p><code>deferproc</code>的函数流程很清晰，首先他会通过<code>newdefer</code>函数分配一个<code>_defer</code>结构对象，然后把需要延迟执行的函数以及该函数需要用到的参数、调用<code>deferproc</code>函数时的<code>rps</code>寄存器的值以及<code>deferproc</code>函数的返回地址保存在<code>_defer</code>结构体对象中，最后通过<code>return0()</code>设置<code>rax</code>寄存器的值为0隐性的给调用者返回一个0值。<code>deferproc</code>主要是靠<code>newdefer</code>来分配<code>_defer</code>结构体对象的，下面我们一起来看看<code>newdefer</code>实现，代码有点长：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// proc/panic.go
</span><span class="c1">// Allocate a Defer, usually using per-P pool.
</span><span class="c1">// Each defer must be released with freedefer.  The defer is not
</span><span class="c1">// added to any defer chain yet.
</span><span class="c1">//
</span><span class="c1">// This must not grow the stack because there may be a frame without
</span><span class="c1">// stack map information when this is called.
</span><span class="c1">//
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newdefer</span><span class="p">(</span><span class="nx">siz</span> <span class="kt">int32</span><span class="p">)</span> <span class="o">*</span><span class="nx">_defer</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">d</span> <span class="o">*</span><span class="nx">_defer</span>
	<span class="nx">sc</span> <span class="o">:=</span> <span class="nf">deferclass</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">siz</span><span class="p">))</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span><span class="c1">//获取当前goroutine的g结构体对象
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sc</span> <span class="p">&lt;</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">{}.</span><span class="nx">deferpool</span><span class="p">))</span> <span class="p">{</span>
		<span class="nx">pp</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="c1">//与当前工作线程绑定的p
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// Take the slow path on the system stack so
</span><span class="c1"></span>			<span class="c1">// we don&#39;t grow newdefer&#39;s stack.
</span><span class="c1"></span>			<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
				<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">deferlock</span><span class="p">)</span> 
         <span class="c1">//把新分配出来的d放入当前goroutine的_defer链表头
</span><span class="c1"></span>				<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">])</span> <span class="p">&lt;</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">d</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span>
					<span class="nx">sched</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">link</span>
					<span class="nx">d</span><span class="p">.</span><span class="nx">link</span> <span class="p">=</span> <span class="kc">nil</span>
					<span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">],</span> <span class="nx">d</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">deferlock</span><span class="p">)</span>
			<span class="p">})</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]);</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">d</span> <span class="p">=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">][</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">][</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="p">=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">][:</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">d</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="c1">//如果p的缓存中没有可用的_defer结构体对象则从堆上分配
</span><span class="c1"></span>         <span class="c1">// Allocate new defer+args.
</span><span class="c1"></span>         <span class="c1">//因为roundupsize以及mallocgc函数都不会处理扩栈，所以需要切换到系统栈执行
</span><span class="c1"></span>		<span class="c1">// Allocate new defer+args.
</span><span class="c1"></span>		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">total</span> <span class="o">:=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nf">totaldefersize</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">siz</span><span class="p">)))</span>
			<span class="nx">d</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">_defer</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">total</span><span class="p">,</span> <span class="nx">deferType</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
		<span class="p">})</span>
		<span class="k">if</span> <span class="nx">debugCachedWork</span> <span class="p">{</span>
			<span class="c1">// Duplicate the tail below so if there&#39;s a
</span><span class="c1"></span>			<span class="c1">// crash in checkPut we can tell if d was just
</span><span class="c1"></span>			<span class="c1">// allocated or came from the pool.
</span><span class="c1"></span>			<span class="nx">d</span><span class="p">.</span><span class="nx">siz</span> <span class="p">=</span> <span class="nx">siz</span>
       <span class="c1">//把新分配出来的d放入当前goroutine的_defer链表头
</span><span class="c1"></span>			<span class="nx">d</span><span class="p">.</span><span class="nx">link</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span>
			<span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="p">=</span> <span class="nx">d</span>
			<span class="k">return</span> <span class="nx">d</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">siz</span> <span class="p">=</span> <span class="nx">siz</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">heap</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="k">return</span> <span class="nx">d</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>newdefer</code>函数首先会尝试从当前工作线程绑定的<code>p</code>的<code>_defer</code>对象池和全局对象池中获取一个满足大小要求<code>(sizeof(_defer) + siz向上取整至16的倍数)</code>的<code> _defer</code> 结构体对象，如果没有能够满足要求的空闲 <code>_defer </code>对象则从堆上分一个，最后把分配到的对象链入当前 <code>goroutine </code>的<code> _defer</code> 链表的表头。</p>
<p>到此<code>deferproc</code>函数就分析完了，你们懂了吗? 没懂不要紧，我们再来总结一下这个过程：</p>
<ul>
<li>首先编译器把<code>defer</code>语句翻译成对应的<code>deferproc</code>函数的调用</li>
<li>然后<code>deferproc</code>函数通过<code>newdefer</code>函数分配一个<code>_defer</code>结构体对象并放入当前的<code>goroutine</code>的<code>_defer</code>链表的表头；</li>
<li>在 _defer 结构体对象中保存被延迟执行的函数 fn 的地址以及 fn 所需的参数</li>
<li>返回到调用 deferproc 的函数继续执行后面的代码。</li>
</ul>
<h3 id="deferreturn函数"><code>deferreturn</code>函数</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Run a deferred function if there is one.
</span><span class="c1">// The compiler inserts a call to this at the end of any
</span><span class="c1">// function which calls defer.
</span><span class="c1">// If there is a deferred function, this will call runtime·jmpdefer,
</span><span class="c1">// which will jump to the deferred function such that it appears
</span><span class="c1">// to have been called by the caller of deferreturn at the point
</span><span class="c1">// just before deferreturn was called. The effect is that deferreturn
</span><span class="c1">// is called again and again until there are no more deferred functions.
</span><span class="c1">//
</span><span class="c1">// Declared as nosplit, because the function should not be preempted once we start
</span><span class="c1">// modifying the caller&#39;s frame in order to reuse the frame to call the deferred
</span><span class="c1">// function.
</span><span class="c1">//
</span><span class="c1">// The single argument isn&#39;t actually used - it just has its address
</span><span class="c1">// taken so it can be matched against pending defers.
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">deferreturn</span><span class="p">(</span><span class="nx">arg0</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span> <span class="c1">//获取当前goroutine对应的g结构体对象
</span><span class="c1"></span>	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="c1">//获取当前goroutine对应的g结构体对象
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">d</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="c1">//没有需要执行的函数直接返回，deferreturn和deferproc是配对使用的
</span><span class="c1"></span>         <span class="c1">//为什么这里d可能为nil？因为deferreturn其实是一个递归调用，这个是递归结束条件之一
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">sp</span> <span class="o">:=</span> <span class="nf">getcallersp</span><span class="p">()</span> <span class="c1">//获取调用deferreturn时的栈顶位置
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">sp</span> <span class="o">!=</span> <span class="nx">sp</span> <span class="p">{</span> <span class="c1">// 递归结束条件
</span><span class="c1"></span>    <span class="c1">//如果保存在_defer对象中的sp值与调用deferretuen时的栈顶位置不一样，直接返回
</span><span class="c1"></span>        <span class="c1">//因为sp不一样表示d代表的是在其他函数中通过defer注册的延迟调用函数，比如:
</span><span class="c1"></span>        <span class="c1">//a()-&gt;b()-&gt;c()它们都通过defer注册了延迟函数，那么当c()执行完时只能执行在c中注册的函数
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">openDefer</span> <span class="p">{</span>
		<span class="nx">done</span> <span class="o">:=</span> <span class="nf">runOpenDeferFrame</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">done</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unfinished open-coded defers in deferreturn&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">link</span>
		<span class="nf">freedefer</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// Moving arguments around.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Everything called after this point must be recursively
</span><span class="c1"></span>	<span class="c1">// nosplit because the garbage collector won&#39;t know the form
</span><span class="c1"></span>	<span class="c1">// of the arguments until the jmpdefer can flip the PC over to
</span><span class="c1"></span>	<span class="c1">// fn.
</span><span class="c1"></span>      <span class="c1">//把保存在_defer对象中的fn函数需要用到的参数拷贝到栈上，准备调用fn
</span><span class="c1"></span>    <span class="c1">//注意fn的参数放在了调用调用者的栈帧中，而不是此函数的栈帧中
</span><span class="c1"></span>	<span class="k">switch</span> <span class="nx">d</span><span class="p">.</span><span class="nx">siz</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
		<span class="c1">// Do nothing.
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">:</span>
		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arg0</span><span class="p">))</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nf">deferArgs</span><span class="p">(</span><span class="nx">d</span><span class="p">))</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nf">memmove</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arg0</span><span class="p">),</span> <span class="nf">deferArgs</span><span class="p">(</span><span class="nx">d</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">siz</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="nx">fn</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">fn</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">fn</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">link</span> <span class="c1">// 使gp._defer指向下一个_defer结构体对象
</span><span class="c1"></span>    <span class="c1">//因为需要调用的函数d.fn已经保存在了fn变量中，它的参数也已经拷贝到了栈上，所以释放_defer结构体对象
</span><span class="c1"></span>	<span class="nf">freedefer</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
	<span class="c1">// If the defer function pointer is nil, force the seg fault to happen
</span><span class="c1"></span>	<span class="c1">// here rather than in jmpdefer. gentraceback() throws an error if it is
</span><span class="c1"></span>	<span class="c1">// called with a callback on an LR architecture and jmpdefer is on the
</span><span class="c1"></span>	<span class="c1">// stack, because the stack trace can be incorrect in that case - see
</span><span class="c1"></span>	<span class="c1">// issue #8153).
</span><span class="c1"></span>	<span class="nx">_</span> <span class="p">=</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">fn</span>
	<span class="nf">jmpdefer</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arg0</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>deferreturn</code>函数主要流程还是简单一些的，我们来分析一下：</p>
<ul>
<li>首先我们通过当前<code>goroutine</code>对应的<code>g</code>结构体对象的<code>_defer</code>链表判断是否有需要执行的<code>defered</code>函数，如果没有则返回；这里的没有是指g._defer== nil 或者<code>defered</code>函数不是在<code>deferteturn</code>的<code>caller</code>函数中注册的函数。</li>
<li>然后我们在从<code>_defer</code>对象中把<code>defered</code>函数需要的参数拷贝到栈上，并释放<code>_defer</code>的结构体对象。</li>
<li>最红调用<code>jmpderfer</code>函数调用<code>defered</code>函数，也就是<code>defer</code>关键字中传入的函数.</li>
</ul>
<p><code>jmpdefer</code>函数实现挺优雅的，我们一起来看看他是如何实现的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// runtime/asm_amd64.s : 581
</span><span class="c1">// func jmpdefer(fv *funcval, argp uintptr)
</span><span class="c1">// argp is a caller SP.
</span><span class="c1">// called from deferreturn.
</span><span class="c1">// 1. pop the caller
</span><span class="c1">// 2. sub 5 bytes from the callers return
</span><span class="c1">// 3. jmp to the argument
</span><span class="c1"></span><span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">jmpdefer</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">NOSPLIT</span><span class="p">,</span> <span class="err">$</span><span class="mi">0</span><span class="o">-</span><span class="mi">16</span>
	<span class="nx">MOVQ</span>	<span class="nx">fv</span><span class="o">+</span><span class="mi">0</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">DX</span>	<span class="c1">// fn
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nx">argp</span><span class="o">+</span><span class="mi">8</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">BX</span>	<span class="c1">// caller sp
</span><span class="c1"></span>	<span class="nx">LEAQ</span>	<span class="o">-</span><span class="mi">8</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">SP</span>	<span class="c1">// caller sp after CALL
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="o">-</span><span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">BP</span>	<span class="c1">// restore BP as if deferreturn returned (harmless if framepointers not in use)
</span><span class="c1"></span>	<span class="nx">SUBQ</span>	<span class="err">$</span><span class="mi">5</span><span class="p">,</span> <span class="p">(</span><span class="nx">SP</span><span class="p">)</span>	<span class="c1">// return to CALL again
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="mi">0</span><span class="p">(</span><span class="nx">DX</span><span class="p">),</span> <span class="nx">BX</span>
	<span class="nx">JMP</span>	<span class="nx">BX</span>	<span class="c1">// but first run the deferred function
</span></code></pre></td></tr></table>
</div>
</div><p>这里都是汇编，大家可能看不懂，没关系，我只是简单介绍一下这里，有兴趣的同学可以去查阅一下相关知识再来深入了解。</p>
<ul>
<li><code> MOVQ	fv+0(FP), DX</code>这条指令会把<code>jmpdefer</code>的第一个参数也就是结构体对象<code>fn</code>的地址存放入<code>DX</code>寄存器，之后的代码就可以通过寄存器访问到<code>fn</code>，<code>fn</code>就可以拿到<code>defer</code>关键字中传入的函数，对应上面的例子就是匿名函数<code>func(){}()</code>.</li>
<li><code>MOVQ	argp+8(FP), BX</code>这条指令就是把<code>jmpdefer</code>的第二个参数放入<code>BX</code>寄存器，该参数是一个指针，他指向<code>defer</code>关键字中传入的函数的第一个参数.</li>
<li><code>LEAQ	-8(BX), SP</code>这条指令的作用是让 <code>SP</code> 寄存器指向 <code>deferreturn</code> 函数的返回地址所在的栈内存单元.</li>
<li><code>MOVQ	-8(SP), BP</code>这条指令的作用是调整 BP 寄存器的值，此时<code>SP_8</code>的位置存放的是<code>defer</code>关键字当前所在的函数的<code>rbp</code>寄存器的值，所以这条指令在调整<code>rbp</code>寄存器的值使其指向当前所在函数的栈帧的适当位置.</li>
<li><code>SUBQ	$5, (SP)</code>这里的作用是完成<code>defer</code>函数的参数以及执行完函数后返回地址在栈上的构造.因为在执行这条指令时，rsp寄存器指向的是<code>deferreturn</code>函数的返回地址.</li>
<li><code>MOVQ	0(DX), BX</code>和<code>JMP	BX</code>放到一起说吧，目的是跳转到对应<code>defer</code>函数去执行，完成<code>defer</code>函数的调用.</li>
</ul>
<h3 id="总结">总结</h3>
<p>大概分析了一下<code>defer</code>的实现机制，但还是有点蒙圈，最后在总结一下这里：</p>
<ul>
<li>首先编译器会把<code>defer</code>语句翻译成对<code>deferproc</code>函数的调用。</li>
<li>然后<code>deferproc</code>函数会负责调用<code>newdefer</code>函数分配一个<code>_defer</code>结构体对象并放入当前的<code>goroutine</code>的<code>_defer</code>链表的表头；</li>
<li>然后编译起会在<code>defer</code>所在函数的结尾处插入对<code>deferreturn</code>的调用，<code>deferreturn</code>负责递归的调用某函数(defer语句所在函数)通过<code>defer</code>语句注册的函数。</li>
</ul>
<p>总体来说就是这三个步骤，go语言对<code>defer</code>的实现机制就是这样啦，你明白了吗？</p>
<h2 id="小试牛刀">小试牛刀</h2>
<p>上面我们也细致学习了一下<code>defer</code>，下面出几道题吧，看看你们真的学会了吗？</p>
<h3 id="问题1">问题1</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 测试1
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Test1</span><span class="p">()</span> <span class="p">(</span><span class="nx">r</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">i</span> <span class="p">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="p">}()</span>
	<span class="k">return</span> <span class="nx">i</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>返回结果是什么？</p>
<h3 id="问题2">问题2</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Test2</span><span class="p">()</span> <span class="p">(</span><span class="nx">r</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">(</span><span class="nx">r</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">r</span> <span class="p">=</span> <span class="nx">r</span> <span class="o">+</span> <span class="mi">2</span>
	<span class="p">}(</span><span class="nx">r</span><span class="p">)</span>
	<span class="k">return</span> <span class="mi">2</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>返回结果是什么？</p>
<p>如果改成这样呢？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Test3</span><span class="p">()</span> <span class="p">(</span><span class="nx">r</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="nx">r</span> <span class="p">=</span> <span class="o">*</span><span class="nx">r</span> <span class="o">+</span> <span class="mi">2</span>
	<span class="p">}(</span><span class="o">&amp;</span><span class="nx">r</span><span class="p">)</span>
	<span class="k">return</span> <span class="mi">2</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="问题3">问题3</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="nf">e1</span><span class="p">()</span>
  <span class="nf">e2</span><span class="p">()</span>
  <span class="nf">e3</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">e1</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;e1 defer err&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">e2</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}()</span>
	<span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;e2 defer err&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">e3</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}(</span><span class="nx">err</span><span class="p">)</span>
	<span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;e3 defer err&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个返回结果又是什么呢？</p>
<h2 id="总结-1">总结</h2>
<p>最后这三道题这里就当作思考题吧，自己运行一下，看看你们想的和运行结果是否一致呢？</p>
<p>如果有问题欢迎来找我讨论，因为目前没有留言功能，大家可以加入我的交流群，我们一起交流成长。因为是微信群，会有过期时间，所以大家关注我的公众号，获取入群二维码，或者添加我的个人微信，我拉你入群。</p>
<p><strong>好啦，这篇文章就到这里啦，素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！</strong></p>
<p><strong>结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。</strong></p>
<p><strong>我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。</strong></p>
<p><strong>翻译了一份Machinery中文文档，会定期进行维护，有需要的小伙伴们后台回复[machinery]即可获取。</strong></p>
<p>**我是asong，一名普普通通的程序猿，让gi我一起慢慢变强吧。欢迎各位的关注，我们下期见~~~**</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://song-oss.oss-cn-beijing.aliyuncs.com/wx/qrcode_for_gh_169729c17b9c_344.jpg"
        data-srcset="https://song-oss.oss-cn-beijing.aliyuncs.com/wx/qrcode_for_gh_169729c17b9c_344.jpg, https://song-oss.oss-cn-beijing.aliyuncs.com/wx/qrcode_for_gh_169729c17b9c_344.jpg 1.5x, https://song-oss.oss-cn-beijing.aliyuncs.com/wx/qrcode_for_gh_169729c17b9c_344.jpg 2x"
        data-sizes="auto"
        alt="https://song-oss.oss-cn-beijing.aliyuncs.com/wx/qrcode_for_gh_169729c17b9c_344.jpg"
        title="https://song-oss.oss-cn-beijing.aliyuncs.com/wx/qrcode_for_gh_169729c17b9c_344.jpg" /></p>
<p>推荐往期文章：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/4QG69Qh1q7_i0lJdxKXWyg" target="_blank" rel="noopener noreffer">machinery-go异步任务队列</a></li>
<li><a href="https://mp.weixin.qq.com/s/wURQFRt2ISz66icW7jbHFw" target="_blank" rel="noopener noreffer">Leaf—Segment分布式ID生成系统（Golang实现版本）</a></li>
<li><a href="https://mp.weixin.qq.com/s/rZBsoKuS-ORvV3kML39jKw" target="_blank" rel="noopener noreffer">十张动图带你搞懂排序算法(附go实现代码)</a></li>
<li><a href="https://mp.weixin.qq.com/s/PaTPwRjG5dFMnOSbOlKcQA" target="_blank" rel="noopener noreffer">Go语言相关书籍推荐（从入门到放弃）</a></li>
<li><a href="https://mp.weixin.qq.com/s/JHbFh2GhoKewlemq7iI59Q" target="_blank" rel="noopener noreffer">go参数传递类型</a></li>
<li><a href="https://mp.weixin.qq.com/s/0MykGst1e2pgnXXUjojvhQ" target="_blank" rel="noopener noreffer">手把手教姐姐写消息队列</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIzMDU0MTA3Nw==&amp;mid=2247483988&amp;idx=1&amp;sn=3bd52650907867d65f1c4d5c3cff8f13&amp;chksm=e8b0902edfc71938f7d7a29246d7278ac48e6c104ba27c684e12e840892252b0823de94b94c1&amp;token=1558933779&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreffer">常见面试题之缓存雪崩、缓存穿透、缓存击穿</a></li>
<li><a href="https://mp.weixin.qq.com/s/JKMHUpwXzLoSzWt_ElptFg" target="_blank" rel="noopener noreffer">详解Context包，看这一篇就够了！！！</a></li>
<li><a href="https://mp.weixin.qq.com/s/mV2hnfctQuRLRKpPPT9XRw" target="_blank" rel="noopener noreffer">go-ElasticSearch入门看这一篇就够了(一)</a></li>
<li><a href="https://mp.weixin.qq.com/s/G7z80u83LTgLyfHgzgrd9g" target="_blank" rel="noopener noreffer">面试官：go中for-range使用过吗？这几个问题你能解释一下原因吗</a></li>
<li><a href="https://mp.weixin.qq.com/s/qmbCmwZGmqKIZDlNs_a3Vw" target="_blank" rel="noopener noreffer">学会wire依赖注入、cron定时任务其实就这么简单！</a></li>
</ul>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2021-01-10</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/index.md" target="_blank">阅读原始文档</a>
                        </span></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" data-title="详解defer实现机制(附上三道面试题，我不信你们都能做对)" data-ralateuid="u/6784500990"><i class="fab fa-weibo fa-fw"></i></a><a href="javascript:void(0);" title="分享到 百度" data-sharer="baidu" data-url="https://asong2020.github.io/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90defer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" data-title="详解defer实现机制(附上三道面试题，我不信你们都能做对)"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/baidu.svg"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/defer/">defer</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/%E7%90%86%E8%A7%A3interface/" class="prev" rel="prev" title="源码剖析Go语言的interface"><i class="fas fa-angle-left fa-fw"></i>源码剖析Go语言的interface</a>
            <a href="/panic%E5%92%8Crecover/" class="next" rel="next" title="详解Go语言中的panic和recover">详解Go语言中的panic和recover<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"></div></article></div>
            </main><footer class="footer">
        <script src="https://utteranc.es/client.js"
                repo="liangyuanpeng/liangyuanpeng.github.io"
                issue-term="title"
                theme="github-light"
                crossorigin="anonymous"
                async>
        </script>
        <div class="footer-container"><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2019 - 2021</span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lunr@2.3.8/lunr.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.stemmer.support.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.zh.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/typeit@7.0.4/dist/typeit.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"data":{"id-1":"Golang梦工厂","id-2":"Golang梦工厂"},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"},"typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"id-1":["id-1"],"id-2":["id-2"]},"duration":-1,"speed":100}};</script><script type="text/javascript" src="/js/theme.min.js"></script><script type="text/javascript">
            window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());
            gtag('config', 'G-LR8SD4JYBT', { 'anonymize_ip': true });
        </script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=G-LR8SD4JYBT" async></script></body>
</html>
